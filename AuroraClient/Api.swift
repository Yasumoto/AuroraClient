/**
 * Autogenerated by Thrift Compiler (1.0.0-dev)
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */

import Foundation

import Thrift


public enum ResponseCode : Int32 {
  case INVALID_REQUEST = 0
  case OK = 1
  case ERROR = 2
  case WARNING = 3
  case AUTH_FAILED = 4
  case LOCK_ERROR = 5
  case ERROR_TRANSIENT = 6

  public init() { self.init(rawValue: 0)! }
}

public enum MaintenanceMode : Int32 {
  case NONE = 1
  case SCHEDULED = 2
  case DRAINING = 3
  case DRAINED = 4

  public init() { self.init(rawValue: 1)! }
}

public enum LockValidation : Int32 {
  case CHECKED = 0
  case UNCHECKED = 1

  public init() { self.init(rawValue: 0)! }
}

public enum Mode : Int32 {
  case RW = 1
  case RO = 2

  public init() { self.init(rawValue: 1)! }
}

public enum CronCollisionPolicy : Int32 {
  case KILL_EXISTING = 0
  case CANCEL_NEW = 1
  case RUN_OVERLAP = 2

  public init() { self.init(rawValue: 0)! }
}

public enum ScheduleStatus : Int32 {
  case INIT = 11
  case THROTTLED = 16
  case PENDING = 0
  case ASSIGNED = 9
  case STARTING = 1
  case RUNNING = 2
  case FINISHED = 3
  case PREEMPTING = 13
  case RESTARTING = 12
  case DRAINING = 17
  case FAILED = 4
  case KILLED = 5
  case KILLING = 6
  case LOST = 7

  public init() { self.init(rawValue: 11)! }
}

public enum JobUpdateStatus : Int32 {
  case ROLLING_FORWARD = 0
  case ROLLING_BACK = 1
  case ROLL_FORWARD_PAUSED = 2
  case ROLL_BACK_PAUSED = 3
  case ROLLED_FORWARD = 4
  case ROLLED_BACK = 5
  case ABORTED = 6
  case ERROR = 7
  case FAILED = 8
  case ROLL_FORWARD_AWAITING_PULSE = 9
  case ROLL_BACK_AWAITING_PULSE = 10

  public init() { self.init(rawValue: 0)! }
}

public enum JobUpdateAction : Int32 {
  case INSTANCE_UPDATED = 1
  case INSTANCE_ROLLED_BACK = 2
  case INSTANCE_UPDATING = 3
  case INSTANCE_ROLLING_BACK = 4
  case INSTANCE_UPDATE_FAILED = 5
  case INSTANCE_ROLLBACK_FAILED = 6

  public init() { self.init(rawValue: 1)! }
}

public enum JobUpdatePulseStatus : Int32 {
  case OK = 1
  case FINISHED = 2

  public init() { self.init(rawValue: 1)! }
}

public struct APIVersion {

  public var major = Int32()

  public init() {
  }

  public init(major: Int32) {
    self.major = major
  }

}

public struct Identity {

  public var role = String()

  public var user = String()

  public init() {
  }

  public init(role: String, user: String) {
    self.role = role
    self.user = user
  }

}

public struct SessionKey {

  public var mechanism : String?

  public var data : TBinary?

  public init() {
  }

  public init(mechanism: String?, data: TBinary?) {
    self.mechanism = mechanism
    self.data = data
  }

}

public struct ResourceAggregate {

  public var numCpus = Double()

  public var ramMb = Int64()

  public var diskMb = Int64()

  public init() {
  }

  public init(numCpus: Double, ramMb: Int64, diskMb: Int64) {
    self.numCpus = numCpus
    self.ramMb = ramMb
    self.diskMb = diskMb
  }

}

public struct Attribute {

  public var name = String()

  public var values = TSet<String>()

  public init() {
  }

  public init(name: String, values: TSet<String>) {
    self.name = name
    self.values = values
  }

}

public struct HostAttributes {

  public var host = String()

  public var attributes = TSet<Attribute>()

  public var mode : MaintenanceMode?

  public var slaveId : String?

  public init() {
  }

  public init(host: String, attributes: TSet<Attribute>) {
    self.host = host
    self.attributes = attributes
  }

  public init(host: String, attributes: TSet<Attribute>, mode: MaintenanceMode?, slaveId: String?) {
    self.host = host
    self.attributes = attributes
    self.mode = mode
    self.slaveId = slaveId
  }

}

public struct ValueConstraint {

  public var negated = Bool()

  public var values = TSet<String>()

  public init() {
  }

  public init(negated: Bool, values: TSet<String>) {
    self.negated = negated
    self.values = values
  }

}

public struct LimitConstraint {

  public var limit = Int32()

  public init() {
  }

  public init(limit: Int32) {
    self.limit = limit
  }

}

public struct TaskConstraint {

  public var value = ValueConstraint()

  public var limit = LimitConstraint()

  public init() {
  }

  public init(value: ValueConstraint, limit: LimitConstraint) {
    self.value = value
    self.limit = limit
  }

}

public struct Constraint {

  public var name = String()

  public var constraint = TaskConstraint()

  public init() {
  }

  public init(name: String, constraint: TaskConstraint) {
    self.name = name
    self.constraint = constraint
  }

}

public struct Package {

  public var role = String()

  public var name = String()

  public var version = Int32()

  public init() {
  }

  public init(role: String, name: String, version: Int32) {
    self.role = role
    self.name = name
    self.version = version
  }

}

public struct Metadata {

  public var key = String()

  public var value = String()

  public init() {
  }

  public init(key: String, value: String) {
    self.key = key
    self.value = value
  }

}

public struct JobKey {

  public var role = String()

  public var environment = String()

  public var name = String()

  public init() {
  }

  public init(role: String, environment: String, name: String) {
    self.role = role
    self.environment = environment
    self.name = name
  }

}

public struct LockKey {

  public var job = JobKey()

  public init() {
  }

  public init(job: JobKey) {
    self.job = job
  }

}

public struct Lock {

  public var key = LockKey()

  public var token = String()

  public var user = String()

  public var timestampMs = Int64()

  public var message : String?

  public init() {
  }

  public init(key: LockKey, token: String, user: String, timestampMs: Int64) {
    self.key = key
    self.token = token
    self.user = user
    self.timestampMs = timestampMs
  }

  public init(key: LockKey, token: String, user: String, timestampMs: Int64, message: String?) {
    self.key = key
    self.token = token
    self.user = user
    self.timestampMs = timestampMs
    self.message = message
  }

}

public struct InstanceKey {

  public var jobKey = JobKey()

  public var instanceId = Int32()

  public init() {
  }

  public init(jobKey: JobKey, instanceId: Int32) {
    self.jobKey = jobKey
    self.instanceId = instanceId
  }

}

public struct ExecutorConfig {

  public var name = String()

  public var data = String()

  public init() {
  }

  public init(name: String, data: String) {
    self.name = name
    self.data = data
  }

}

public struct Volume {

  public var containerPath = String()

  public var hostPath = String()

  public var mode = Mode()

  public init() {
  }

  public init(containerPath: String, hostPath: String, mode: Mode) {
    self.containerPath = containerPath
    self.hostPath = hostPath
    self.mode = mode
  }

}

public struct MesosContainer {

  public init() {
  }

}

public struct DockerParameter {

  public var name = String()

  public var value = String()

  public init() {
  }

  public init(name: String, value: String) {
    self.name = name
    self.value = value
  }

}

public struct DockerContainer {

  public var image = String()

  public var parameters : TList<DockerParameter>?

  public init() {
  }

  public init(image: String) {
    self.image = image
  }

  public init(image: String, parameters: TList<DockerParameter>?) {
    self.image = image
    self.parameters = parameters
  }

}

public struct Container {

  public var mesos = MesosContainer()

  public var docker = DockerContainer()

  public init() {
  }

  public init(mesos: MesosContainer, docker: DockerContainer) {
    self.mesos = mesos
    self.docker = docker
  }

}

public struct TaskConfig {

  public var job = JobKey()

  public var owner = Identity()

  public var environment = String()

  public var jobName = String()

  public var isService = Bool()

  public var numCpus = Double()

  public var ramMb = Int64()

  public var diskMb = Int64()

  public var priority = Int32()

  public var maxTaskFailures = Int32()

  public var production : Bool?

  public var tier : String?

  public var constraints = TSet<Constraint>()

  public var requestedPorts = TSet<String>()

  public var taskLinks : TMap<String, String>?

  public var contactEmail : String?

  public var executorConfig : ExecutorConfig?

  public var metadata : TSet<Metadata>?

  public var container = Container()

  public init() {
  }

  public init(job: JobKey, owner: Identity, environment: String, jobName: String, isService: Bool, numCpus: Double, ramMb: Int64, diskMb: Int64, priority: Int32, maxTaskFailures: Int32, constraints: TSet<Constraint>, requestedPorts: TSet<String>, container: Container) {
    self.job = job
    self.owner = owner
    self.environment = environment
    self.jobName = jobName
    self.isService = isService
    self.numCpus = numCpus
    self.ramMb = ramMb
    self.diskMb = diskMb
    self.priority = priority
    self.maxTaskFailures = maxTaskFailures
    self.constraints = constraints
    self.requestedPorts = requestedPorts
    self.container = container
  }

  public init(job: JobKey, owner: Identity, environment: String, jobName: String, isService: Bool, numCpus: Double, ramMb: Int64, diskMb: Int64, priority: Int32, maxTaskFailures: Int32, production: Bool?, tier: String?, constraints: TSet<Constraint>, requestedPorts: TSet<String>, taskLinks: TMap<String, String>?, contactEmail: String?, executorConfig: ExecutorConfig?, metadata: TSet<Metadata>?, container: Container) {
    self.job = job
    self.owner = owner
    self.environment = environment
    self.jobName = jobName
    self.isService = isService
    self.numCpus = numCpus
    self.ramMb = ramMb
    self.diskMb = diskMb
    self.priority = priority
    self.maxTaskFailures = maxTaskFailures
    self.production = production
    self.tier = tier
    self.constraints = constraints
    self.requestedPorts = requestedPorts
    self.taskLinks = taskLinks
    self.contactEmail = contactEmail
    self.executorConfig = executorConfig
    self.metadata = metadata
    self.container = container
  }

}

public struct JobConfiguration {

  public var key = JobKey()

  public var owner = Identity()

  public var cronSchedule = String()

  public var cronCollisionPolicy = CronCollisionPolicy()

  public var taskConfig = TaskConfig()

  public var instanceCount = Int32()

  public init() {
  }

  public init(key: JobKey, owner: Identity, cronSchedule: String, cronCollisionPolicy: CronCollisionPolicy, taskConfig: TaskConfig, instanceCount: Int32) {
    self.key = key
    self.owner = owner
    self.cronSchedule = cronSchedule
    self.cronCollisionPolicy = cronCollisionPolicy
    self.taskConfig = taskConfig
    self.instanceCount = instanceCount
  }

}

public struct JobStats {

  public var activeTaskCount = Int32()

  public var finishedTaskCount = Int32()

  public var failedTaskCount = Int32()

  public var pendingTaskCount = Int32()

  public init() {
  }

  public init(activeTaskCount: Int32, finishedTaskCount: Int32, failedTaskCount: Int32, pendingTaskCount: Int32) {
    self.activeTaskCount = activeTaskCount
    self.finishedTaskCount = finishedTaskCount
    self.failedTaskCount = failedTaskCount
    self.pendingTaskCount = pendingTaskCount
  }

}

public struct JobSummary {

  public var job = JobConfiguration()

  public var stats = JobStats()

  public var nextCronRunMs : Int64?

  public init() {
  }

  public init(job: JobConfiguration, stats: JobStats) {
    self.job = job
    self.stats = stats
  }

  public init(job: JobConfiguration, stats: JobStats, nextCronRunMs: Int64?) {
    self.job = job
    self.stats = stats
    self.nextCronRunMs = nextCronRunMs
  }

}

public struct AddInstancesConfig {

  public var key = JobKey()

  public var taskConfig = TaskConfig()

  public var instanceIds = TSet<Int32>()

  public init() {
  }

  public init(key: JobKey, taskConfig: TaskConfig, instanceIds: TSet<Int32>) {
    self.key = key
    self.taskConfig = taskConfig
    self.instanceIds = instanceIds
  }

}

public struct Range {

  public var first = Int32()

  public var last = Int32()

  public init() {
  }

  public init(first: Int32, last: Int32) {
    self.first = first
    self.last = last
  }

}

public struct ConfigGroup {

  public var config = TaskConfig()

  public var instanceIds = TSet<Int32>()

  public init() {
  }

  public init(config: TaskConfig, instanceIds: TSet<Int32>) {
    self.config = config
    self.instanceIds = instanceIds
  }

}

public struct ConfigSummary {

  public var key = JobKey()

  public var groups = TSet<ConfigGroup>()

  public init() {
  }

  public init(key: JobKey, groups: TSet<ConfigGroup>) {
    self.key = key
    self.groups = groups
  }

}

public struct PopulateJobResult {

  public var taskConfig = TaskConfig()

  public init() {
  }

  public init(taskConfig: TaskConfig) {
    self.taskConfig = taskConfig
  }

}

public struct GetQuotaResult {

  public var quota = ResourceAggregate()

  public var prodSharedConsumption : ResourceAggregate?

  public var nonProdSharedConsumption : ResourceAggregate?

  public var prodDedicatedConsumption : ResourceAggregate?

  public var nonProdDedicatedConsumption : ResourceAggregate?

  public init() {
  }

  public init(quota: ResourceAggregate) {
    self.quota = quota
  }

  public init(quota: ResourceAggregate, prodSharedConsumption: ResourceAggregate?, nonProdSharedConsumption: ResourceAggregate?, prodDedicatedConsumption: ResourceAggregate?, nonProdDedicatedConsumption: ResourceAggregate?) {
    self.quota = quota
    self.prodSharedConsumption = prodSharedConsumption
    self.nonProdSharedConsumption = nonProdSharedConsumption
    self.prodDedicatedConsumption = prodDedicatedConsumption
    self.nonProdDedicatedConsumption = nonProdDedicatedConsumption
  }

}

public struct AcquireLockResult {

  public var lock = Lock()

  public init() {
  }

  public init(lock: Lock) {
    self.lock = lock
  }

}

public struct TaskEvent {

  public var timestamp = Int64()

  public var status = ScheduleStatus()

  public var message : String?

  public var scheduler : String?

  public init() {
  }

  public init(timestamp: Int64, status: ScheduleStatus) {
    self.timestamp = timestamp
    self.status = status
  }

  public init(timestamp: Int64, status: ScheduleStatus, message: String?, scheduler: String?) {
    self.timestamp = timestamp
    self.status = status
    self.message = message
    self.scheduler = scheduler
  }

}

public struct AssignedTask {

  public var taskId = String()

  public var slaveId = String()

  public var slaveHost = String()

  public var task = TaskConfig()

  public var assignedPorts = TMap<String, Int32>()

  public var instanceId = Int32()

  public init() {
  }

  public init(taskId: String, slaveId: String, slaveHost: String, task: TaskConfig, assignedPorts: TMap<String, Int32>, instanceId: Int32) {
    self.taskId = taskId
    self.slaveId = slaveId
    self.slaveHost = slaveHost
    self.task = task
    self.assignedPorts = assignedPorts
    self.instanceId = instanceId
  }

}

public struct ScheduledTask {

  public var assignedTask = AssignedTask()

  public var status = ScheduleStatus()

  public var failureCount = Int32()

  public var taskEvents = TList<TaskEvent>()

  public var ancestorId = String()

  public init() {
  }

  public init(assignedTask: AssignedTask, status: ScheduleStatus, failureCount: Int32, taskEvents: TList<TaskEvent>, ancestorId: String) {
    self.assignedTask = assignedTask
    self.status = status
    self.failureCount = failureCount
    self.taskEvents = taskEvents
    self.ancestorId = ancestorId
  }

}

public struct ScheduleStatusResult {

  public var tasks = TList<ScheduledTask>()

  public init() {
  }

  public init(tasks: TList<ScheduledTask>) {
    self.tasks = tasks
  }

}

public struct GetJobsResult {

  public var configs = TSet<JobConfiguration>()

  public init() {
  }

  public init(configs: TSet<JobConfiguration>) {
    self.configs = configs
  }

}

public struct TaskQuery {

  public var owner = Identity()

  public var role = String()

  public var environment = String()

  public var jobName = String()

  public var taskIds = TSet<String>()

  public var statuses = TSet<ScheduleStatus>()

  public var instanceIds = TSet<Int32>()

  public var slaveHosts = TSet<String>()

  public var jobKeys = TSet<JobKey>()

  public var offset = Int32()

  public var limit = Int32()

  public init() {
  }

  public init(owner: Identity, role: String, environment: String, jobName: String, taskIds: TSet<String>, statuses: TSet<ScheduleStatus>, instanceIds: TSet<Int32>, slaveHosts: TSet<String>, jobKeys: TSet<JobKey>, offset: Int32, limit: Int32) {
    self.owner = owner
    self.role = role
    self.environment = environment
    self.jobName = jobName
    self.taskIds = taskIds
    self.statuses = statuses
    self.instanceIds = instanceIds
    self.slaveHosts = slaveHosts
    self.jobKeys = jobKeys
    self.offset = offset
    self.limit = limit
  }

}

public struct HostStatus {

  public var host = String()

  public var mode = MaintenanceMode()

  public init() {
  }

  public init(host: String, mode: MaintenanceMode) {
    self.host = host
    self.mode = mode
  }

}

public struct RoleSummary {

  public var role = String()

  public var jobCount = Int32()

  public var cronJobCount = Int32()

  public init() {
  }

  public init(role: String, jobCount: Int32, cronJobCount: Int32) {
    self.role = role
    self.jobCount = jobCount
    self.cronJobCount = cronJobCount
  }

}

public struct Hosts {

  public var hostNames = TSet<String>()

  public init() {
  }

  public init(hostNames: TSet<String>) {
    self.hostNames = hostNames
  }

}

public struct PendingReason {

  public var taskId = String()

  public var reason = String()

  public init() {
  }

  public init(taskId: String, reason: String) {
    self.taskId = taskId
    self.reason = reason
  }

}

public struct JobUpdateKey {

  public var job = JobKey()

  public var id = String()

  public init() {
  }

  public init(job: JobKey, id: String) {
    self.job = job
    self.id = id
  }

}

public struct JobUpdateSettings {

  public var updateGroupSize = Int32()

  public var maxPerInstanceFailures = Int32()

  public var maxFailedInstances = Int32()

  public var maxWaitToInstanceRunningMs = Int32()

  public var minWaitInInstanceRunningMs = Int32()

  public var rollbackOnFailure = Bool()

  public var updateOnlyTheseInstances = TSet<Range>()

  public var waitForBatchCompletion = Bool()

  public var blockIfNoPulsesAfterMs : Int32?

  public init() {
  }

  public init(updateGroupSize: Int32, maxPerInstanceFailures: Int32, maxFailedInstances: Int32, maxWaitToInstanceRunningMs: Int32, minWaitInInstanceRunningMs: Int32, rollbackOnFailure: Bool, updateOnlyTheseInstances: TSet<Range>, waitForBatchCompletion: Bool) {
    self.updateGroupSize = updateGroupSize
    self.maxPerInstanceFailures = maxPerInstanceFailures
    self.maxFailedInstances = maxFailedInstances
    self.maxWaitToInstanceRunningMs = maxWaitToInstanceRunningMs
    self.minWaitInInstanceRunningMs = minWaitInInstanceRunningMs
    self.rollbackOnFailure = rollbackOnFailure
    self.updateOnlyTheseInstances = updateOnlyTheseInstances
    self.waitForBatchCompletion = waitForBatchCompletion
  }

  public init(updateGroupSize: Int32, maxPerInstanceFailures: Int32, maxFailedInstances: Int32, maxWaitToInstanceRunningMs: Int32, minWaitInInstanceRunningMs: Int32, rollbackOnFailure: Bool, updateOnlyTheseInstances: TSet<Range>, waitForBatchCompletion: Bool, blockIfNoPulsesAfterMs: Int32?) {
    self.updateGroupSize = updateGroupSize
    self.maxPerInstanceFailures = maxPerInstanceFailures
    self.maxFailedInstances = maxFailedInstances
    self.maxWaitToInstanceRunningMs = maxWaitToInstanceRunningMs
    self.minWaitInInstanceRunningMs = minWaitInInstanceRunningMs
    self.rollbackOnFailure = rollbackOnFailure
    self.updateOnlyTheseInstances = updateOnlyTheseInstances
    self.waitForBatchCompletion = waitForBatchCompletion
    self.blockIfNoPulsesAfterMs = blockIfNoPulsesAfterMs
  }

}

public struct JobUpdateEvent {

  public var status = JobUpdateStatus()

  public var timestampMs = Int64()

  public var user : String?

  public var message : String?

  public init() {
  }

  public init(status: JobUpdateStatus, timestampMs: Int64) {
    self.status = status
    self.timestampMs = timestampMs
  }

  public init(status: JobUpdateStatus, timestampMs: Int64, user: String?, message: String?) {
    self.status = status
    self.timestampMs = timestampMs
    self.user = user
    self.message = message
  }

}

public struct JobInstanceUpdateEvent {

  public var instanceId = Int32()

  public var timestampMs = Int64()

  public var action = JobUpdateAction()

  public init() {
  }

  public init(instanceId: Int32, timestampMs: Int64, action: JobUpdateAction) {
    self.instanceId = instanceId
    self.timestampMs = timestampMs
    self.action = action
  }

}

public struct InstanceTaskConfig {

  public var task = TaskConfig()

  public var instances = TSet<Range>()

  public init() {
  }

  public init(task: TaskConfig, instances: TSet<Range>) {
    self.task = task
    self.instances = instances
  }

}

public struct JobUpdateState {

  public var status = JobUpdateStatus()

  public var createdTimestampMs = Int64()

  public var lastModifiedTimestampMs = Int64()

  public init() {
  }

  public init(status: JobUpdateStatus, createdTimestampMs: Int64, lastModifiedTimestampMs: Int64) {
    self.status = status
    self.createdTimestampMs = createdTimestampMs
    self.lastModifiedTimestampMs = lastModifiedTimestampMs
  }

}

public struct JobUpdateSummary {

  public var key = JobUpdateKey()

  public var user = String()

  public var state = JobUpdateState()

  public init() {
  }

  public init(key: JobUpdateKey, user: String, state: JobUpdateState) {
    self.key = key
    self.user = user
    self.state = state
  }

}

public struct JobUpdateInstructions {

  public var initialState = TSet<InstanceTaskConfig>()

  public var desiredState = InstanceTaskConfig()

  public var settings = JobUpdateSettings()

  public init() {
  }

  public init(initialState: TSet<InstanceTaskConfig>, desiredState: InstanceTaskConfig, settings: JobUpdateSettings) {
    self.initialState = initialState
    self.desiredState = desiredState
    self.settings = settings
  }

}

public struct JobUpdate {

  public var summary = JobUpdateSummary()

  public var instructions = JobUpdateInstructions()

  public init() {
  }

  public init(summary: JobUpdateSummary, instructions: JobUpdateInstructions) {
    self.summary = summary
    self.instructions = instructions
  }

}

public struct JobUpdateDetails {

  public var update = JobUpdate()

  public var updateEvents = TList<JobUpdateEvent>()

  public var instanceEvents = TList<JobInstanceUpdateEvent>()

  public init() {
  }

  public init(update: JobUpdate, updateEvents: TList<JobUpdateEvent>, instanceEvents: TList<JobInstanceUpdateEvent>) {
    self.update = update
    self.updateEvents = updateEvents
    self.instanceEvents = instanceEvents
  }

}

public struct JobUpdateRequest {

  public var taskConfig = TaskConfig()

  public var instanceCount = Int32()

  public var settings = JobUpdateSettings()

  public init() {
  }

  public init(taskConfig: TaskConfig, instanceCount: Int32, settings: JobUpdateSettings) {
    self.taskConfig = taskConfig
    self.instanceCount = instanceCount
    self.settings = settings
  }

}

public struct JobUpdateQuery {

  public var role = String()

  public var key = JobUpdateKey()

  public var jobKey = JobKey()

  public var user = String()

  public var updateStatuses = TSet<JobUpdateStatus>()

  public var offset = Int32()

  public var limit = Int32()

  public init() {
  }

  public init(role: String, key: JobUpdateKey, jobKey: JobKey, user: String, updateStatuses: TSet<JobUpdateStatus>, offset: Int32, limit: Int32) {
    self.role = role
    self.key = key
    self.jobKey = jobKey
    self.user = user
    self.updateStatuses = updateStatuses
    self.offset = offset
    self.limit = limit
  }

}

public struct ListBackupsResult {

  public var backups = TSet<String>()

  public init() {
  }

  public init(backups: TSet<String>) {
    self.backups = backups
  }

}

public struct StartMaintenanceResult {

  public var statuses = TSet<HostStatus>()

  public init() {
  }

  public init(statuses: TSet<HostStatus>) {
    self.statuses = statuses
  }

}

public struct DrainHostsResult {

  public var statuses = TSet<HostStatus>()

  public init() {
  }

  public init(statuses: TSet<HostStatus>) {
    self.statuses = statuses
  }

}

public struct QueryRecoveryResult {

  public var tasks = TSet<ScheduledTask>()

  public init() {
  }

  public init(tasks: TSet<ScheduledTask>) {
    self.tasks = tasks
  }

}

public struct MaintenanceStatusResult {

  public var statuses = TSet<HostStatus>()

  public init() {
  }

  public init(statuses: TSet<HostStatus>) {
    self.statuses = statuses
  }

}

public struct EndMaintenanceResult {

  public var statuses = TSet<HostStatus>()

  public init() {
  }

  public init(statuses: TSet<HostStatus>) {
    self.statuses = statuses
  }

}

public struct RoleSummaryResult {

  public var summaries = TSet<RoleSummary>()

  public init() {
  }

  public init(summaries: TSet<RoleSummary>) {
    self.summaries = summaries
  }

}

public struct JobSummaryResult {

  public var summaries = TSet<JobSummary>()

  public init() {
  }

  public init(summaries: TSet<JobSummary>) {
    self.summaries = summaries
  }

}

public struct GetLocksResult {

  public var locks = TSet<Lock>()

  public init() {
  }

  public init(locks: TSet<Lock>) {
    self.locks = locks
  }

}

public struct ConfigSummaryResult {

  public var summary = ConfigSummary()

  public init() {
  }

  public init(summary: ConfigSummary) {
    self.summary = summary
  }

}

public struct GetPendingReasonResult {

  public var reasons = TSet<PendingReason>()

  public init() {
  }

  public init(reasons: TSet<PendingReason>) {
    self.reasons = reasons
  }

}

public struct StartJobUpdateResult {

  public var key = JobUpdateKey()

  public init() {
  }

  public init(key: JobUpdateKey) {
    self.key = key
  }

}

public struct GetJobUpdateSummariesResult {

  public var updateSummaries = TList<JobUpdateSummary>()

  public init() {
  }

  public init(updateSummaries: TList<JobUpdateSummary>) {
    self.updateSummaries = updateSummaries
  }

}

public struct GetJobUpdateDetailsResult {

  public var details = JobUpdateDetails()

  public init() {
  }

  public init(details: JobUpdateDetails) {
    self.details = details
  }

}

public struct PulseJobUpdateResult {

  public var status = JobUpdatePulseStatus()

  public init() {
  }

  public init(status: JobUpdatePulseStatus) {
    self.status = status
  }

}

public struct ServerInfo {

  public var clusterName = String()

  public var thriftAPIVersion = Int32()

  public var statsUrlPrefix = String()

  public init() {
  }

  public init(clusterName: String, thriftAPIVersion: Int32, statsUrlPrefix: String) {
    self.clusterName = clusterName
    self.thriftAPIVersion = thriftAPIVersion
    self.statsUrlPrefix = statsUrlPrefix
  }

}

public struct Result {

  public var populateJobResult = PopulateJobResult()

  public var scheduleStatusResult = ScheduleStatusResult()

  public var getJobsResult = GetJobsResult()

  public var getQuotaResult = GetQuotaResult()

  public var listBackupsResult = ListBackupsResult()

  public var startMaintenanceResult = StartMaintenanceResult()

  public var drainHostsResult = DrainHostsResult()

  public var queryRecoveryResult = QueryRecoveryResult()

  public var maintenanceStatusResult = MaintenanceStatusResult()

  public var endMaintenanceResult = EndMaintenanceResult()

  public var getVersionResult = APIVersion()

  public var acquireLockResult = AcquireLockResult()

  public var roleSummaryResult = RoleSummaryResult()

  public var jobSummaryResult = JobSummaryResult()

  public var getLocksResult = GetLocksResult()

  public var configSummaryResult = ConfigSummaryResult()

  public var getPendingReasonResult = GetPendingReasonResult()

  public var startJobUpdateResult = StartJobUpdateResult()

  public var getJobUpdateSummariesResult = GetJobUpdateSummariesResult()

  public var getJobUpdateDetailsResult = GetJobUpdateDetailsResult()

  public var pulseJobUpdateResult = PulseJobUpdateResult()

  public init() {
  }

  public init(populateJobResult: PopulateJobResult, scheduleStatusResult: ScheduleStatusResult, getJobsResult: GetJobsResult, getQuotaResult: GetQuotaResult, listBackupsResult: ListBackupsResult, startMaintenanceResult: StartMaintenanceResult, drainHostsResult: DrainHostsResult, queryRecoveryResult: QueryRecoveryResult, maintenanceStatusResult: MaintenanceStatusResult, endMaintenanceResult: EndMaintenanceResult, getVersionResult: APIVersion, acquireLockResult: AcquireLockResult, roleSummaryResult: RoleSummaryResult, jobSummaryResult: JobSummaryResult, getLocksResult: GetLocksResult, configSummaryResult: ConfigSummaryResult, getPendingReasonResult: GetPendingReasonResult, startJobUpdateResult: StartJobUpdateResult, getJobUpdateSummariesResult: GetJobUpdateSummariesResult, getJobUpdateDetailsResult: GetJobUpdateDetailsResult, pulseJobUpdateResult: PulseJobUpdateResult) {
    self.populateJobResult = populateJobResult
    self.scheduleStatusResult = scheduleStatusResult
    self.getJobsResult = getJobsResult
    self.getQuotaResult = getQuotaResult
    self.listBackupsResult = listBackupsResult
    self.startMaintenanceResult = startMaintenanceResult
    self.drainHostsResult = drainHostsResult
    self.queryRecoveryResult = queryRecoveryResult
    self.maintenanceStatusResult = maintenanceStatusResult
    self.endMaintenanceResult = endMaintenanceResult
    self.getVersionResult = getVersionResult
    self.acquireLockResult = acquireLockResult
    self.roleSummaryResult = roleSummaryResult
    self.jobSummaryResult = jobSummaryResult
    self.getLocksResult = getLocksResult
    self.configSummaryResult = configSummaryResult
    self.getPendingReasonResult = getPendingReasonResult
    self.startJobUpdateResult = startJobUpdateResult
    self.getJobUpdateSummariesResult = getJobUpdateSummariesResult
    self.getJobUpdateDetailsResult = getJobUpdateDetailsResult
    self.pulseJobUpdateResult = pulseJobUpdateResult
  }

}

public struct ResponseDetail {

  public var message = String()

  public init() {
  }

  public init(message: String) {
    self.message = message
  }

}

public struct Response {

  public var responseCode = ResponseCode()

  public var serverInfo = ServerInfo()

  public var result : Result?

  public var details = TList<ResponseDetail>()

  public init() {
  }

  public init(responseCode: ResponseCode, serverInfo: ServerInfo, details: TList<ResponseDetail>) {
    self.responseCode = responseCode
    self.serverInfo = serverInfo
    self.details = details
  }

  public init(responseCode: ResponseCode, serverInfo: ServerInfo, result: Result?, details: TList<ResponseDetail>) {
    self.responseCode = responseCode
    self.serverInfo = serverInfo
    self.result = result
    self.details = details
  }

}

public struct InstanceConfigRewrite {

  public var instanceKey = InstanceKey()

  public var oldTask = TaskConfig()

  public var rewrittenTask = TaskConfig()

  public init() {
  }

  public init(instanceKey: InstanceKey, oldTask: TaskConfig, rewrittenTask: TaskConfig) {
    self.instanceKey = instanceKey
    self.oldTask = oldTask
    self.rewrittenTask = rewrittenTask
  }

}

public struct JobConfigRewrite {

  public var oldJob = JobConfiguration()

  public var rewrittenJob = JobConfiguration()

  public init() {
  }

  public init(oldJob: JobConfiguration, rewrittenJob: JobConfiguration) {
    self.oldJob = oldJob
    self.rewrittenJob = rewrittenJob
  }

}

public struct ConfigRewrite {

  public var jobRewrite = JobConfigRewrite()

  public var instanceRewrite = InstanceConfigRewrite()

  public init() {
  }

  public init(jobRewrite: JobConfigRewrite, instanceRewrite: InstanceConfigRewrite) {
    self.jobRewrite = jobRewrite
    self.instanceRewrite = instanceRewrite
  }

}

public struct RewriteConfigsRequest {

  public var rewriteCommands = TList<ConfigRewrite>()

  public init() {
  }

  public init(rewriteCommands: TList<ConfigRewrite>) {
    self.rewriteCommands = rewriteCommands
  }

}

public protocol ReadOnlyScheduler {

  func getRoleSummary() throws -> Response  // exceptions: 

  func getJobSummaryWithRole(role: String) throws -> Response  // exceptions: 

  func getTasksStatusWithQuery(query: TaskQuery) throws -> Response  // exceptions: 

  func getTasksWithoutConfigsWithQuery(query: TaskQuery) throws -> Response  // exceptions: 

  func getPendingReasonWithQuery(query: TaskQuery) throws -> Response  // exceptions: 

  func getConfigSummaryWithJob(job: JobKey) throws -> Response  // exceptions: 

  func getJobsWithOwnerRole(ownerRole: String) throws -> Response  // exceptions: 

  func getQuotaWithOwnerRole(ownerRole: String) throws -> Response  // exceptions: 

  func populateJobConfigWithDescription(description: JobConfiguration) throws -> Response  // exceptions: 

  func getLocks() throws -> Response  // exceptions: 

  func getJobUpdateSummariesWithJobUpdateQuery(jobUpdateQuery: JobUpdateQuery) throws -> Response  // exceptions: 

  func getJobUpdateDetailsWithKey(key: JobUpdateKey) throws -> Response  // exceptions: 
}

public class ReadOnlySchedulerClient /* : ReadOnlyScheduler */ {

  let __inProtocol : TProtocol

  let __outProtocol : TProtocol

  public init(inoutProtocol: TProtocol) {
    __inProtocol = inoutProtocol
    __outProtocol = inoutProtocol
  }

  public init(inProtocol: TProtocol, outProtocol: TProtocol) {
    __inProtocol = inProtocol
    __outProtocol = outProtocol
  }

}

public class ReadOnlySchedulerProcessor : NSObject /* ReadOnlyScheduler */ {

  typealias ProcessorHandlerDictionary = [String: (Int, TProtocol, TProtocol, ReadOnlyScheduler) throws -> Void]

  let service : ReadOnlyScheduler

  public init(service: ReadOnlyScheduler) {
    self.service = service
  }

}

public protocol AuroraSchedulerManager {

  func createJobWithDescription(description: JobConfiguration, lock: Lock, session: SessionKey) throws -> Response  // exceptions: 

  func scheduleCronJobWithDescription(description: JobConfiguration, lock: Lock, session: SessionKey) throws -> Response  // exceptions: 

  func descheduleCronJob(job: JobKey, lock: Lock, session: SessionKey) throws -> Response  // exceptions: 

  func startCronJob(job: JobKey, session: SessionKey) throws -> Response  // exceptions: 

  func restartShardsWithJob(job: JobKey, shardIds: TSet<Int32>, lock: Lock, session: SessionKey) throws -> Response  // exceptions: 

  func killTasksWithQuery(query: TaskQuery, lock: Lock, session: SessionKey) throws -> Response  // exceptions: 

  func addInstancesWithConfig(config: AddInstancesConfig, lock: Lock, session: SessionKey) throws -> Response  // exceptions: 

  func acquireLockWithLockKey(lockKey: LockKey, session: SessionKey) throws -> Response  // exceptions: 

  func releaseLock(lock: Lock, validation: LockValidation, session: SessionKey) throws -> Response  // exceptions: 

  func replaceCronTemplateWithConfig(config: JobConfiguration, lock: Lock, session: SessionKey) throws -> Response  // exceptions: 

  func startJobUpdateWithRequest(request: JobUpdateRequest, message: String, session: SessionKey) throws -> Response  // exceptions: 

  func pauseJobUpdateWithKey(key: JobUpdateKey, message: String, session: SessionKey) throws -> Response  // exceptions: 

  func resumeJobUpdateWithKey(key: JobUpdateKey, message: String, session: SessionKey) throws -> Response  // exceptions: 

  func abortJobUpdateWithKey(key: JobUpdateKey, message: String, session: SessionKey) throws -> Response  // exceptions: 

  func pulseJobUpdateWithKey(key: JobUpdateKey, session: SessionKey) throws -> Response  // exceptions: 
}

public class AuroraSchedulerManagerClient /* : AuroraSchedulerManager */ {

  let __inProtocol : TProtocol

  let __outProtocol : TProtocol

  public init(inoutProtocol: TProtocol) {
    __inProtocol = inoutProtocol
    __outProtocol = inoutProtocol
  }

  public init(inProtocol: TProtocol, outProtocol: TProtocol) {
    __inProtocol = inProtocol
    __outProtocol = outProtocol
  }

}

public class AuroraSchedulerManagerProcessor : NSObject /* AuroraSchedulerManager */ {

  typealias ProcessorHandlerDictionary = [String: (Int, TProtocol, TProtocol, AuroraSchedulerManager) throws -> Void]

  let service : AuroraSchedulerManager

  public init(service: AuroraSchedulerManager) {
    self.service = service
  }

}

public protocol AuroraAdmin {

  func setQuotaWithOwnerRole(ownerRole: String, quota: ResourceAggregate, session: SessionKey) throws -> Response  // exceptions: 

  func forceTaskStateWithTaskId(taskId: String, status: ScheduleStatus, session: SessionKey) throws -> Response  // exceptions: 

  func performBackupWithSession(session: SessionKey) throws -> Response  // exceptions: 

  func listBackupsWithSession(session: SessionKey) throws -> Response  // exceptions: 

  func stageRecoveryWithBackupId(backupId: String, session: SessionKey) throws -> Response  // exceptions: 

  func queryRecoveryWithQuery(query: TaskQuery, session: SessionKey) throws -> Response  // exceptions: 

  func deleteRecoveryTasksWithQuery(query: TaskQuery, session: SessionKey) throws -> Response  // exceptions: 

  func commitRecoveryWithSession(session: SessionKey) throws -> Response  // exceptions: 

  func unloadRecoveryWithSession(session: SessionKey) throws -> Response  // exceptions: 

  func startMaintenanceWithHosts(hosts: Hosts, session: SessionKey) throws -> Response  // exceptions: 

  func drainHosts(hosts: Hosts, session: SessionKey) throws -> Response  // exceptions: 

  func maintenanceStatusWithHosts(hosts: Hosts, session: SessionKey) throws -> Response  // exceptions: 

  func endMaintenanceWithHosts(hosts: Hosts, session: SessionKey) throws -> Response  // exceptions: 

  func snapshotWithSession(session: SessionKey) throws -> Response  // exceptions: 

  func rewriteConfigsWithRequest(request: RewriteConfigsRequest, session: SessionKey) throws -> Response  // exceptions: 
}

public class AuroraAdminClient /* : AuroraAdmin */ {

  let __inProtocol : TProtocol

  let __outProtocol : TProtocol

  public init(inoutProtocol: TProtocol) {
    __inProtocol = inoutProtocol
    __outProtocol = inoutProtocol
  }

  public init(inProtocol: TProtocol, outProtocol: TProtocol) {
    __inProtocol = inProtocol
    __outProtocol = outProtocol
  }

}

public class AuroraAdminProcessor : NSObject /* AuroraAdmin */ {

  typealias ProcessorHandlerDictionary = [String: (Int, TProtocol, TProtocol, AuroraAdmin) throws -> Void]

  let service : AuroraAdmin

  public init(service: AuroraAdmin) {
    self.service = service
  }

}

public let THRIFT_API_VERSION : Int32 = Int32(3)

public let CURRENT_API_VERSION : APIVersion = APIVersion(major: Int32(3))

public let AURORA_EXECUTOR_NAME : String = "AuroraExecutor"

public let ACTIVE_STATES : TSet<ScheduleStatus> = []

public let SLAVE_ASSIGNED_STATES : TSet<ScheduleStatus> = []

public let LIVE_STATES : TSet<ScheduleStatus> = []

public let TERMINAL_STATES : TSet<ScheduleStatus> = []

public let GOOD_IDENTIFIER_PATTERN : String = "^[\\w\\-\\.]+$"

public let GOOD_IDENTIFIER_PATTERN_JVM : String = "^[\\w\\-\\.]+$"

public let GOOD_IDENTIFIER_PATTERN_PYTHON : String = "^[\\w\\-\\.]+$"

public let ACTIVE_JOB_UPDATE_STATES : TSet<JobUpdateStatus> = []


