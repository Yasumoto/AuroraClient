/**
 * Autogenerated by Thrift Compiler (1.0.0-dev)
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */

import Foundation

import Thrift


extension ResponseCode : TEnum {

  public static func readValueFromProtocol(proto: TProtocol) throws -> ResponseCode {
    var raw = Int32()
    try proto.readI32(&raw)
    return ResponseCode(rawValue: raw)!
  }

  public static func writeValue(value: ResponseCode, toProtocol proto: TProtocol) throws {
    try proto.writeI32(value.rawValue)
  }

}

extension MaintenanceMode : TEnum {

  public static func readValueFromProtocol(proto: TProtocol) throws -> MaintenanceMode {
    var raw = Int32()
    try proto.readI32(&raw)
    return MaintenanceMode(rawValue: raw)!
  }

  public static func writeValue(value: MaintenanceMode, toProtocol proto: TProtocol) throws {
    try proto.writeI32(value.rawValue)
  }

}

extension LockValidation : TEnum {

  public static func readValueFromProtocol(proto: TProtocol) throws -> LockValidation {
    var raw = Int32()
    try proto.readI32(&raw)
    return LockValidation(rawValue: raw)!
  }

  public static func writeValue(value: LockValidation, toProtocol proto: TProtocol) throws {
    try proto.writeI32(value.rawValue)
  }

}

extension Mode : TEnum {

  public static func readValueFromProtocol(proto: TProtocol) throws -> Mode {
    var raw = Int32()
    try proto.readI32(&raw)
    return Mode(rawValue: raw)!
  }

  public static func writeValue(value: Mode, toProtocol proto: TProtocol) throws {
    try proto.writeI32(value.rawValue)
  }

}

extension CronCollisionPolicy : TEnum {

  public static func readValueFromProtocol(proto: TProtocol) throws -> CronCollisionPolicy {
    var raw = Int32()
    try proto.readI32(&raw)
    return CronCollisionPolicy(rawValue: raw)!
  }

  public static func writeValue(value: CronCollisionPolicy, toProtocol proto: TProtocol) throws {
    try proto.writeI32(value.rawValue)
  }

}

extension ScheduleStatus : TEnum {

  public static func readValueFromProtocol(proto: TProtocol) throws -> ScheduleStatus {
    var raw = Int32()
    try proto.readI32(&raw)
    return ScheduleStatus(rawValue: raw)!
  }

  public static func writeValue(value: ScheduleStatus, toProtocol proto: TProtocol) throws {
    try proto.writeI32(value.rawValue)
  }

}

extension JobUpdateStatus : TEnum {

  public static func readValueFromProtocol(proto: TProtocol) throws -> JobUpdateStatus {
    var raw = Int32()
    try proto.readI32(&raw)
    return JobUpdateStatus(rawValue: raw)!
  }

  public static func writeValue(value: JobUpdateStatus, toProtocol proto: TProtocol) throws {
    try proto.writeI32(value.rawValue)
  }

}

extension JobUpdateAction : TEnum {

  public static func readValueFromProtocol(proto: TProtocol) throws -> JobUpdateAction {
    var raw = Int32()
    try proto.readI32(&raw)
    return JobUpdateAction(rawValue: raw)!
  }

  public static func writeValue(value: JobUpdateAction, toProtocol proto: TProtocol) throws {
    try proto.writeI32(value.rawValue)
  }

}

extension JobUpdatePulseStatus : TEnum {

  public static func readValueFromProtocol(proto: TProtocol) throws -> JobUpdatePulseStatus {
    var raw = Int32()
    try proto.readI32(&raw)
    return JobUpdatePulseStatus(rawValue: raw)!
  }

  public static func writeValue(value: JobUpdatePulseStatus, toProtocol proto: TProtocol) throws {
    try proto.writeI32(value.rawValue)
  }

}

public func ==(lhs: APIVersion, rhs: APIVersion) -> Bool {
  return
    (lhs.major ?== rhs.major)
}

extension APIVersion : CustomStringConvertible {

  public var description : String {
    var desc = "APIVersion("
    desc += "major=\(self.major)"
    desc += ")"
    return desc
  }

}

extension APIVersion : Hashable {

  public var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime * result + (major.hashValue)
    return result
  }

}

extension APIVersion : TStruct {

  public static func readValueFromProtocol(__proto: TProtocol) throws -> APIVersion {

    try __proto.readStructBegin()

    var major : Int32!

    fields: while true {

      let (_, fieldType, fieldID) = try __proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .STOP):
          break fields

        case (1, .I32):
          major = try __proto.readValue() as Int32

        case let (_, unknownType):
          try __proto.skipType(unknownType)
      }

      try __proto.readFieldEnd()
    }

    try __proto.readStructEnd()

    // Required fields
    try __proto.validateValue(major, named: "major")

    return APIVersion(major: major)
  }

  public static func writeValue(__value: APIVersion, toProtocol __proto: TProtocol) throws {

    try __proto.writeStructBeginWithName("APIVersion")

    try __proto.writeFieldValue(__value.major, name: "major", type: .I32, id: 1)

    try __proto.writeFieldStop()

    try __proto.writeStructEnd()
  }

}



public func ==(lhs: Identity, rhs: Identity) -> Bool {
  return
    (lhs.role ?== rhs.role) &&
    (lhs.user ?== rhs.user)
}

extension Identity : CustomStringConvertible {

  public var description : String {
    var desc = "Identity("
    desc += "role=\(self.role), "
    desc += "user=\(self.user)"
    desc += ")"
    return desc
  }

}

extension Identity : Hashable {

  public var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime * result + (role.hashValue)
    result = prime * result + (user.hashValue)
    return result
  }

}

extension Identity : TStruct {

  public static func readValueFromProtocol(__proto: TProtocol) throws -> Identity {

    try __proto.readStructBegin()

    var role : String!
    var user : String!

    fields: while true {

      let (_, fieldType, fieldID) = try __proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .STOP):
          break fields

        case (1, .STRING):
          role = try __proto.readValue() as String

        case (2, .STRING):
          user = try __proto.readValue() as String

        case let (_, unknownType):
          try __proto.skipType(unknownType)
      }

      try __proto.readFieldEnd()
    }

    try __proto.readStructEnd()

    // Required fields
    try __proto.validateValue(role, named: "role")
    try __proto.validateValue(user, named: "user")

    return Identity(role: role, user: user)
  }

  public static func writeValue(__value: Identity, toProtocol __proto: TProtocol) throws {

    try __proto.writeStructBeginWithName("Identity")

    try __proto.writeFieldValue(__value.role, name: "role", type: .STRING, id: 1)

    try __proto.writeFieldValue(__value.user, name: "user", type: .STRING, id: 2)

    try __proto.writeFieldStop()

    try __proto.writeStructEnd()
  }

}



public func ==(lhs: SessionKey, rhs: SessionKey) -> Bool {
  return
    (lhs.mechanism ?== rhs.mechanism) &&
    (lhs.data ?== rhs.data)
}

extension SessionKey : CustomStringConvertible {

  public var description : String {
    var desc = "SessionKey("
    desc += "mechanism=\(self.mechanism), "
    desc += "data=\(self.data)"
    desc += ")"
    return desc
  }

}

extension SessionKey : Hashable {

  public var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime * result + (mechanism?.hashValue ?? 0)
    result = prime * result + (data?.hashValue ?? 0)
    return result
  }

}

extension SessionKey : TStruct {

  public static func readValueFromProtocol(__proto: TProtocol) throws -> SessionKey {

    try __proto.readStructBegin()

    var mechanism : String?
    var data : TBinary?

    fields: while true {

      let (_, fieldType, fieldID) = try __proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .STOP):
          break fields

        case (4, .STRING):
          mechanism = try __proto.readValue() as String

        case (5, .STRING):
          data = try __proto.readValue() as TBinary

        case let (_, unknownType):
          try __proto.skipType(unknownType)
      }

      try __proto.readFieldEnd()
    }

    try __proto.readStructEnd()


    return SessionKey(mechanism: mechanism, data: data)
  }

  public static func writeValue(__value: SessionKey, toProtocol __proto: TProtocol) throws {

    try __proto.writeStructBeginWithName("SessionKey")

    if let mechanism = __value.mechanism {
      try __proto.writeFieldValue(mechanism, name: "mechanism", type: .STRING, id: 4)
    }

    if let data = __value.data {
      try __proto.writeFieldValue(data, name: "data", type: .STRING, id: 5)
    }

    try __proto.writeFieldStop()

    try __proto.writeStructEnd()
  }

}



public func ==(lhs: ResourceAggregate, rhs: ResourceAggregate) -> Bool {
  return
    (lhs.numCpus ?== rhs.numCpus) &&
    (lhs.ramMb ?== rhs.ramMb) &&
    (lhs.diskMb ?== rhs.diskMb)
}

extension ResourceAggregate : CustomStringConvertible {

  public var description : String {
    var desc = "ResourceAggregate("
    desc += "numCpus=\(self.numCpus), "
    desc += "ramMb=\(self.ramMb), "
    desc += "diskMb=\(self.diskMb)"
    desc += ")"
    return desc
  }

}

extension ResourceAggregate : Hashable {

  public var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime * result + (numCpus.hashValue)
    result = prime * result + (ramMb.hashValue)
    result = prime * result + (diskMb.hashValue)
    return result
  }

}

extension ResourceAggregate : TStruct {

  public static func readValueFromProtocol(__proto: TProtocol) throws -> ResourceAggregate {

    try __proto.readStructBegin()

    var numCpus : Double!
    var ramMb : Int64!
    var diskMb : Int64!

    fields: while true {

      let (_, fieldType, fieldID) = try __proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .STOP):
          break fields

        case (1, .DOUBLE):
          numCpus = try __proto.readValue() as Double

        case (2, .I64):
          ramMb = try __proto.readValue() as Int64

        case (3, .I64):
          diskMb = try __proto.readValue() as Int64

        case let (_, unknownType):
          try __proto.skipType(unknownType)
      }

      try __proto.readFieldEnd()
    }

    try __proto.readStructEnd()

    // Required fields
    try __proto.validateValue(numCpus, named: "numCpus")
    try __proto.validateValue(ramMb, named: "ramMb")
    try __proto.validateValue(diskMb, named: "diskMb")

    return ResourceAggregate(numCpus: numCpus, ramMb: ramMb, diskMb: diskMb)
  }

  public static func writeValue(__value: ResourceAggregate, toProtocol __proto: TProtocol) throws {

    try __proto.writeStructBeginWithName("ResourceAggregate")

    try __proto.writeFieldValue(__value.numCpus, name: "numCpus", type: .DOUBLE, id: 1)

    try __proto.writeFieldValue(__value.ramMb, name: "ramMb", type: .I64, id: 2)

    try __proto.writeFieldValue(__value.diskMb, name: "diskMb", type: .I64, id: 3)

    try __proto.writeFieldStop()

    try __proto.writeStructEnd()
  }

}



public func ==(lhs: Attribute, rhs: Attribute) -> Bool {
  return
    (lhs.name ?== rhs.name) &&
    (lhs.values ?== rhs.values)
}

extension Attribute : CustomStringConvertible {

  public var description : String {
    var desc = "Attribute("
    desc += "name=\(self.name), "
    desc += "values=\(self.values)"
    desc += ")"
    return desc
  }

}

extension Attribute : Hashable {

  public var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime * result + (name.hashValue)
    result = prime * result + (values.hashValue)
    return result
  }

}

extension Attribute : TStruct {

  public static func readValueFromProtocol(__proto: TProtocol) throws -> Attribute {

    try __proto.readStructBegin()

    var name : String!
    var values : TSet<String>!

    fields: while true {

      let (_, fieldType, fieldID) = try __proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .STOP):
          break fields

        case (1, .STRING):
          name = try __proto.readValue() as String

        case (2, .SET):
          values = try __proto.readValue() as TSet<String>

        case let (_, unknownType):
          try __proto.skipType(unknownType)
      }

      try __proto.readFieldEnd()
    }

    try __proto.readStructEnd()

    // Required fields
    try __proto.validateValue(name, named: "name")
    try __proto.validateValue(values, named: "values")

    return Attribute(name: name, values: values)
  }

  public static func writeValue(__value: Attribute, toProtocol __proto: TProtocol) throws {

    try __proto.writeStructBeginWithName("Attribute")

    try __proto.writeFieldValue(__value.name, name: "name", type: .STRING, id: 1)

    try __proto.writeFieldValue(__value.values, name: "values", type: .SET, id: 2)

    try __proto.writeFieldStop()

    try __proto.writeStructEnd()
  }

}



public func ==(lhs: HostAttributes, rhs: HostAttributes) -> Bool {
  return
    (lhs.host ?== rhs.host) &&
    (lhs.attributes ?== rhs.attributes) &&
    (lhs.mode ?== rhs.mode) &&
    (lhs.slaveId ?== rhs.slaveId)
}

extension HostAttributes : CustomStringConvertible {

  public var description : String {
    var desc = "HostAttributes("
    desc += "host=\(self.host), "
    desc += "attributes=\(self.attributes), "
    desc += "mode=\(self.mode), "
    desc += "slaveId=\(self.slaveId)"
    desc += ")"
    return desc
  }

}

extension HostAttributes : Hashable {

  public var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime * result + (host.hashValue)
    result = prime * result + (attributes.hashValue)
    result = prime * result + (mode?.hashValue ?? 0)
    result = prime * result + (slaveId?.hashValue ?? 0)
    return result
  }

}

extension HostAttributes : TStruct {

  public static func readValueFromProtocol(__proto: TProtocol) throws -> HostAttributes {

    try __proto.readStructBegin()

    var host : String!
    var attributes : TSet<Attribute>!
    var mode : MaintenanceMode?
    var slaveId : String?

    fields: while true {

      let (_, fieldType, fieldID) = try __proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .STOP):
          break fields

        case (1, .STRING):
          host = try __proto.readValue() as String

        case (2, .SET):
          attributes = try __proto.readValue() as TSet<Attribute>

        case (3, .I32):
          mode = try __proto.readValue() as MaintenanceMode

        case (4, .STRING):
          slaveId = try __proto.readValue() as String

        case let (_, unknownType):
          try __proto.skipType(unknownType)
      }

      try __proto.readFieldEnd()
    }

    try __proto.readStructEnd()

    // Required fields
    try __proto.validateValue(host, named: "host")
    try __proto.validateValue(attributes, named: "attributes")

    return HostAttributes(host: host, attributes: attributes, mode: mode, slaveId: slaveId)
  }

  public static func writeValue(__value: HostAttributes, toProtocol __proto: TProtocol) throws {

    try __proto.writeStructBeginWithName("HostAttributes")

    try __proto.writeFieldValue(__value.host, name: "host", type: .STRING, id: 1)

    try __proto.writeFieldValue(__value.attributes, name: "attributes", type: .SET, id: 2)

    if let mode = __value.mode {
      try __proto.writeFieldValue(mode, name: "mode", type: .I32, id: 3)
    }

    if let slaveId = __value.slaveId {
      try __proto.writeFieldValue(slaveId, name: "slaveId", type: .STRING, id: 4)
    }

    try __proto.writeFieldStop()

    try __proto.writeStructEnd()
  }

}



public func ==(lhs: ValueConstraint, rhs: ValueConstraint) -> Bool {
  return
    (lhs.negated ?== rhs.negated) &&
    (lhs.values ?== rhs.values)
}

extension ValueConstraint : CustomStringConvertible {

  public var description : String {
    var desc = "ValueConstraint("
    desc += "negated=\(self.negated), "
    desc += "values=\(self.values)"
    desc += ")"
    return desc
  }

}

extension ValueConstraint : Hashable {

  public var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime * result + (negated.hashValue)
    result = prime * result + (values.hashValue)
    return result
  }

}

extension ValueConstraint : TStruct {

  public static func readValueFromProtocol(__proto: TProtocol) throws -> ValueConstraint {

    try __proto.readStructBegin()

    var negated : Bool!
    var values : TSet<String>!

    fields: while true {

      let (_, fieldType, fieldID) = try __proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .STOP):
          break fields

        case (1, .BOOL):
          negated = try __proto.readValue() as Bool

        case (2, .SET):
          values = try __proto.readValue() as TSet<String>

        case let (_, unknownType):
          try __proto.skipType(unknownType)
      }

      try __proto.readFieldEnd()
    }

    try __proto.readStructEnd()

    // Required fields
    try __proto.validateValue(negated, named: "negated")
    try __proto.validateValue(values, named: "values")

    return ValueConstraint(negated: negated, values: values)
  }

  public static func writeValue(__value: ValueConstraint, toProtocol __proto: TProtocol) throws {

    try __proto.writeStructBeginWithName("ValueConstraint")

    try __proto.writeFieldValue(__value.negated, name: "negated", type: .BOOL, id: 1)

    try __proto.writeFieldValue(__value.values, name: "values", type: .SET, id: 2)

    try __proto.writeFieldStop()

    try __proto.writeStructEnd()
  }

}



public func ==(lhs: LimitConstraint, rhs: LimitConstraint) -> Bool {
  return
    (lhs.limit ?== rhs.limit)
}

extension LimitConstraint : CustomStringConvertible {

  public var description : String {
    var desc = "LimitConstraint("
    desc += "limit=\(self.limit)"
    desc += ")"
    return desc
  }

}

extension LimitConstraint : Hashable {

  public var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime * result + (limit.hashValue)
    return result
  }

}

extension LimitConstraint : TStruct {

  public static func readValueFromProtocol(__proto: TProtocol) throws -> LimitConstraint {

    try __proto.readStructBegin()

    var limit : Int32!

    fields: while true {

      let (_, fieldType, fieldID) = try __proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .STOP):
          break fields

        case (1, .I32):
          limit = try __proto.readValue() as Int32

        case let (_, unknownType):
          try __proto.skipType(unknownType)
      }

      try __proto.readFieldEnd()
    }

    try __proto.readStructEnd()

    // Required fields
    try __proto.validateValue(limit, named: "limit")

    return LimitConstraint(limit: limit)
  }

  public static func writeValue(__value: LimitConstraint, toProtocol __proto: TProtocol) throws {

    try __proto.writeStructBeginWithName("LimitConstraint")

    try __proto.writeFieldValue(__value.limit, name: "limit", type: .I32, id: 1)

    try __proto.writeFieldStop()

    try __proto.writeStructEnd()
  }

}



public func ==(lhs: TaskConstraint, rhs: TaskConstraint) -> Bool {
  return
    (lhs.value ?== rhs.value) &&
    (lhs.limit ?== rhs.limit)
}

extension TaskConstraint : CustomStringConvertible {

  public var description : String {
    var desc = "TaskConstraint("
    desc += "value=\(self.value), "
    desc += "limit=\(self.limit)"
    desc += ")"
    return desc
  }

}

extension TaskConstraint : Hashable {

  public var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime * result + (value.hashValue)
    result = prime * result + (limit.hashValue)
    return result
  }

}

extension TaskConstraint : TStruct {

  public static func readValueFromProtocol(__proto: TProtocol) throws -> TaskConstraint {

    try __proto.readStructBegin()

    var value : ValueConstraint!
    var limit : LimitConstraint!

    fields: while true {

      let (_, fieldType, fieldID) = try __proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .STOP):
          break fields

        case (1, .STRUCT):
          value = try __proto.readValue() as ValueConstraint

        case (2, .STRUCT):
          limit = try __proto.readValue() as LimitConstraint

        case let (_, unknownType):
          try __proto.skipType(unknownType)
      }

      try __proto.readFieldEnd()
    }

    try __proto.readStructEnd()

    // Required fields
    try __proto.validateValue(value, named: "value")
    try __proto.validateValue(limit, named: "limit")

    return TaskConstraint(value: value, limit: limit)
  }

  public static func writeValue(__value: TaskConstraint, toProtocol __proto: TProtocol) throws {

    try __proto.writeStructBeginWithName("TaskConstraint")

    try __proto.writeFieldValue(__value.value, name: "value", type: .STRUCT, id: 1)

    try __proto.writeFieldValue(__value.limit, name: "limit", type: .STRUCT, id: 2)

    try __proto.writeFieldStop()

    try __proto.writeStructEnd()
  }

}



public func ==(lhs: Constraint, rhs: Constraint) -> Bool {
  return
    (lhs.name ?== rhs.name) &&
    (lhs.constraint ?== rhs.constraint)
}

extension Constraint : CustomStringConvertible {

  public var description : String {
    var desc = "Constraint("
    desc += "name=\(self.name), "
    desc += "constraint=\(self.constraint)"
    desc += ")"
    return desc
  }

}

extension Constraint : Hashable {

  public var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime * result + (name.hashValue)
    result = prime * result + (constraint.hashValue)
    return result
  }

}

extension Constraint : TStruct {

  public static func readValueFromProtocol(__proto: TProtocol) throws -> Constraint {

    try __proto.readStructBegin()

    var name : String!
    var constraint : TaskConstraint!

    fields: while true {

      let (_, fieldType, fieldID) = try __proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .STOP):
          break fields

        case (1, .STRING):
          name = try __proto.readValue() as String

        case (2, .STRUCT):
          constraint = try __proto.readValue() as TaskConstraint

        case let (_, unknownType):
          try __proto.skipType(unknownType)
      }

      try __proto.readFieldEnd()
    }

    try __proto.readStructEnd()

    // Required fields
    try __proto.validateValue(name, named: "name")
    try __proto.validateValue(constraint, named: "constraint")

    return Constraint(name: name, constraint: constraint)
  }

  public static func writeValue(__value: Constraint, toProtocol __proto: TProtocol) throws {

    try __proto.writeStructBeginWithName("Constraint")

    try __proto.writeFieldValue(__value.name, name: "name", type: .STRING, id: 1)

    try __proto.writeFieldValue(__value.constraint, name: "constraint", type: .STRUCT, id: 2)

    try __proto.writeFieldStop()

    try __proto.writeStructEnd()
  }

}



public func ==(lhs: Package, rhs: Package) -> Bool {
  return
    (lhs.role ?== rhs.role) &&
    (lhs.name ?== rhs.name) &&
    (lhs.version ?== rhs.version)
}

extension Package : CustomStringConvertible {

  public var description : String {
    var desc = "Package("
    desc += "role=\(self.role), "
    desc += "name=\(self.name), "
    desc += "version=\(self.version)"
    desc += ")"
    return desc
  }

}

extension Package : Hashable {

  public var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime * result + (role.hashValue)
    result = prime * result + (name.hashValue)
    result = prime * result + (version.hashValue)
    return result
  }

}

extension Package : TStruct {

  public static func readValueFromProtocol(__proto: TProtocol) throws -> Package {

    try __proto.readStructBegin()

    var role : String!
    var name : String!
    var version : Int32!

    fields: while true {

      let (_, fieldType, fieldID) = try __proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .STOP):
          break fields

        case (1, .STRING):
          role = try __proto.readValue() as String

        case (2, .STRING):
          name = try __proto.readValue() as String

        case (3, .I32):
          version = try __proto.readValue() as Int32

        case let (_, unknownType):
          try __proto.skipType(unknownType)
      }

      try __proto.readFieldEnd()
    }

    try __proto.readStructEnd()

    // Required fields
    try __proto.validateValue(role, named: "role")
    try __proto.validateValue(name, named: "name")
    try __proto.validateValue(version, named: "version")

    return Package(role: role, name: name, version: version)
  }

  public static func writeValue(__value: Package, toProtocol __proto: TProtocol) throws {

    try __proto.writeStructBeginWithName("Package")

    try __proto.writeFieldValue(__value.role, name: "role", type: .STRING, id: 1)

    try __proto.writeFieldValue(__value.name, name: "name", type: .STRING, id: 2)

    try __proto.writeFieldValue(__value.version, name: "version", type: .I32, id: 3)

    try __proto.writeFieldStop()

    try __proto.writeStructEnd()
  }

}



public func ==(lhs: Metadata, rhs: Metadata) -> Bool {
  return
    (lhs.key ?== rhs.key) &&
    (lhs.value ?== rhs.value)
}

extension Metadata : CustomStringConvertible {

  public var description : String {
    var desc = "Metadata("
    desc += "key=\(self.key), "
    desc += "value=\(self.value)"
    desc += ")"
    return desc
  }

}

extension Metadata : Hashable {

  public var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime * result + (key.hashValue)
    result = prime * result + (value.hashValue)
    return result
  }

}

extension Metadata : TStruct {

  public static func readValueFromProtocol(__proto: TProtocol) throws -> Metadata {

    try __proto.readStructBegin()

    var key : String!
    var value : String!

    fields: while true {

      let (_, fieldType, fieldID) = try __proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .STOP):
          break fields

        case (1, .STRING):
          key = try __proto.readValue() as String

        case (2, .STRING):
          value = try __proto.readValue() as String

        case let (_, unknownType):
          try __proto.skipType(unknownType)
      }

      try __proto.readFieldEnd()
    }

    try __proto.readStructEnd()

    // Required fields
    try __proto.validateValue(key, named: "key")
    try __proto.validateValue(value, named: "value")

    return Metadata(key: key, value: value)
  }

  public static func writeValue(__value: Metadata, toProtocol __proto: TProtocol) throws {

    try __proto.writeStructBeginWithName("Metadata")

    try __proto.writeFieldValue(__value.key, name: "key", type: .STRING, id: 1)

    try __proto.writeFieldValue(__value.value, name: "value", type: .STRING, id: 2)

    try __proto.writeFieldStop()

    try __proto.writeStructEnd()
  }

}



public func ==(lhs: JobKey, rhs: JobKey) -> Bool {
  return
    (lhs.role ?== rhs.role) &&
    (lhs.environment ?== rhs.environment) &&
    (lhs.name ?== rhs.name)
}

extension JobKey : CustomStringConvertible {

  public var description : String {
    var desc = "JobKey("
    desc += "role=\(self.role), "
    desc += "environment=\(self.environment), "
    desc += "name=\(self.name)"
    desc += ")"
    return desc
  }

}

extension JobKey : Hashable {

  public var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime * result + (role.hashValue)
    result = prime * result + (environment.hashValue)
    result = prime * result + (name.hashValue)
    return result
  }

}

extension JobKey : TStruct {

  public static func readValueFromProtocol(__proto: TProtocol) throws -> JobKey {

    try __proto.readStructBegin()

    var role : String!
    var environment : String!
    var name : String!

    fields: while true {

      let (_, fieldType, fieldID) = try __proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .STOP):
          break fields

        case (1, .STRING):
          role = try __proto.readValue() as String

        case (2, .STRING):
          environment = try __proto.readValue() as String

        case (3, .STRING):
          name = try __proto.readValue() as String

        case let (_, unknownType):
          try __proto.skipType(unknownType)
      }

      try __proto.readFieldEnd()
    }

    try __proto.readStructEnd()

    // Required fields
    try __proto.validateValue(role, named: "role")
    try __proto.validateValue(environment, named: "environment")
    try __proto.validateValue(name, named: "name")

    return JobKey(role: role, environment: environment, name: name)
  }

  public static func writeValue(__value: JobKey, toProtocol __proto: TProtocol) throws {

    try __proto.writeStructBeginWithName("JobKey")

    try __proto.writeFieldValue(__value.role, name: "role", type: .STRING, id: 1)

    try __proto.writeFieldValue(__value.environment, name: "environment", type: .STRING, id: 2)

    try __proto.writeFieldValue(__value.name, name: "name", type: .STRING, id: 3)

    try __proto.writeFieldStop()

    try __proto.writeStructEnd()
  }

}



public func ==(lhs: LockKey, rhs: LockKey) -> Bool {
  return
    (lhs.job ?== rhs.job)
}

extension LockKey : CustomStringConvertible {

  public var description : String {
    var desc = "LockKey("
    desc += "job=\(self.job)"
    desc += ")"
    return desc
  }

}

extension LockKey : Hashable {

  public var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime * result + (job.hashValue)
    return result
  }

}

extension LockKey : TStruct {

  public static func readValueFromProtocol(__proto: TProtocol) throws -> LockKey {

    try __proto.readStructBegin()

    var job : JobKey!

    fields: while true {

      let (_, fieldType, fieldID) = try __proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .STOP):
          break fields

        case (1, .STRUCT):
          job = try __proto.readValue() as JobKey

        case let (_, unknownType):
          try __proto.skipType(unknownType)
      }

      try __proto.readFieldEnd()
    }

    try __proto.readStructEnd()

    // Required fields
    try __proto.validateValue(job, named: "job")

    return LockKey(job: job)
  }

  public static func writeValue(__value: LockKey, toProtocol __proto: TProtocol) throws {

    try __proto.writeStructBeginWithName("LockKey")

    try __proto.writeFieldValue(__value.job, name: "job", type: .STRUCT, id: 1)

    try __proto.writeFieldStop()

    try __proto.writeStructEnd()
  }

}



public func ==(lhs: Lock, rhs: Lock) -> Bool {
  return
    (lhs.key ?== rhs.key) &&
    (lhs.token ?== rhs.token) &&
    (lhs.user ?== rhs.user) &&
    (lhs.timestampMs ?== rhs.timestampMs) &&
    (lhs.message ?== rhs.message)
}

extension Lock : CustomStringConvertible {

  public var description : String {
    var desc = "Lock("
    desc += "key=\(self.key), "
    desc += "token=\(self.token), "
    desc += "user=\(self.user), "
    desc += "timestampMs=\(self.timestampMs), "
    desc += "message=\(self.message)"
    desc += ")"
    return desc
  }

}

extension Lock : Hashable {

  public var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime * result + (key.hashValue)
    result = prime * result + (token.hashValue)
    result = prime * result + (user.hashValue)
    result = prime * result + (timestampMs.hashValue)
    result = prime * result + (message?.hashValue ?? 0)
    return result
  }

}

extension Lock : TStruct {

  public static func readValueFromProtocol(__proto: TProtocol) throws -> Lock {

    try __proto.readStructBegin()

    var key : LockKey!
    var token : String!
    var user : String!
    var timestampMs : Int64!
    var message : String?

    fields: while true {

      let (_, fieldType, fieldID) = try __proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .STOP):
          break fields

        case (1, .STRUCT):
          key = try __proto.readValue() as LockKey

        case (2, .STRING):
          token = try __proto.readValue() as String

        case (3, .STRING):
          user = try __proto.readValue() as String

        case (4, .I64):
          timestampMs = try __proto.readValue() as Int64

        case (5, .STRING):
          message = try __proto.readValue() as String

        case let (_, unknownType):
          try __proto.skipType(unknownType)
      }

      try __proto.readFieldEnd()
    }

    try __proto.readStructEnd()

    // Required fields
    try __proto.validateValue(key, named: "key")
    try __proto.validateValue(token, named: "token")
    try __proto.validateValue(user, named: "user")
    try __proto.validateValue(timestampMs, named: "timestampMs")

    return Lock(key: key, token: token, user: user, timestampMs: timestampMs, message: message)
  }

  public static func writeValue(__value: Lock, toProtocol __proto: TProtocol) throws {

    try __proto.writeStructBeginWithName("Lock")

    try __proto.writeFieldValue(__value.key, name: "key", type: .STRUCT, id: 1)

    try __proto.writeFieldValue(__value.token, name: "token", type: .STRING, id: 2)

    try __proto.writeFieldValue(__value.user, name: "user", type: .STRING, id: 3)

    try __proto.writeFieldValue(__value.timestampMs, name: "timestampMs", type: .I64, id: 4)

    if let message = __value.message {
      try __proto.writeFieldValue(message, name: "message", type: .STRING, id: 5)
    }

    try __proto.writeFieldStop()

    try __proto.writeStructEnd()
  }

}



public func ==(lhs: InstanceKey, rhs: InstanceKey) -> Bool {
  return
    (lhs.jobKey ?== rhs.jobKey) &&
    (lhs.instanceId ?== rhs.instanceId)
}

extension InstanceKey : CustomStringConvertible {

  public var description : String {
    var desc = "InstanceKey("
    desc += "jobKey=\(self.jobKey), "
    desc += "instanceId=\(self.instanceId)"
    desc += ")"
    return desc
  }

}

extension InstanceKey : Hashable {

  public var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime * result + (jobKey.hashValue)
    result = prime * result + (instanceId.hashValue)
    return result
  }

}

extension InstanceKey : TStruct {

  public static func readValueFromProtocol(__proto: TProtocol) throws -> InstanceKey {

    try __proto.readStructBegin()

    var jobKey : JobKey!
    var instanceId : Int32!

    fields: while true {

      let (_, fieldType, fieldID) = try __proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .STOP):
          break fields

        case (1, .STRUCT):
          jobKey = try __proto.readValue() as JobKey

        case (2, .I32):
          instanceId = try __proto.readValue() as Int32

        case let (_, unknownType):
          try __proto.skipType(unknownType)
      }

      try __proto.readFieldEnd()
    }

    try __proto.readStructEnd()

    // Required fields
    try __proto.validateValue(jobKey, named: "jobKey")
    try __proto.validateValue(instanceId, named: "instanceId")

    return InstanceKey(jobKey: jobKey, instanceId: instanceId)
  }

  public static func writeValue(__value: InstanceKey, toProtocol __proto: TProtocol) throws {

    try __proto.writeStructBeginWithName("InstanceKey")

    try __proto.writeFieldValue(__value.jobKey, name: "jobKey", type: .STRUCT, id: 1)

    try __proto.writeFieldValue(__value.instanceId, name: "instanceId", type: .I32, id: 2)

    try __proto.writeFieldStop()

    try __proto.writeStructEnd()
  }

}



public func ==(lhs: ExecutorConfig, rhs: ExecutorConfig) -> Bool {
  return
    (lhs.name ?== rhs.name) &&
    (lhs.data ?== rhs.data)
}

extension ExecutorConfig : CustomStringConvertible {

  public var description : String {
    var desc = "ExecutorConfig("
    desc += "name=\(self.name), "
    desc += "data=\(self.data)"
    desc += ")"
    return desc
  }

}

extension ExecutorConfig : Hashable {

  public var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime * result + (name.hashValue)
    result = prime * result + (data.hashValue)
    return result
  }

}

extension ExecutorConfig : TStruct {

  public static func readValueFromProtocol(__proto: TProtocol) throws -> ExecutorConfig {

    try __proto.readStructBegin()

    var name : String!
    var data : String!

    fields: while true {

      let (_, fieldType, fieldID) = try __proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .STOP):
          break fields

        case (1, .STRING):
          name = try __proto.readValue() as String

        case (2, .STRING):
          data = try __proto.readValue() as String

        case let (_, unknownType):
          try __proto.skipType(unknownType)
      }

      try __proto.readFieldEnd()
    }

    try __proto.readStructEnd()

    // Required fields
    try __proto.validateValue(name, named: "name")
    try __proto.validateValue(data, named: "data")

    return ExecutorConfig(name: name, data: data)
  }

  public static func writeValue(__value: ExecutorConfig, toProtocol __proto: TProtocol) throws {

    try __proto.writeStructBeginWithName("ExecutorConfig")

    try __proto.writeFieldValue(__value.name, name: "name", type: .STRING, id: 1)

    try __proto.writeFieldValue(__value.data, name: "data", type: .STRING, id: 2)

    try __proto.writeFieldStop()

    try __proto.writeStructEnd()
  }

}



public func ==(lhs: Volume, rhs: Volume) -> Bool {
  return
    (lhs.containerPath ?== rhs.containerPath) &&
    (lhs.hostPath ?== rhs.hostPath) &&
    (lhs.mode ?== rhs.mode)
}

extension Volume : CustomStringConvertible {

  public var description : String {
    var desc = "Volume("
    desc += "containerPath=\(self.containerPath), "
    desc += "hostPath=\(self.hostPath), "
    desc += "mode=\(self.mode)"
    desc += ")"
    return desc
  }

}

extension Volume : Hashable {

  public var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime * result + (containerPath.hashValue)
    result = prime * result + (hostPath.hashValue)
    result = prime * result + (mode.hashValue)
    return result
  }

}

extension Volume : TStruct {

  public static func readValueFromProtocol(__proto: TProtocol) throws -> Volume {

    try __proto.readStructBegin()

    var containerPath : String!
    var hostPath : String!
    var mode : Mode!

    fields: while true {

      let (_, fieldType, fieldID) = try __proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .STOP):
          break fields

        case (1, .STRING):
          containerPath = try __proto.readValue() as String

        case (2, .STRING):
          hostPath = try __proto.readValue() as String

        case (3, .I32):
          mode = try __proto.readValue() as Mode

        case let (_, unknownType):
          try __proto.skipType(unknownType)
      }

      try __proto.readFieldEnd()
    }

    try __proto.readStructEnd()

    // Required fields
    try __proto.validateValue(containerPath, named: "containerPath")
    try __proto.validateValue(hostPath, named: "hostPath")
    try __proto.validateValue(mode, named: "mode")

    return Volume(containerPath: containerPath, hostPath: hostPath, mode: mode)
  }

  public static func writeValue(__value: Volume, toProtocol __proto: TProtocol) throws {

    try __proto.writeStructBeginWithName("Volume")

    try __proto.writeFieldValue(__value.containerPath, name: "containerPath", type: .STRING, id: 1)

    try __proto.writeFieldValue(__value.hostPath, name: "hostPath", type: .STRING, id: 2)

    try __proto.writeFieldValue(__value.mode, name: "mode", type: .I32, id: 3)

    try __proto.writeFieldStop()

    try __proto.writeStructEnd()
  }

}



public func ==(lhs: MesosContainer, rhs: MesosContainer) -> Bool {
  return true
}

extension MesosContainer : CustomStringConvertible {

  public var description : String {
    var desc = "MesosContainer("
    desc += ")"
    return desc
  }

}

extension MesosContainer : Hashable {

  public var hashValue : Int {
    return 31
  }

}

extension MesosContainer : TStruct {

  public static func readValueFromProtocol(__proto: TProtocol) throws -> MesosContainer {

    try __proto.readStructBegin()


    fields: while true {

      let (_, fieldType, fieldID) = try __proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .STOP):
          break fields

        case let (_, unknownType):
          try __proto.skipType(unknownType)
      }

      try __proto.readFieldEnd()
    }

    try __proto.readStructEnd()


    return MesosContainer()
  }

  public static func writeValue(__value: MesosContainer, toProtocol __proto: TProtocol) throws {

    try __proto.writeStructBeginWithName("MesosContainer")

    try __proto.writeFieldStop()

    try __proto.writeStructEnd()
  }

}



public func ==(lhs: DockerParameter, rhs: DockerParameter) -> Bool {
  return
    (lhs.name ?== rhs.name) &&
    (lhs.value ?== rhs.value)
}

extension DockerParameter : CustomStringConvertible {

  public var description : String {
    var desc = "DockerParameter("
    desc += "name=\(self.name), "
    desc += "value=\(self.value)"
    desc += ")"
    return desc
  }

}

extension DockerParameter : Hashable {

  public var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime * result + (name.hashValue)
    result = prime * result + (value.hashValue)
    return result
  }

}

extension DockerParameter : TStruct {

  public static func readValueFromProtocol(__proto: TProtocol) throws -> DockerParameter {

    try __proto.readStructBegin()

    var name : String!
    var value : String!

    fields: while true {

      let (_, fieldType, fieldID) = try __proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .STOP):
          break fields

        case (1, .STRING):
          name = try __proto.readValue() as String

        case (2, .STRING):
          value = try __proto.readValue() as String

        case let (_, unknownType):
          try __proto.skipType(unknownType)
      }

      try __proto.readFieldEnd()
    }

    try __proto.readStructEnd()

    // Required fields
    try __proto.validateValue(name, named: "name")
    try __proto.validateValue(value, named: "value")

    return DockerParameter(name: name, value: value)
  }

  public static func writeValue(__value: DockerParameter, toProtocol __proto: TProtocol) throws {

    try __proto.writeStructBeginWithName("DockerParameter")

    try __proto.writeFieldValue(__value.name, name: "name", type: .STRING, id: 1)

    try __proto.writeFieldValue(__value.value, name: "value", type: .STRING, id: 2)

    try __proto.writeFieldStop()

    try __proto.writeStructEnd()
  }

}



public func ==(lhs: DockerContainer, rhs: DockerContainer) -> Bool {
  return
    (lhs.image ?== rhs.image) &&
    (lhs.parameters ?== rhs.parameters)
}

extension DockerContainer : CustomStringConvertible {

  public var description : String {
    var desc = "DockerContainer("
    desc += "image=\(self.image), "
    desc += "parameters=\(self.parameters)"
    desc += ")"
    return desc
  }

}

extension DockerContainer : Hashable {

  public var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime * result + (image.hashValue)
    result = prime * result + (parameters?.hashValue ?? 0)
    return result
  }

}

extension DockerContainer : TStruct {

  public static func readValueFromProtocol(__proto: TProtocol) throws -> DockerContainer {

    try __proto.readStructBegin()

    var image : String!
    var parameters : TList<DockerParameter>?

    fields: while true {

      let (_, fieldType, fieldID) = try __proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .STOP):
          break fields

        case (1, .STRING):
          image = try __proto.readValue() as String

        case (2, .LIST):
          parameters = try __proto.readValue() as TList<DockerParameter>

        case let (_, unknownType):
          try __proto.skipType(unknownType)
      }

      try __proto.readFieldEnd()
    }

    try __proto.readStructEnd()

    // Required fields
    try __proto.validateValue(image, named: "image")

    return DockerContainer(image: image, parameters: parameters)
  }

  public static func writeValue(__value: DockerContainer, toProtocol __proto: TProtocol) throws {

    try __proto.writeStructBeginWithName("DockerContainer")

    try __proto.writeFieldValue(__value.image, name: "image", type: .STRING, id: 1)

    if let parameters = __value.parameters {
      try __proto.writeFieldValue(parameters, name: "parameters", type: .LIST, id: 2)
    }

    try __proto.writeFieldStop()

    try __proto.writeStructEnd()
  }

}



public func ==(lhs: Container, rhs: Container) -> Bool {
  return
    (lhs.mesos ?== rhs.mesos) &&
    (lhs.docker ?== rhs.docker)
}

extension Container : CustomStringConvertible {

  public var description : String {
    var desc = "Container("
    desc += "mesos=\(self.mesos), "
    desc += "docker=\(self.docker)"
    desc += ")"
    return desc
  }

}

extension Container : Hashable {

  public var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime * result + (mesos.hashValue)
    result = prime * result + (docker.hashValue)
    return result
  }

}

extension Container : TStruct {

  public static func readValueFromProtocol(__proto: TProtocol) throws -> Container {

    try __proto.readStructBegin()

    var mesos : MesosContainer!
    var docker : DockerContainer!

    fields: while true {

      let (_, fieldType, fieldID) = try __proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .STOP):
          break fields

        case (1, .STRUCT):
          mesos = try __proto.readValue() as MesosContainer

        case (2, .STRUCT):
          docker = try __proto.readValue() as DockerContainer

        case let (_, unknownType):
          try __proto.skipType(unknownType)
      }

      try __proto.readFieldEnd()
    }

    try __proto.readStructEnd()

    // Required fields
    try __proto.validateValue(mesos, named: "mesos")
    try __proto.validateValue(docker, named: "docker")

    return Container(mesos: mesos, docker: docker)
  }

  public static func writeValue(__value: Container, toProtocol __proto: TProtocol) throws {

    try __proto.writeStructBeginWithName("Container")

    try __proto.writeFieldValue(__value.mesos, name: "mesos", type: .STRUCT, id: 1)

    try __proto.writeFieldValue(__value.docker, name: "docker", type: .STRUCT, id: 2)

    try __proto.writeFieldStop()

    try __proto.writeStructEnd()
  }

}



public func ==(lhs: TaskConfig, rhs: TaskConfig) -> Bool {
  return
    (lhs.job ?== rhs.job) &&
    (lhs.owner ?== rhs.owner) &&
    (lhs.environment ?== rhs.environment) &&
    (lhs.jobName ?== rhs.jobName) &&
    (lhs.isService ?== rhs.isService) &&
    (lhs.numCpus ?== rhs.numCpus) &&
    (lhs.ramMb ?== rhs.ramMb) &&
    (lhs.diskMb ?== rhs.diskMb) &&
    (lhs.priority ?== rhs.priority) &&
    (lhs.maxTaskFailures ?== rhs.maxTaskFailures) &&
    (lhs.production ?== rhs.production) &&
    (lhs.tier ?== rhs.tier) &&
    (lhs.constraints ?== rhs.constraints) &&
    (lhs.requestedPorts ?== rhs.requestedPorts) &&
    (lhs.taskLinks ?== rhs.taskLinks) &&
    (lhs.contactEmail ?== rhs.contactEmail) &&
    (lhs.executorConfig ?== rhs.executorConfig) &&
    (lhs.metadata ?== rhs.metadata) &&
    (lhs.container ?== rhs.container)
}

extension TaskConfig : CustomStringConvertible {

  public var description : String {
    var desc = "TaskConfig("
    desc += "job=\(self.job), "
    desc += "owner=\(self.owner), "
    desc += "environment=\(self.environment), "
    desc += "jobName=\(self.jobName), "
    desc += "isService=\(self.isService), "
    desc += "numCpus=\(self.numCpus), "
    desc += "ramMb=\(self.ramMb), "
    desc += "diskMb=\(self.diskMb), "
    desc += "priority=\(self.priority), "
    desc += "maxTaskFailures=\(self.maxTaskFailures), "
    desc += "production=\(self.production), "
    desc += "tier=\(self.tier), "
    desc += "constraints=\(self.constraints), "
    desc += "requestedPorts=\(self.requestedPorts), "
    desc += "taskLinks=\(self.taskLinks), "
    desc += "contactEmail=\(self.contactEmail), "
    desc += "executorConfig=\(self.executorConfig), "
    desc += "metadata=\(self.metadata), "
    desc += "container=\(self.container)"
    desc += ")"
    return desc
  }

}

extension TaskConfig : Hashable {

  public var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime * result + (job.hashValue)
    result = prime * result + (owner.hashValue)
    result = prime * result + (environment.hashValue)
    result = prime * result + (jobName.hashValue)
    result = prime * result + (isService.hashValue)
    result = prime * result + (numCpus.hashValue)
    result = prime * result + (ramMb.hashValue)
    result = prime * result + (diskMb.hashValue)
    result = prime * result + (priority.hashValue)
    result = prime * result + (maxTaskFailures.hashValue)
    result = prime * result + (production?.hashValue ?? 0)
    result = prime * result + (tier?.hashValue ?? 0)
    result = prime * result + (constraints.hashValue)
    result = prime * result + (requestedPorts.hashValue)
    result = prime * result + (taskLinks?.hashValue ?? 0)
    result = prime * result + (contactEmail?.hashValue ?? 0)
    result = prime * result + (executorConfig?.hashValue ?? 0)
    result = prime * result + (metadata?.hashValue ?? 0)
    result = prime * result + (container.hashValue)
    return result
  }

}

extension TaskConfig : TStruct {

  public static func readValueFromProtocol(__proto: TProtocol) throws -> TaskConfig {

    try __proto.readStructBegin()

    var job : JobKey!
    var owner : Identity!
    var environment : String!
    var jobName : String!
    var isService : Bool!
    var numCpus : Double!
    var ramMb : Int64!
    var diskMb : Int64!
    var priority : Int32!
    var maxTaskFailures : Int32!
    var production : Bool?
    var tier : String?
    var constraints : TSet<Constraint>!
    var requestedPorts : TSet<String>!
    var taskLinks : TMap<String, String>?
    var contactEmail : String?
    var executorConfig : ExecutorConfig?
    var metadata : TSet<Metadata>?
    var container : Container!

    fields: while true {

      let (_, fieldType, fieldID) = try __proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .STOP):
          break fields

        case (28, .STRUCT):
          job = try __proto.readValue() as JobKey

        case (17, .STRUCT):
          owner = try __proto.readValue() as Identity

        case (26, .STRING):
          environment = try __proto.readValue() as String

        case (3, .STRING):
          jobName = try __proto.readValue() as String

        case (7, .BOOL):
          isService = try __proto.readValue() as Bool

        case (8, .DOUBLE):
          numCpus = try __proto.readValue() as Double

        case (9, .I64):
          ramMb = try __proto.readValue() as Int64

        case (10, .I64):
          diskMb = try __proto.readValue() as Int64

        case (11, .I32):
          priority = try __proto.readValue() as Int32

        case (13, .I32):
          maxTaskFailures = try __proto.readValue() as Int32

        case (18, .BOOL):
          production = try __proto.readValue() as Bool

        case (30, .STRING):
          tier = try __proto.readValue() as String

        case (20, .SET):
          constraints = try __proto.readValue() as TSet<Constraint>

        case (21, .SET):
          requestedPorts = try __proto.readValue() as TSet<String>

        case (22, .MAP):
          taskLinks = try __proto.readValue() as TMap<String, String>

        case (23, .STRING):
          contactEmail = try __proto.readValue() as String

        case (25, .STRUCT):
          executorConfig = try __proto.readValue() as ExecutorConfig

        case (27, .SET):
          metadata = try __proto.readValue() as TSet<Metadata>

        case (29, .STRUCT):
          container = try __proto.readValue() as Container

        case let (_, unknownType):
          try __proto.skipType(unknownType)
      }

      try __proto.readFieldEnd()
    }

    try __proto.readStructEnd()

    // Required fields
    try __proto.validateValue(job, named: "job")
    try __proto.validateValue(owner, named: "owner")
    try __proto.validateValue(environment, named: "environment")
    try __proto.validateValue(jobName, named: "jobName")
    try __proto.validateValue(isService, named: "isService")
    try __proto.validateValue(numCpus, named: "numCpus")
    try __proto.validateValue(ramMb, named: "ramMb")
    try __proto.validateValue(diskMb, named: "diskMb")
    try __proto.validateValue(priority, named: "priority")
    try __proto.validateValue(maxTaskFailures, named: "maxTaskFailures")
    try __proto.validateValue(constraints, named: "constraints")
    try __proto.validateValue(requestedPorts, named: "requestedPorts")
    try __proto.validateValue(container, named: "container")

    return TaskConfig(job: job, owner: owner, environment: environment, jobName: jobName, isService: isService, numCpus: numCpus, ramMb: ramMb, diskMb: diskMb, priority: priority, maxTaskFailures: maxTaskFailures, production: production, tier: tier, constraints: constraints, requestedPorts: requestedPorts, taskLinks: taskLinks, contactEmail: contactEmail, executorConfig: executorConfig, metadata: metadata, container: container)
  }

  public static func writeValue(__value: TaskConfig, toProtocol __proto: TProtocol) throws {

    try __proto.writeStructBeginWithName("TaskConfig")

    try __proto.writeFieldValue(__value.job, name: "job", type: .STRUCT, id: 28)

    try __proto.writeFieldValue(__value.owner, name: "owner", type: .STRUCT, id: 17)

    try __proto.writeFieldValue(__value.environment, name: "environment", type: .STRING, id: 26)

    try __proto.writeFieldValue(__value.jobName, name: "jobName", type: .STRING, id: 3)

    try __proto.writeFieldValue(__value.isService, name: "isService", type: .BOOL, id: 7)

    try __proto.writeFieldValue(__value.numCpus, name: "numCpus", type: .DOUBLE, id: 8)

    try __proto.writeFieldValue(__value.ramMb, name: "ramMb", type: .I64, id: 9)

    try __proto.writeFieldValue(__value.diskMb, name: "diskMb", type: .I64, id: 10)

    try __proto.writeFieldValue(__value.priority, name: "priority", type: .I32, id: 11)

    try __proto.writeFieldValue(__value.maxTaskFailures, name: "maxTaskFailures", type: .I32, id: 13)

    if let production = __value.production {
      try __proto.writeFieldValue(production, name: "production", type: .BOOL, id: 18)
    }

    if let tier = __value.tier {
      try __proto.writeFieldValue(tier, name: "tier", type: .STRING, id: 30)
    }

    try __proto.writeFieldValue(__value.constraints, name: "constraints", type: .SET, id: 20)

    try __proto.writeFieldValue(__value.requestedPorts, name: "requestedPorts", type: .SET, id: 21)

    if let taskLinks = __value.taskLinks {
      try __proto.writeFieldValue(taskLinks, name: "taskLinks", type: .MAP, id: 22)
    }

    if let contactEmail = __value.contactEmail {
      try __proto.writeFieldValue(contactEmail, name: "contactEmail", type: .STRING, id: 23)
    }

    if let executorConfig = __value.executorConfig {
      try __proto.writeFieldValue(executorConfig, name: "executorConfig", type: .STRUCT, id: 25)
    }

    if let metadata = __value.metadata {
      try __proto.writeFieldValue(metadata, name: "metadata", type: .SET, id: 27)
    }

    try __proto.writeFieldValue(__value.container, name: "container", type: .STRUCT, id: 29)

    try __proto.writeFieldStop()

    try __proto.writeStructEnd()
  }

}



public func ==(lhs: JobConfiguration, rhs: JobConfiguration) -> Bool {
  return
    (lhs.key ?== rhs.key) &&
    (lhs.owner ?== rhs.owner) &&
    (lhs.cronSchedule ?== rhs.cronSchedule) &&
    (lhs.cronCollisionPolicy ?== rhs.cronCollisionPolicy) &&
    (lhs.taskConfig ?== rhs.taskConfig) &&
    (lhs.instanceCount ?== rhs.instanceCount)
}

extension JobConfiguration : CustomStringConvertible {

  public var description : String {
    var desc = "JobConfiguration("
    desc += "key=\(self.key), "
    desc += "owner=\(self.owner), "
    desc += "cronSchedule=\(self.cronSchedule), "
    desc += "cronCollisionPolicy=\(self.cronCollisionPolicy), "
    desc += "taskConfig=\(self.taskConfig), "
    desc += "instanceCount=\(self.instanceCount)"
    desc += ")"
    return desc
  }

}

extension JobConfiguration : Hashable {

  public var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime * result + (key.hashValue)
    result = prime * result + (owner.hashValue)
    result = prime * result + (cronSchedule.hashValue)
    result = prime * result + (cronCollisionPolicy.hashValue)
    result = prime * result + (taskConfig.hashValue)
    result = prime * result + (instanceCount.hashValue)
    return result
  }

}

extension JobConfiguration : TStruct {

  public static func readValueFromProtocol(__proto: TProtocol) throws -> JobConfiguration {

    try __proto.readStructBegin()

    var key : JobKey!
    var owner : Identity!
    var cronSchedule : String!
    var cronCollisionPolicy : CronCollisionPolicy!
    var taskConfig : TaskConfig!
    var instanceCount : Int32!

    fields: while true {

      let (_, fieldType, fieldID) = try __proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .STOP):
          break fields

        case (9, .STRUCT):
          key = try __proto.readValue() as JobKey

        case (7, .STRUCT):
          owner = try __proto.readValue() as Identity

        case (4, .STRING):
          cronSchedule = try __proto.readValue() as String

        case (5, .I32):
          cronCollisionPolicy = try __proto.readValue() as CronCollisionPolicy

        case (6, .STRUCT):
          taskConfig = try __proto.readValue() as TaskConfig

        case (8, .I32):
          instanceCount = try __proto.readValue() as Int32

        case let (_, unknownType):
          try __proto.skipType(unknownType)
      }

      try __proto.readFieldEnd()
    }

    try __proto.readStructEnd()

    // Required fields
    try __proto.validateValue(key, named: "key")
    try __proto.validateValue(owner, named: "owner")
    try __proto.validateValue(cronSchedule, named: "cronSchedule")
    try __proto.validateValue(cronCollisionPolicy, named: "cronCollisionPolicy")
    try __proto.validateValue(taskConfig, named: "taskConfig")
    try __proto.validateValue(instanceCount, named: "instanceCount")

    return JobConfiguration(key: key, owner: owner, cronSchedule: cronSchedule, cronCollisionPolicy: cronCollisionPolicy, taskConfig: taskConfig, instanceCount: instanceCount)
  }

  public static func writeValue(__value: JobConfiguration, toProtocol __proto: TProtocol) throws {

    try __proto.writeStructBeginWithName("JobConfiguration")

    try __proto.writeFieldValue(__value.key, name: "key", type: .STRUCT, id: 9)

    try __proto.writeFieldValue(__value.owner, name: "owner", type: .STRUCT, id: 7)

    try __proto.writeFieldValue(__value.cronSchedule, name: "cronSchedule", type: .STRING, id: 4)

    try __proto.writeFieldValue(__value.cronCollisionPolicy, name: "cronCollisionPolicy", type: .I32, id: 5)

    try __proto.writeFieldValue(__value.taskConfig, name: "taskConfig", type: .STRUCT, id: 6)

    try __proto.writeFieldValue(__value.instanceCount, name: "instanceCount", type: .I32, id: 8)

    try __proto.writeFieldStop()

    try __proto.writeStructEnd()
  }

}



public func ==(lhs: JobStats, rhs: JobStats) -> Bool {
  return
    (lhs.activeTaskCount ?== rhs.activeTaskCount) &&
    (lhs.finishedTaskCount ?== rhs.finishedTaskCount) &&
    (lhs.failedTaskCount ?== rhs.failedTaskCount) &&
    (lhs.pendingTaskCount ?== rhs.pendingTaskCount)
}

extension JobStats : CustomStringConvertible {

  public var description : String {
    var desc = "JobStats("
    desc += "activeTaskCount=\(self.activeTaskCount), "
    desc += "finishedTaskCount=\(self.finishedTaskCount), "
    desc += "failedTaskCount=\(self.failedTaskCount), "
    desc += "pendingTaskCount=\(self.pendingTaskCount)"
    desc += ")"
    return desc
  }

}

extension JobStats : Hashable {

  public var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime * result + (activeTaskCount.hashValue)
    result = prime * result + (finishedTaskCount.hashValue)
    result = prime * result + (failedTaskCount.hashValue)
    result = prime * result + (pendingTaskCount.hashValue)
    return result
  }

}

extension JobStats : TStruct {

  public static func readValueFromProtocol(__proto: TProtocol) throws -> JobStats {

    try __proto.readStructBegin()

    var activeTaskCount : Int32!
    var finishedTaskCount : Int32!
    var failedTaskCount : Int32!
    var pendingTaskCount : Int32!

    fields: while true {

      let (_, fieldType, fieldID) = try __proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .STOP):
          break fields

        case (1, .I32):
          activeTaskCount = try __proto.readValue() as Int32

        case (2, .I32):
          finishedTaskCount = try __proto.readValue() as Int32

        case (3, .I32):
          failedTaskCount = try __proto.readValue() as Int32

        case (4, .I32):
          pendingTaskCount = try __proto.readValue() as Int32

        case let (_, unknownType):
          try __proto.skipType(unknownType)
      }

      try __proto.readFieldEnd()
    }

    try __proto.readStructEnd()

    // Required fields
    try __proto.validateValue(activeTaskCount, named: "activeTaskCount")
    try __proto.validateValue(finishedTaskCount, named: "finishedTaskCount")
    try __proto.validateValue(failedTaskCount, named: "failedTaskCount")
    try __proto.validateValue(pendingTaskCount, named: "pendingTaskCount")

    return JobStats(activeTaskCount: activeTaskCount, finishedTaskCount: finishedTaskCount, failedTaskCount: failedTaskCount, pendingTaskCount: pendingTaskCount)
  }

  public static func writeValue(__value: JobStats, toProtocol __proto: TProtocol) throws {

    try __proto.writeStructBeginWithName("JobStats")

    try __proto.writeFieldValue(__value.activeTaskCount, name: "activeTaskCount", type: .I32, id: 1)

    try __proto.writeFieldValue(__value.finishedTaskCount, name: "finishedTaskCount", type: .I32, id: 2)

    try __proto.writeFieldValue(__value.failedTaskCount, name: "failedTaskCount", type: .I32, id: 3)

    try __proto.writeFieldValue(__value.pendingTaskCount, name: "pendingTaskCount", type: .I32, id: 4)

    try __proto.writeFieldStop()

    try __proto.writeStructEnd()
  }

}



public func ==(lhs: JobSummary, rhs: JobSummary) -> Bool {
  return
    (lhs.job ?== rhs.job) &&
    (lhs.stats ?== rhs.stats) &&
    (lhs.nextCronRunMs ?== rhs.nextCronRunMs)
}

extension JobSummary : CustomStringConvertible {

  public var description : String {
    var desc = "JobSummary("
    desc += "job=\(self.job), "
    desc += "stats=\(self.stats), "
    desc += "nextCronRunMs=\(self.nextCronRunMs)"
    desc += ")"
    return desc
  }

}

extension JobSummary : Hashable {

  public var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime * result + (job.hashValue)
    result = prime * result + (stats.hashValue)
    result = prime * result + (nextCronRunMs?.hashValue ?? 0)
    return result
  }

}

extension JobSummary : TStruct {

  public static func readValueFromProtocol(__proto: TProtocol) throws -> JobSummary {

    try __proto.readStructBegin()

    var job : JobConfiguration!
    var stats : JobStats!
    var nextCronRunMs : Int64?

    fields: while true {

      let (_, fieldType, fieldID) = try __proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .STOP):
          break fields

        case (1, .STRUCT):
          job = try __proto.readValue() as JobConfiguration

        case (2, .STRUCT):
          stats = try __proto.readValue() as JobStats

        case (3, .I64):
          nextCronRunMs = try __proto.readValue() as Int64

        case let (_, unknownType):
          try __proto.skipType(unknownType)
      }

      try __proto.readFieldEnd()
    }

    try __proto.readStructEnd()

    // Required fields
    try __proto.validateValue(job, named: "job")
    try __proto.validateValue(stats, named: "stats")

    return JobSummary(job: job, stats: stats, nextCronRunMs: nextCronRunMs)
  }

  public static func writeValue(__value: JobSummary, toProtocol __proto: TProtocol) throws {

    try __proto.writeStructBeginWithName("JobSummary")

    try __proto.writeFieldValue(__value.job, name: "job", type: .STRUCT, id: 1)

    try __proto.writeFieldValue(__value.stats, name: "stats", type: .STRUCT, id: 2)

    if let nextCronRunMs = __value.nextCronRunMs {
      try __proto.writeFieldValue(nextCronRunMs, name: "nextCronRunMs", type: .I64, id: 3)
    }

    try __proto.writeFieldStop()

    try __proto.writeStructEnd()
  }

}



public func ==(lhs: AddInstancesConfig, rhs: AddInstancesConfig) -> Bool {
  return
    (lhs.key ?== rhs.key) &&
    (lhs.taskConfig ?== rhs.taskConfig) &&
    (lhs.instanceIds ?== rhs.instanceIds)
}

extension AddInstancesConfig : CustomStringConvertible {

  public var description : String {
    var desc = "AddInstancesConfig("
    desc += "key=\(self.key), "
    desc += "taskConfig=\(self.taskConfig), "
    desc += "instanceIds=\(self.instanceIds)"
    desc += ")"
    return desc
  }

}

extension AddInstancesConfig : Hashable {

  public var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime * result + (key.hashValue)
    result = prime * result + (taskConfig.hashValue)
    result = prime * result + (instanceIds.hashValue)
    return result
  }

}

extension AddInstancesConfig : TStruct {

  public static func readValueFromProtocol(__proto: TProtocol) throws -> AddInstancesConfig {

    try __proto.readStructBegin()

    var key : JobKey!
    var taskConfig : TaskConfig!
    var instanceIds : TSet<Int32>!

    fields: while true {

      let (_, fieldType, fieldID) = try __proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .STOP):
          break fields

        case (1, .STRUCT):
          key = try __proto.readValue() as JobKey

        case (2, .STRUCT):
          taskConfig = try __proto.readValue() as TaskConfig

        case (3, .SET):
          instanceIds = try __proto.readValue() as TSet<Int32>

        case let (_, unknownType):
          try __proto.skipType(unknownType)
      }

      try __proto.readFieldEnd()
    }

    try __proto.readStructEnd()

    // Required fields
    try __proto.validateValue(key, named: "key")
    try __proto.validateValue(taskConfig, named: "taskConfig")
    try __proto.validateValue(instanceIds, named: "instanceIds")

    return AddInstancesConfig(key: key, taskConfig: taskConfig, instanceIds: instanceIds)
  }

  public static func writeValue(__value: AddInstancesConfig, toProtocol __proto: TProtocol) throws {

    try __proto.writeStructBeginWithName("AddInstancesConfig")

    try __proto.writeFieldValue(__value.key, name: "key", type: .STRUCT, id: 1)

    try __proto.writeFieldValue(__value.taskConfig, name: "taskConfig", type: .STRUCT, id: 2)

    try __proto.writeFieldValue(__value.instanceIds, name: "instanceIds", type: .SET, id: 3)

    try __proto.writeFieldStop()

    try __proto.writeStructEnd()
  }

}



public func ==(lhs: Range, rhs: Range) -> Bool {
  return
    (lhs.first ?== rhs.first) &&
    (lhs.last ?== rhs.last)
}

extension Range : CustomStringConvertible {

  public var description : String {
    var desc = "Range("
    desc += "first=\(self.first), "
    desc += "last=\(self.last)"
    desc += ")"
    return desc
  }

}

extension Range : Hashable {

  public var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime * result + (first.hashValue)
    result = prime * result + (last.hashValue)
    return result
  }

}

extension Range : TStruct {

  public static func readValueFromProtocol(__proto: TProtocol) throws -> Range {

    try __proto.readStructBegin()

    var first : Int32!
    var last : Int32!

    fields: while true {

      let (_, fieldType, fieldID) = try __proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .STOP):
          break fields

        case (1, .I32):
          first = try __proto.readValue() as Int32

        case (2, .I32):
          last = try __proto.readValue() as Int32

        case let (_, unknownType):
          try __proto.skipType(unknownType)
      }

      try __proto.readFieldEnd()
    }

    try __proto.readStructEnd()

    // Required fields
    try __proto.validateValue(first, named: "first")
    try __proto.validateValue(last, named: "last")

    return Range(first: first, last: last)
  }

  public static func writeValue(__value: Range, toProtocol __proto: TProtocol) throws {

    try __proto.writeStructBeginWithName("Range")

    try __proto.writeFieldValue(__value.first, name: "first", type: .I32, id: 1)

    try __proto.writeFieldValue(__value.last, name: "last", type: .I32, id: 2)

    try __proto.writeFieldStop()

    try __proto.writeStructEnd()
  }

}



public func ==(lhs: ConfigGroup, rhs: ConfigGroup) -> Bool {
  return
    (lhs.config ?== rhs.config) &&
    (lhs.instanceIds ?== rhs.instanceIds)
}

extension ConfigGroup : CustomStringConvertible {

  public var description : String {
    var desc = "ConfigGroup("
    desc += "config=\(self.config), "
    desc += "instanceIds=\(self.instanceIds)"
    desc += ")"
    return desc
  }

}

extension ConfigGroup : Hashable {

  public var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime * result + (config.hashValue)
    result = prime * result + (instanceIds.hashValue)
    return result
  }

}

extension ConfigGroup : TStruct {

  public static func readValueFromProtocol(__proto: TProtocol) throws -> ConfigGroup {

    try __proto.readStructBegin()

    var config : TaskConfig!
    var instanceIds : TSet<Int32>!

    fields: while true {

      let (_, fieldType, fieldID) = try __proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .STOP):
          break fields

        case (1, .STRUCT):
          config = try __proto.readValue() as TaskConfig

        case (2, .SET):
          instanceIds = try __proto.readValue() as TSet<Int32>

        case let (_, unknownType):
          try __proto.skipType(unknownType)
      }

      try __proto.readFieldEnd()
    }

    try __proto.readStructEnd()

    // Required fields
    try __proto.validateValue(config, named: "config")
    try __proto.validateValue(instanceIds, named: "instanceIds")

    return ConfigGroup(config: config, instanceIds: instanceIds)
  }

  public static func writeValue(__value: ConfigGroup, toProtocol __proto: TProtocol) throws {

    try __proto.writeStructBeginWithName("ConfigGroup")

    try __proto.writeFieldValue(__value.config, name: "config", type: .STRUCT, id: 1)

    try __proto.writeFieldValue(__value.instanceIds, name: "instanceIds", type: .SET, id: 2)

    try __proto.writeFieldStop()

    try __proto.writeStructEnd()
  }

}



public func ==(lhs: ConfigSummary, rhs: ConfigSummary) -> Bool {
  return
    (lhs.key ?== rhs.key) &&
    (lhs.groups ?== rhs.groups)
}

extension ConfigSummary : CustomStringConvertible {

  public var description : String {
    var desc = "ConfigSummary("
    desc += "key=\(self.key), "
    desc += "groups=\(self.groups)"
    desc += ")"
    return desc
  }

}

extension ConfigSummary : Hashable {

  public var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime * result + (key.hashValue)
    result = prime * result + (groups.hashValue)
    return result
  }

}

extension ConfigSummary : TStruct {

  public static func readValueFromProtocol(__proto: TProtocol) throws -> ConfigSummary {

    try __proto.readStructBegin()

    var key : JobKey!
    var groups : TSet<ConfigGroup>!

    fields: while true {

      let (_, fieldType, fieldID) = try __proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .STOP):
          break fields

        case (1, .STRUCT):
          key = try __proto.readValue() as JobKey

        case (2, .SET):
          groups = try __proto.readValue() as TSet<ConfigGroup>

        case let (_, unknownType):
          try __proto.skipType(unknownType)
      }

      try __proto.readFieldEnd()
    }

    try __proto.readStructEnd()

    // Required fields
    try __proto.validateValue(key, named: "key")
    try __proto.validateValue(groups, named: "groups")

    return ConfigSummary(key: key, groups: groups)
  }

  public static func writeValue(__value: ConfigSummary, toProtocol __proto: TProtocol) throws {

    try __proto.writeStructBeginWithName("ConfigSummary")

    try __proto.writeFieldValue(__value.key, name: "key", type: .STRUCT, id: 1)

    try __proto.writeFieldValue(__value.groups, name: "groups", type: .SET, id: 2)

    try __proto.writeFieldStop()

    try __proto.writeStructEnd()
  }

}



public func ==(lhs: PopulateJobResult, rhs: PopulateJobResult) -> Bool {
  return
    (lhs.taskConfig ?== rhs.taskConfig)
}

extension PopulateJobResult : CustomStringConvertible {

  public var description : String {
    var desc = "PopulateJobResult("
    desc += "taskConfig=\(self.taskConfig)"
    desc += ")"
    return desc
  }

}

extension PopulateJobResult : Hashable {

  public var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime * result + (taskConfig.hashValue)
    return result
  }

}

extension PopulateJobResult : TStruct {

  public static func readValueFromProtocol(__proto: TProtocol) throws -> PopulateJobResult {

    try __proto.readStructBegin()

    var taskConfig : TaskConfig!

    fields: while true {

      let (_, fieldType, fieldID) = try __proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .STOP):
          break fields

        case (2, .STRUCT):
          taskConfig = try __proto.readValue() as TaskConfig

        case let (_, unknownType):
          try __proto.skipType(unknownType)
      }

      try __proto.readFieldEnd()
    }

    try __proto.readStructEnd()

    // Required fields
    try __proto.validateValue(taskConfig, named: "taskConfig")

    return PopulateJobResult(taskConfig: taskConfig)
  }

  public static func writeValue(__value: PopulateJobResult, toProtocol __proto: TProtocol) throws {

    try __proto.writeStructBeginWithName("PopulateJobResult")

    try __proto.writeFieldValue(__value.taskConfig, name: "taskConfig", type: .STRUCT, id: 2)

    try __proto.writeFieldStop()

    try __proto.writeStructEnd()
  }

}



public func ==(lhs: GetQuotaResult, rhs: GetQuotaResult) -> Bool {
  return
    (lhs.quota ?== rhs.quota) &&
    (lhs.prodSharedConsumption ?== rhs.prodSharedConsumption) &&
    (lhs.nonProdSharedConsumption ?== rhs.nonProdSharedConsumption) &&
    (lhs.prodDedicatedConsumption ?== rhs.prodDedicatedConsumption) &&
    (lhs.nonProdDedicatedConsumption ?== rhs.nonProdDedicatedConsumption)
}

extension GetQuotaResult : CustomStringConvertible {

  public var description : String {
    var desc = "GetQuotaResult("
    desc += "quota=\(self.quota), "
    desc += "prodSharedConsumption=\(self.prodSharedConsumption), "
    desc += "nonProdSharedConsumption=\(self.nonProdSharedConsumption), "
    desc += "prodDedicatedConsumption=\(self.prodDedicatedConsumption), "
    desc += "nonProdDedicatedConsumption=\(self.nonProdDedicatedConsumption)"
    desc += ")"
    return desc
  }

}

extension GetQuotaResult : Hashable {

  public var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime * result + (quota.hashValue)
    result = prime * result + (prodSharedConsumption?.hashValue ?? 0)
    result = prime * result + (nonProdSharedConsumption?.hashValue ?? 0)
    result = prime * result + (prodDedicatedConsumption?.hashValue ?? 0)
    result = prime * result + (nonProdDedicatedConsumption?.hashValue ?? 0)
    return result
  }

}

extension GetQuotaResult : TStruct {

  public static func readValueFromProtocol(__proto: TProtocol) throws -> GetQuotaResult {

    try __proto.readStructBegin()

    var quota : ResourceAggregate!
    var prodSharedConsumption : ResourceAggregate?
    var nonProdSharedConsumption : ResourceAggregate?
    var prodDedicatedConsumption : ResourceAggregate?
    var nonProdDedicatedConsumption : ResourceAggregate?

    fields: while true {

      let (_, fieldType, fieldID) = try __proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .STOP):
          break fields

        case (1, .STRUCT):
          quota = try __proto.readValue() as ResourceAggregate

        case (2, .STRUCT):
          prodSharedConsumption = try __proto.readValue() as ResourceAggregate

        case (3, .STRUCT):
          nonProdSharedConsumption = try __proto.readValue() as ResourceAggregate

        case (4, .STRUCT):
          prodDedicatedConsumption = try __proto.readValue() as ResourceAggregate

        case (5, .STRUCT):
          nonProdDedicatedConsumption = try __proto.readValue() as ResourceAggregate

        case let (_, unknownType):
          try __proto.skipType(unknownType)
      }

      try __proto.readFieldEnd()
    }

    try __proto.readStructEnd()

    // Required fields
    try __proto.validateValue(quota, named: "quota")

    return GetQuotaResult(quota: quota, prodSharedConsumption: prodSharedConsumption, nonProdSharedConsumption: nonProdSharedConsumption, prodDedicatedConsumption: prodDedicatedConsumption, nonProdDedicatedConsumption: nonProdDedicatedConsumption)
  }

  public static func writeValue(__value: GetQuotaResult, toProtocol __proto: TProtocol) throws {

    try __proto.writeStructBeginWithName("GetQuotaResult")

    try __proto.writeFieldValue(__value.quota, name: "quota", type: .STRUCT, id: 1)

    if let prodSharedConsumption = __value.prodSharedConsumption {
      try __proto.writeFieldValue(prodSharedConsumption, name: "prodSharedConsumption", type: .STRUCT, id: 2)
    }

    if let nonProdSharedConsumption = __value.nonProdSharedConsumption {
      try __proto.writeFieldValue(nonProdSharedConsumption, name: "nonProdSharedConsumption", type: .STRUCT, id: 3)
    }

    if let prodDedicatedConsumption = __value.prodDedicatedConsumption {
      try __proto.writeFieldValue(prodDedicatedConsumption, name: "prodDedicatedConsumption", type: .STRUCT, id: 4)
    }

    if let nonProdDedicatedConsumption = __value.nonProdDedicatedConsumption {
      try __proto.writeFieldValue(nonProdDedicatedConsumption, name: "nonProdDedicatedConsumption", type: .STRUCT, id: 5)
    }

    try __proto.writeFieldStop()

    try __proto.writeStructEnd()
  }

}



public func ==(lhs: AcquireLockResult, rhs: AcquireLockResult) -> Bool {
  return
    (lhs.lock ?== rhs.lock)
}

extension AcquireLockResult : CustomStringConvertible {

  public var description : String {
    var desc = "AcquireLockResult("
    desc += "lock=\(self.lock)"
    desc += ")"
    return desc
  }

}

extension AcquireLockResult : Hashable {

  public var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime * result + (lock.hashValue)
    return result
  }

}

extension AcquireLockResult : TStruct {

  public static func readValueFromProtocol(__proto: TProtocol) throws -> AcquireLockResult {

    try __proto.readStructBegin()

    var lock : Lock!

    fields: while true {

      let (_, fieldType, fieldID) = try __proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .STOP):
          break fields

        case (1, .STRUCT):
          lock = try __proto.readValue() as Lock

        case let (_, unknownType):
          try __proto.skipType(unknownType)
      }

      try __proto.readFieldEnd()
    }

    try __proto.readStructEnd()

    // Required fields
    try __proto.validateValue(lock, named: "lock")

    return AcquireLockResult(lock: lock)
  }

  public static func writeValue(__value: AcquireLockResult, toProtocol __proto: TProtocol) throws {

    try __proto.writeStructBeginWithName("AcquireLockResult")

    try __proto.writeFieldValue(__value.lock, name: "lock", type: .STRUCT, id: 1)

    try __proto.writeFieldStop()

    try __proto.writeStructEnd()
  }

}



public func ==(lhs: TaskEvent, rhs: TaskEvent) -> Bool {
  return
    (lhs.timestamp ?== rhs.timestamp) &&
    (lhs.status ?== rhs.status) &&
    (lhs.message ?== rhs.message) &&
    (lhs.scheduler ?== rhs.scheduler)
}

extension TaskEvent : CustomStringConvertible {

  public var description : String {
    var desc = "TaskEvent("
    desc += "timestamp=\(self.timestamp), "
    desc += "status=\(self.status), "
    desc += "message=\(self.message), "
    desc += "scheduler=\(self.scheduler)"
    desc += ")"
    return desc
  }

}

extension TaskEvent : Hashable {

  public var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime * result + (timestamp.hashValue)
    result = prime * result + (status.hashValue)
    result = prime * result + (message?.hashValue ?? 0)
    result = prime * result + (scheduler?.hashValue ?? 0)
    return result
  }

}

extension TaskEvent : TStruct {

  public static func readValueFromProtocol(__proto: TProtocol) throws -> TaskEvent {

    try __proto.readStructBegin()

    var timestamp : Int64!
    var status : ScheduleStatus!
    var message : String?
    var scheduler : String?

    fields: while true {

      let (_, fieldType, fieldID) = try __proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .STOP):
          break fields

        case (1, .I64):
          timestamp = try __proto.readValue() as Int64

        case (2, .I32):
          status = try __proto.readValue() as ScheduleStatus

        case (3, .STRING):
          message = try __proto.readValue() as String

        case (4, .STRING):
          scheduler = try __proto.readValue() as String

        case let (_, unknownType):
          try __proto.skipType(unknownType)
      }

      try __proto.readFieldEnd()
    }

    try __proto.readStructEnd()

    // Required fields
    try __proto.validateValue(timestamp, named: "timestamp")
    try __proto.validateValue(status, named: "status")

    return TaskEvent(timestamp: timestamp, status: status, message: message, scheduler: scheduler)
  }

  public static func writeValue(__value: TaskEvent, toProtocol __proto: TProtocol) throws {

    try __proto.writeStructBeginWithName("TaskEvent")

    try __proto.writeFieldValue(__value.timestamp, name: "timestamp", type: .I64, id: 1)

    try __proto.writeFieldValue(__value.status, name: "status", type: .I32, id: 2)

    if let message = __value.message {
      try __proto.writeFieldValue(message, name: "message", type: .STRING, id: 3)
    }

    if let scheduler = __value.scheduler {
      try __proto.writeFieldValue(scheduler, name: "scheduler", type: .STRING, id: 4)
    }

    try __proto.writeFieldStop()

    try __proto.writeStructEnd()
  }

}



public func ==(lhs: AssignedTask, rhs: AssignedTask) -> Bool {
  return
    (lhs.taskId ?== rhs.taskId) &&
    (lhs.slaveId ?== rhs.slaveId) &&
    (lhs.slaveHost ?== rhs.slaveHost) &&
    (lhs.task ?== rhs.task) &&
    (lhs.assignedPorts ?== rhs.assignedPorts) &&
    (lhs.instanceId ?== rhs.instanceId)
}

extension AssignedTask : CustomStringConvertible {

  public var description : String {
    var desc = "AssignedTask("
    desc += "taskId=\(self.taskId), "
    desc += "slaveId=\(self.slaveId), "
    desc += "slaveHost=\(self.slaveHost), "
    desc += "task=\(self.task), "
    desc += "assignedPorts=\(self.assignedPorts), "
    desc += "instanceId=\(self.instanceId)"
    desc += ")"
    return desc
  }

}

extension AssignedTask : Hashable {

  public var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime * result + (taskId.hashValue)
    result = prime * result + (slaveId.hashValue)
    result = prime * result + (slaveHost.hashValue)
    result = prime * result + (task.hashValue)
    result = prime * result + (assignedPorts.hashValue)
    result = prime * result + (instanceId.hashValue)
    return result
  }

}

extension AssignedTask : TStruct {

  public static func readValueFromProtocol(__proto: TProtocol) throws -> AssignedTask {

    try __proto.readStructBegin()

    var taskId : String!
    var slaveId : String!
    var slaveHost : String!
    var task : TaskConfig!
    var assignedPorts : TMap<String, Int32>!
    var instanceId : Int32!

    fields: while true {

      let (_, fieldType, fieldID) = try __proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .STOP):
          break fields

        case (1, .STRING):
          taskId = try __proto.readValue() as String

        case (2, .STRING):
          slaveId = try __proto.readValue() as String

        case (3, .STRING):
          slaveHost = try __proto.readValue() as String

        case (4, .STRUCT):
          task = try __proto.readValue() as TaskConfig

        case (5, .MAP):
          assignedPorts = try __proto.readValue() as TMap<String, Int32>

        case (6, .I32):
          instanceId = try __proto.readValue() as Int32

        case let (_, unknownType):
          try __proto.skipType(unknownType)
      }

      try __proto.readFieldEnd()
    }

    try __proto.readStructEnd()

    // Required fields
    try __proto.validateValue(taskId, named: "taskId")
    try __proto.validateValue(slaveId, named: "slaveId")
    try __proto.validateValue(slaveHost, named: "slaveHost")
    try __proto.validateValue(task, named: "task")
    try __proto.validateValue(assignedPorts, named: "assignedPorts")
    try __proto.validateValue(instanceId, named: "instanceId")

    return AssignedTask(taskId: taskId, slaveId: slaveId, slaveHost: slaveHost, task: task, assignedPorts: assignedPorts, instanceId: instanceId)
  }

  public static func writeValue(__value: AssignedTask, toProtocol __proto: TProtocol) throws {

    try __proto.writeStructBeginWithName("AssignedTask")

    try __proto.writeFieldValue(__value.taskId, name: "taskId", type: .STRING, id: 1)

    try __proto.writeFieldValue(__value.slaveId, name: "slaveId", type: .STRING, id: 2)

    try __proto.writeFieldValue(__value.slaveHost, name: "slaveHost", type: .STRING, id: 3)

    try __proto.writeFieldValue(__value.task, name: "task", type: .STRUCT, id: 4)

    try __proto.writeFieldValue(__value.assignedPorts, name: "assignedPorts", type: .MAP, id: 5)

    try __proto.writeFieldValue(__value.instanceId, name: "instanceId", type: .I32, id: 6)

    try __proto.writeFieldStop()

    try __proto.writeStructEnd()
  }

}



public func ==(lhs: ScheduledTask, rhs: ScheduledTask) -> Bool {
  return
    (lhs.assignedTask ?== rhs.assignedTask) &&
    (lhs.status ?== rhs.status) &&
    (lhs.failureCount ?== rhs.failureCount) &&
    (lhs.taskEvents ?== rhs.taskEvents) &&
    (lhs.ancestorId ?== rhs.ancestorId)
}

extension ScheduledTask : CustomStringConvertible {

  public var description : String {
    var desc = "ScheduledTask("
    desc += "assignedTask=\(self.assignedTask), "
    desc += "status=\(self.status), "
    desc += "failureCount=\(self.failureCount), "
    desc += "taskEvents=\(self.taskEvents), "
    desc += "ancestorId=\(self.ancestorId)"
    desc += ")"
    return desc
  }

}

extension ScheduledTask : Hashable {

  public var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime * result + (assignedTask.hashValue)
    result = prime * result + (status.hashValue)
    result = prime * result + (failureCount.hashValue)
    result = prime * result + (taskEvents.hashValue)
    result = prime * result + (ancestorId.hashValue)
    return result
  }

}

extension ScheduledTask : TStruct {

  public static func readValueFromProtocol(__proto: TProtocol) throws -> ScheduledTask {

    try __proto.readStructBegin()

    var assignedTask : AssignedTask!
    var status : ScheduleStatus!
    var failureCount : Int32!
    var taskEvents : TList<TaskEvent>!
    var ancestorId : String!

    fields: while true {

      let (_, fieldType, fieldID) = try __proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .STOP):
          break fields

        case (1, .STRUCT):
          assignedTask = try __proto.readValue() as AssignedTask

        case (2, .I32):
          status = try __proto.readValue() as ScheduleStatus

        case (3, .I32):
          failureCount = try __proto.readValue() as Int32

        case (4, .LIST):
          taskEvents = try __proto.readValue() as TList<TaskEvent>

        case (5, .STRING):
          ancestorId = try __proto.readValue() as String

        case let (_, unknownType):
          try __proto.skipType(unknownType)
      }

      try __proto.readFieldEnd()
    }

    try __proto.readStructEnd()

    // Required fields
    try __proto.validateValue(assignedTask, named: "assignedTask")
    try __proto.validateValue(status, named: "status")
    try __proto.validateValue(failureCount, named: "failureCount")
    try __proto.validateValue(taskEvents, named: "taskEvents")
    try __proto.validateValue(ancestorId, named: "ancestorId")

    return ScheduledTask(assignedTask: assignedTask, status: status, failureCount: failureCount, taskEvents: taskEvents, ancestorId: ancestorId)
  }

  public static func writeValue(__value: ScheduledTask, toProtocol __proto: TProtocol) throws {

    try __proto.writeStructBeginWithName("ScheduledTask")

    try __proto.writeFieldValue(__value.assignedTask, name: "assignedTask", type: .STRUCT, id: 1)

    try __proto.writeFieldValue(__value.status, name: "status", type: .I32, id: 2)

    try __proto.writeFieldValue(__value.failureCount, name: "failureCount", type: .I32, id: 3)

    try __proto.writeFieldValue(__value.taskEvents, name: "taskEvents", type: .LIST, id: 4)

    try __proto.writeFieldValue(__value.ancestorId, name: "ancestorId", type: .STRING, id: 5)

    try __proto.writeFieldStop()

    try __proto.writeStructEnd()
  }

}



public func ==(lhs: ScheduleStatusResult, rhs: ScheduleStatusResult) -> Bool {
  return
    (lhs.tasks ?== rhs.tasks)
}

extension ScheduleStatusResult : CustomStringConvertible {

  public var description : String {
    var desc = "ScheduleStatusResult("
    desc += "tasks=\(self.tasks)"
    desc += ")"
    return desc
  }

}

extension ScheduleStatusResult : Hashable {

  public var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime * result + (tasks.hashValue)
    return result
  }

}

extension ScheduleStatusResult : TStruct {

  public static func readValueFromProtocol(__proto: TProtocol) throws -> ScheduleStatusResult {

    try __proto.readStructBegin()

    var tasks : TList<ScheduledTask>!

    fields: while true {

      let (_, fieldType, fieldID) = try __proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .STOP):
          break fields

        case (1, .LIST):
          tasks = try __proto.readValue() as TList<ScheduledTask>

        case let (_, unknownType):
          try __proto.skipType(unknownType)
      }

      try __proto.readFieldEnd()
    }

    try __proto.readStructEnd()

    // Required fields
    try __proto.validateValue(tasks, named: "tasks")

    return ScheduleStatusResult(tasks: tasks)
  }

  public static func writeValue(__value: ScheduleStatusResult, toProtocol __proto: TProtocol) throws {

    try __proto.writeStructBeginWithName("ScheduleStatusResult")

    try __proto.writeFieldValue(__value.tasks, name: "tasks", type: .LIST, id: 1)

    try __proto.writeFieldStop()

    try __proto.writeStructEnd()
  }

}



public func ==(lhs: GetJobsResult, rhs: GetJobsResult) -> Bool {
  return
    (lhs.configs ?== rhs.configs)
}

extension GetJobsResult : CustomStringConvertible {

  public var description : String {
    var desc = "GetJobsResult("
    desc += "configs=\(self.configs)"
    desc += ")"
    return desc
  }

}

extension GetJobsResult : Hashable {

  public var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime * result + (configs.hashValue)
    return result
  }

}

extension GetJobsResult : TStruct {

  public static func readValueFromProtocol(__proto: TProtocol) throws -> GetJobsResult {

    try __proto.readStructBegin()

    var configs : TSet<JobConfiguration>!

    fields: while true {

      let (_, fieldType, fieldID) = try __proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .STOP):
          break fields

        case (1, .SET):
          configs = try __proto.readValue() as TSet<JobConfiguration>

        case let (_, unknownType):
          try __proto.skipType(unknownType)
      }

      try __proto.readFieldEnd()
    }

    try __proto.readStructEnd()

    // Required fields
    try __proto.validateValue(configs, named: "configs")

    return GetJobsResult(configs: configs)
  }

  public static func writeValue(__value: GetJobsResult, toProtocol __proto: TProtocol) throws {

    try __proto.writeStructBeginWithName("GetJobsResult")

    try __proto.writeFieldValue(__value.configs, name: "configs", type: .SET, id: 1)

    try __proto.writeFieldStop()

    try __proto.writeStructEnd()
  }

}



public func ==(lhs: TaskQuery, rhs: TaskQuery) -> Bool {
  return
    (lhs.owner ?== rhs.owner) &&
    (lhs.role ?== rhs.role) &&
    (lhs.environment ?== rhs.environment) &&
    (lhs.jobName ?== rhs.jobName) &&
    (lhs.taskIds ?== rhs.taskIds) &&
    (lhs.statuses ?== rhs.statuses) &&
    (lhs.instanceIds ?== rhs.instanceIds) &&
    (lhs.slaveHosts ?== rhs.slaveHosts) &&
    (lhs.jobKeys ?== rhs.jobKeys) &&
    (lhs.offset ?== rhs.offset) &&
    (lhs.limit ?== rhs.limit)
}

extension TaskQuery : CustomStringConvertible {

  public var description : String {
    var desc = "TaskQuery("
    desc += "owner=\(self.owner), "
    desc += "role=\(self.role), "
    desc += "environment=\(self.environment), "
    desc += "jobName=\(self.jobName), "
    desc += "taskIds=\(self.taskIds), "
    desc += "statuses=\(self.statuses), "
    desc += "instanceIds=\(self.instanceIds), "
    desc += "slaveHosts=\(self.slaveHosts), "
    desc += "jobKeys=\(self.jobKeys), "
    desc += "offset=\(self.offset), "
    desc += "limit=\(self.limit)"
    desc += ")"
    return desc
  }

}

extension TaskQuery : Hashable {

  public var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime * result + (owner.hashValue)
    result = prime * result + (role.hashValue)
    result = prime * result + (environment.hashValue)
    result = prime * result + (jobName.hashValue)
    result = prime * result + (taskIds.hashValue)
    result = prime * result + (statuses.hashValue)
    result = prime * result + (instanceIds.hashValue)
    result = prime * result + (slaveHosts.hashValue)
    result = prime * result + (jobKeys.hashValue)
    result = prime * result + (offset.hashValue)
    result = prime * result + (limit.hashValue)
    return result
  }

}

extension TaskQuery : TStruct {

  public static func readValueFromProtocol(__proto: TProtocol) throws -> TaskQuery {

    try __proto.readStructBegin()

    var owner : Identity!
    var role : String!
    var environment : String!
    var jobName : String!
    var taskIds : TSet<String>!
    var statuses : TSet<ScheduleStatus>!
    var instanceIds : TSet<Int32>!
    var slaveHosts : TSet<String>!
    var jobKeys : TSet<JobKey>!
    var offset : Int32!
    var limit : Int32!

    fields: while true {

      let (_, fieldType, fieldID) = try __proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .STOP):
          break fields

        case (8, .STRUCT):
          owner = try __proto.readValue() as Identity

        case (14, .STRING):
          role = try __proto.readValue() as String

        case (9, .STRING):
          environment = try __proto.readValue() as String

        case (2, .STRING):
          jobName = try __proto.readValue() as String

        case (4, .SET):
          taskIds = try __proto.readValue() as TSet<String>

        case (5, .SET):
          statuses = try __proto.readValue() as TSet<ScheduleStatus>

        case (7, .SET):
          instanceIds = try __proto.readValue() as TSet<Int32>

        case (10, .SET):
          slaveHosts = try __proto.readValue() as TSet<String>

        case (11, .SET):
          jobKeys = try __proto.readValue() as TSet<JobKey>

        case (12, .I32):
          offset = try __proto.readValue() as Int32

        case (13, .I32):
          limit = try __proto.readValue() as Int32

        case let (_, unknownType):
          try __proto.skipType(unknownType)
      }

      try __proto.readFieldEnd()
    }

    try __proto.readStructEnd()

    // Required fields
    try __proto.validateValue(owner, named: "owner")
    try __proto.validateValue(role, named: "role")
    try __proto.validateValue(environment, named: "environment")
    try __proto.validateValue(jobName, named: "jobName")
    try __proto.validateValue(taskIds, named: "taskIds")
    try __proto.validateValue(statuses, named: "statuses")
    try __proto.validateValue(instanceIds, named: "instanceIds")
    try __proto.validateValue(slaveHosts, named: "slaveHosts")
    try __proto.validateValue(jobKeys, named: "jobKeys")
    try __proto.validateValue(offset, named: "offset")
    try __proto.validateValue(limit, named: "limit")

    return TaskQuery(owner: owner, role: role, environment: environment, jobName: jobName, taskIds: taskIds, statuses: statuses, instanceIds: instanceIds, slaveHosts: slaveHosts, jobKeys: jobKeys, offset: offset, limit: limit)
  }

  public static func writeValue(__value: TaskQuery, toProtocol __proto: TProtocol) throws {

    try __proto.writeStructBeginWithName("TaskQuery")

    try __proto.writeFieldValue(__value.owner, name: "owner", type: .STRUCT, id: 8)

    try __proto.writeFieldValue(__value.role, name: "role", type: .STRING, id: 14)

    try __proto.writeFieldValue(__value.environment, name: "environment", type: .STRING, id: 9)

    try __proto.writeFieldValue(__value.jobName, name: "jobName", type: .STRING, id: 2)

    try __proto.writeFieldValue(__value.taskIds, name: "taskIds", type: .SET, id: 4)

    try __proto.writeFieldValue(__value.statuses, name: "statuses", type: .SET, id: 5)

    try __proto.writeFieldValue(__value.instanceIds, name: "instanceIds", type: .SET, id: 7)

    try __proto.writeFieldValue(__value.slaveHosts, name: "slaveHosts", type: .SET, id: 10)

    try __proto.writeFieldValue(__value.jobKeys, name: "jobKeys", type: .SET, id: 11)

    try __proto.writeFieldValue(__value.offset, name: "offset", type: .I32, id: 12)

    try __proto.writeFieldValue(__value.limit, name: "limit", type: .I32, id: 13)

    try __proto.writeFieldStop()

    try __proto.writeStructEnd()
  }

}



public func ==(lhs: HostStatus, rhs: HostStatus) -> Bool {
  return
    (lhs.host ?== rhs.host) &&
    (lhs.mode ?== rhs.mode)
}

extension HostStatus : CustomStringConvertible {

  public var description : String {
    var desc = "HostStatus("
    desc += "host=\(self.host), "
    desc += "mode=\(self.mode)"
    desc += ")"
    return desc
  }

}

extension HostStatus : Hashable {

  public var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime * result + (host.hashValue)
    result = prime * result + (mode.hashValue)
    return result
  }

}

extension HostStatus : TStruct {

  public static func readValueFromProtocol(__proto: TProtocol) throws -> HostStatus {

    try __proto.readStructBegin()

    var host : String!
    var mode : MaintenanceMode!

    fields: while true {

      let (_, fieldType, fieldID) = try __proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .STOP):
          break fields

        case (1, .STRING):
          host = try __proto.readValue() as String

        case (2, .I32):
          mode = try __proto.readValue() as MaintenanceMode

        case let (_, unknownType):
          try __proto.skipType(unknownType)
      }

      try __proto.readFieldEnd()
    }

    try __proto.readStructEnd()

    // Required fields
    try __proto.validateValue(host, named: "host")
    try __proto.validateValue(mode, named: "mode")

    return HostStatus(host: host, mode: mode)
  }

  public static func writeValue(__value: HostStatus, toProtocol __proto: TProtocol) throws {

    try __proto.writeStructBeginWithName("HostStatus")

    try __proto.writeFieldValue(__value.host, name: "host", type: .STRING, id: 1)

    try __proto.writeFieldValue(__value.mode, name: "mode", type: .I32, id: 2)

    try __proto.writeFieldStop()

    try __proto.writeStructEnd()
  }

}



public func ==(lhs: RoleSummary, rhs: RoleSummary) -> Bool {
  return
    (lhs.role ?== rhs.role) &&
    (lhs.jobCount ?== rhs.jobCount) &&
    (lhs.cronJobCount ?== rhs.cronJobCount)
}

extension RoleSummary : CustomStringConvertible {

  public var description : String {
    var desc = "RoleSummary("
    desc += "role=\(self.role), "
    desc += "jobCount=\(self.jobCount), "
    desc += "cronJobCount=\(self.cronJobCount)"
    desc += ")"
    return desc
  }

}

extension RoleSummary : Hashable {

  public var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime * result + (role.hashValue)
    result = prime * result + (jobCount.hashValue)
    result = prime * result + (cronJobCount.hashValue)
    return result
  }

}

extension RoleSummary : TStruct {

  public static func readValueFromProtocol(__proto: TProtocol) throws -> RoleSummary {

    try __proto.readStructBegin()

    var role : String!
    var jobCount : Int32!
    var cronJobCount : Int32!

    fields: while true {

      let (_, fieldType, fieldID) = try __proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .STOP):
          break fields

        case (1, .STRING):
          role = try __proto.readValue() as String

        case (2, .I32):
          jobCount = try __proto.readValue() as Int32

        case (3, .I32):
          cronJobCount = try __proto.readValue() as Int32

        case let (_, unknownType):
          try __proto.skipType(unknownType)
      }

      try __proto.readFieldEnd()
    }

    try __proto.readStructEnd()

    // Required fields
    try __proto.validateValue(role, named: "role")
    try __proto.validateValue(jobCount, named: "jobCount")
    try __proto.validateValue(cronJobCount, named: "cronJobCount")

    return RoleSummary(role: role, jobCount: jobCount, cronJobCount: cronJobCount)
  }

  public static func writeValue(__value: RoleSummary, toProtocol __proto: TProtocol) throws {

    try __proto.writeStructBeginWithName("RoleSummary")

    try __proto.writeFieldValue(__value.role, name: "role", type: .STRING, id: 1)

    try __proto.writeFieldValue(__value.jobCount, name: "jobCount", type: .I32, id: 2)

    try __proto.writeFieldValue(__value.cronJobCount, name: "cronJobCount", type: .I32, id: 3)

    try __proto.writeFieldStop()

    try __proto.writeStructEnd()
  }

}



public func ==(lhs: Hosts, rhs: Hosts) -> Bool {
  return
    (lhs.hostNames ?== rhs.hostNames)
}

extension Hosts : CustomStringConvertible {

  public var description : String {
    var desc = "Hosts("
    desc += "hostNames=\(self.hostNames)"
    desc += ")"
    return desc
  }

}

extension Hosts : Hashable {

  public var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime * result + (hostNames.hashValue)
    return result
  }

}

extension Hosts : TStruct {

  public static func readValueFromProtocol(__proto: TProtocol) throws -> Hosts {

    try __proto.readStructBegin()

    var hostNames : TSet<String>!

    fields: while true {

      let (_, fieldType, fieldID) = try __proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .STOP):
          break fields

        case (1, .SET):
          hostNames = try __proto.readValue() as TSet<String>

        case let (_, unknownType):
          try __proto.skipType(unknownType)
      }

      try __proto.readFieldEnd()
    }

    try __proto.readStructEnd()

    // Required fields
    try __proto.validateValue(hostNames, named: "hostNames")

    return Hosts(hostNames: hostNames)
  }

  public static func writeValue(__value: Hosts, toProtocol __proto: TProtocol) throws {

    try __proto.writeStructBeginWithName("Hosts")

    try __proto.writeFieldValue(__value.hostNames, name: "hostNames", type: .SET, id: 1)

    try __proto.writeFieldStop()

    try __proto.writeStructEnd()
  }

}



public func ==(lhs: PendingReason, rhs: PendingReason) -> Bool {
  return
    (lhs.taskId ?== rhs.taskId) &&
    (lhs.reason ?== rhs.reason)
}

extension PendingReason : CustomStringConvertible {

  public var description : String {
    var desc = "PendingReason("
    desc += "taskId=\(self.taskId), "
    desc += "reason=\(self.reason)"
    desc += ")"
    return desc
  }

}

extension PendingReason : Hashable {

  public var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime * result + (taskId.hashValue)
    result = prime * result + (reason.hashValue)
    return result
  }

}

extension PendingReason : TStruct {

  public static func readValueFromProtocol(__proto: TProtocol) throws -> PendingReason {

    try __proto.readStructBegin()

    var taskId : String!
    var reason : String!

    fields: while true {

      let (_, fieldType, fieldID) = try __proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .STOP):
          break fields

        case (1, .STRING):
          taskId = try __proto.readValue() as String

        case (2, .STRING):
          reason = try __proto.readValue() as String

        case let (_, unknownType):
          try __proto.skipType(unknownType)
      }

      try __proto.readFieldEnd()
    }

    try __proto.readStructEnd()

    // Required fields
    try __proto.validateValue(taskId, named: "taskId")
    try __proto.validateValue(reason, named: "reason")

    return PendingReason(taskId: taskId, reason: reason)
  }

  public static func writeValue(__value: PendingReason, toProtocol __proto: TProtocol) throws {

    try __proto.writeStructBeginWithName("PendingReason")

    try __proto.writeFieldValue(__value.taskId, name: "taskId", type: .STRING, id: 1)

    try __proto.writeFieldValue(__value.reason, name: "reason", type: .STRING, id: 2)

    try __proto.writeFieldStop()

    try __proto.writeStructEnd()
  }

}



public func ==(lhs: JobUpdateKey, rhs: JobUpdateKey) -> Bool {
  return
    (lhs.job ?== rhs.job) &&
    (lhs.id ?== rhs.id)
}

extension JobUpdateKey : CustomStringConvertible {

  public var description : String {
    var desc = "JobUpdateKey("
    desc += "job=\(self.job), "
    desc += "id=\(self.id)"
    desc += ")"
    return desc
  }

}

extension JobUpdateKey : Hashable {

  public var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime * result + (job.hashValue)
    result = prime * result + (id.hashValue)
    return result
  }

}

extension JobUpdateKey : TStruct {

  public static func readValueFromProtocol(__proto: TProtocol) throws -> JobUpdateKey {

    try __proto.readStructBegin()

    var job : JobKey!
    var id : String!

    fields: while true {

      let (_, fieldType, fieldID) = try __proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .STOP):
          break fields

        case (1, .STRUCT):
          job = try __proto.readValue() as JobKey

        case (2, .STRING):
          id = try __proto.readValue() as String

        case let (_, unknownType):
          try __proto.skipType(unknownType)
      }

      try __proto.readFieldEnd()
    }

    try __proto.readStructEnd()

    // Required fields
    try __proto.validateValue(job, named: "job")
    try __proto.validateValue(id, named: "id")

    return JobUpdateKey(job: job, id: id)
  }

  public static func writeValue(__value: JobUpdateKey, toProtocol __proto: TProtocol) throws {

    try __proto.writeStructBeginWithName("JobUpdateKey")

    try __proto.writeFieldValue(__value.job, name: "job", type: .STRUCT, id: 1)

    try __proto.writeFieldValue(__value.id, name: "id", type: .STRING, id: 2)

    try __proto.writeFieldStop()

    try __proto.writeStructEnd()
  }

}



public func ==(lhs: JobUpdateSettings, rhs: JobUpdateSettings) -> Bool {
  return
    (lhs.updateGroupSize ?== rhs.updateGroupSize) &&
    (lhs.maxPerInstanceFailures ?== rhs.maxPerInstanceFailures) &&
    (lhs.maxFailedInstances ?== rhs.maxFailedInstances) &&
    (lhs.maxWaitToInstanceRunningMs ?== rhs.maxWaitToInstanceRunningMs) &&
    (lhs.minWaitInInstanceRunningMs ?== rhs.minWaitInInstanceRunningMs) &&
    (lhs.rollbackOnFailure ?== rhs.rollbackOnFailure) &&
    (lhs.updateOnlyTheseInstances ?== rhs.updateOnlyTheseInstances) &&
    (lhs.waitForBatchCompletion ?== rhs.waitForBatchCompletion) &&
    (lhs.blockIfNoPulsesAfterMs ?== rhs.blockIfNoPulsesAfterMs)
}

extension JobUpdateSettings : CustomStringConvertible {

  public var description : String {
    var desc = "JobUpdateSettings("
    desc += "updateGroupSize=\(self.updateGroupSize), "
    desc += "maxPerInstanceFailures=\(self.maxPerInstanceFailures), "
    desc += "maxFailedInstances=\(self.maxFailedInstances), "
    desc += "maxWaitToInstanceRunningMs=\(self.maxWaitToInstanceRunningMs), "
    desc += "minWaitInInstanceRunningMs=\(self.minWaitInInstanceRunningMs), "
    desc += "rollbackOnFailure=\(self.rollbackOnFailure), "
    desc += "updateOnlyTheseInstances=\(self.updateOnlyTheseInstances), "
    desc += "waitForBatchCompletion=\(self.waitForBatchCompletion), "
    desc += "blockIfNoPulsesAfterMs=\(self.blockIfNoPulsesAfterMs)"
    desc += ")"
    return desc
  }

}

extension JobUpdateSettings : Hashable {

  public var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime * result + (updateGroupSize.hashValue)
    result = prime * result + (maxPerInstanceFailures.hashValue)
    result = prime * result + (maxFailedInstances.hashValue)
    result = prime * result + (maxWaitToInstanceRunningMs.hashValue)
    result = prime * result + (minWaitInInstanceRunningMs.hashValue)
    result = prime * result + (rollbackOnFailure.hashValue)
    result = prime * result + (updateOnlyTheseInstances.hashValue)
    result = prime * result + (waitForBatchCompletion.hashValue)
    result = prime * result + (blockIfNoPulsesAfterMs?.hashValue ?? 0)
    return result
  }

}

extension JobUpdateSettings : TStruct {

  public static func readValueFromProtocol(__proto: TProtocol) throws -> JobUpdateSettings {

    try __proto.readStructBegin()

    var updateGroupSize : Int32!
    var maxPerInstanceFailures : Int32!
    var maxFailedInstances : Int32!
    var maxWaitToInstanceRunningMs : Int32!
    var minWaitInInstanceRunningMs : Int32!
    var rollbackOnFailure : Bool!
    var updateOnlyTheseInstances : TSet<Range>!
    var waitForBatchCompletion : Bool!
    var blockIfNoPulsesAfterMs : Int32?

    fields: while true {

      let (_, fieldType, fieldID) = try __proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .STOP):
          break fields

        case (1, .I32):
          updateGroupSize = try __proto.readValue() as Int32

        case (2, .I32):
          maxPerInstanceFailures = try __proto.readValue() as Int32

        case (3, .I32):
          maxFailedInstances = try __proto.readValue() as Int32

        case (4, .I32):
          maxWaitToInstanceRunningMs = try __proto.readValue() as Int32

        case (5, .I32):
          minWaitInInstanceRunningMs = try __proto.readValue() as Int32

        case (6, .BOOL):
          rollbackOnFailure = try __proto.readValue() as Bool

        case (7, .SET):
          updateOnlyTheseInstances = try __proto.readValue() as TSet<Range>

        case (8, .BOOL):
          waitForBatchCompletion = try __proto.readValue() as Bool

        case (9, .I32):
          blockIfNoPulsesAfterMs = try __proto.readValue() as Int32

        case let (_, unknownType):
          try __proto.skipType(unknownType)
      }

      try __proto.readFieldEnd()
    }

    try __proto.readStructEnd()

    // Required fields
    try __proto.validateValue(updateGroupSize, named: "updateGroupSize")
    try __proto.validateValue(maxPerInstanceFailures, named: "maxPerInstanceFailures")
    try __proto.validateValue(maxFailedInstances, named: "maxFailedInstances")
    try __proto.validateValue(maxWaitToInstanceRunningMs, named: "maxWaitToInstanceRunningMs")
    try __proto.validateValue(minWaitInInstanceRunningMs, named: "minWaitInInstanceRunningMs")
    try __proto.validateValue(rollbackOnFailure, named: "rollbackOnFailure")
    try __proto.validateValue(updateOnlyTheseInstances, named: "updateOnlyTheseInstances")
    try __proto.validateValue(waitForBatchCompletion, named: "waitForBatchCompletion")

    return JobUpdateSettings(updateGroupSize: updateGroupSize, maxPerInstanceFailures: maxPerInstanceFailures, maxFailedInstances: maxFailedInstances, maxWaitToInstanceRunningMs: maxWaitToInstanceRunningMs, minWaitInInstanceRunningMs: minWaitInInstanceRunningMs, rollbackOnFailure: rollbackOnFailure, updateOnlyTheseInstances: updateOnlyTheseInstances, waitForBatchCompletion: waitForBatchCompletion, blockIfNoPulsesAfterMs: blockIfNoPulsesAfterMs)
  }

  public static func writeValue(__value: JobUpdateSettings, toProtocol __proto: TProtocol) throws {

    try __proto.writeStructBeginWithName("JobUpdateSettings")

    try __proto.writeFieldValue(__value.updateGroupSize, name: "updateGroupSize", type: .I32, id: 1)

    try __proto.writeFieldValue(__value.maxPerInstanceFailures, name: "maxPerInstanceFailures", type: .I32, id: 2)

    try __proto.writeFieldValue(__value.maxFailedInstances, name: "maxFailedInstances", type: .I32, id: 3)

    try __proto.writeFieldValue(__value.maxWaitToInstanceRunningMs, name: "maxWaitToInstanceRunningMs", type: .I32, id: 4)

    try __proto.writeFieldValue(__value.minWaitInInstanceRunningMs, name: "minWaitInInstanceRunningMs", type: .I32, id: 5)

    try __proto.writeFieldValue(__value.rollbackOnFailure, name: "rollbackOnFailure", type: .BOOL, id: 6)

    try __proto.writeFieldValue(__value.updateOnlyTheseInstances, name: "updateOnlyTheseInstances", type: .SET, id: 7)

    try __proto.writeFieldValue(__value.waitForBatchCompletion, name: "waitForBatchCompletion", type: .BOOL, id: 8)

    if let blockIfNoPulsesAfterMs = __value.blockIfNoPulsesAfterMs {
      try __proto.writeFieldValue(blockIfNoPulsesAfterMs, name: "blockIfNoPulsesAfterMs", type: .I32, id: 9)
    }

    try __proto.writeFieldStop()

    try __proto.writeStructEnd()
  }

}



public func ==(lhs: JobUpdateEvent, rhs: JobUpdateEvent) -> Bool {
  return
    (lhs.status ?== rhs.status) &&
    (lhs.timestampMs ?== rhs.timestampMs) &&
    (lhs.user ?== rhs.user) &&
    (lhs.message ?== rhs.message)
}

extension JobUpdateEvent : CustomStringConvertible {

  public var description : String {
    var desc = "JobUpdateEvent("
    desc += "status=\(self.status), "
    desc += "timestampMs=\(self.timestampMs), "
    desc += "user=\(self.user), "
    desc += "message=\(self.message)"
    desc += ")"
    return desc
  }

}

extension JobUpdateEvent : Hashable {

  public var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime * result + (status.hashValue)
    result = prime * result + (timestampMs.hashValue)
    result = prime * result + (user?.hashValue ?? 0)
    result = prime * result + (message?.hashValue ?? 0)
    return result
  }

}

extension JobUpdateEvent : TStruct {

  public static func readValueFromProtocol(__proto: TProtocol) throws -> JobUpdateEvent {

    try __proto.readStructBegin()

    var status : JobUpdateStatus!
    var timestampMs : Int64!
    var user : String?
    var message : String?

    fields: while true {

      let (_, fieldType, fieldID) = try __proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .STOP):
          break fields

        case (1, .I32):
          status = try __proto.readValue() as JobUpdateStatus

        case (2, .I64):
          timestampMs = try __proto.readValue() as Int64

        case (3, .STRING):
          user = try __proto.readValue() as String

        case (4, .STRING):
          message = try __proto.readValue() as String

        case let (_, unknownType):
          try __proto.skipType(unknownType)
      }

      try __proto.readFieldEnd()
    }

    try __proto.readStructEnd()

    // Required fields
    try __proto.validateValue(status, named: "status")
    try __proto.validateValue(timestampMs, named: "timestampMs")

    return JobUpdateEvent(status: status, timestampMs: timestampMs, user: user, message: message)
  }

  public static func writeValue(__value: JobUpdateEvent, toProtocol __proto: TProtocol) throws {

    try __proto.writeStructBeginWithName("JobUpdateEvent")

    try __proto.writeFieldValue(__value.status, name: "status", type: .I32, id: 1)

    try __proto.writeFieldValue(__value.timestampMs, name: "timestampMs", type: .I64, id: 2)

    if let user = __value.user {
      try __proto.writeFieldValue(user, name: "user", type: .STRING, id: 3)
    }

    if let message = __value.message {
      try __proto.writeFieldValue(message, name: "message", type: .STRING, id: 4)
    }

    try __proto.writeFieldStop()

    try __proto.writeStructEnd()
  }

}



public func ==(lhs: JobInstanceUpdateEvent, rhs: JobInstanceUpdateEvent) -> Bool {
  return
    (lhs.instanceId ?== rhs.instanceId) &&
    (lhs.timestampMs ?== rhs.timestampMs) &&
    (lhs.action ?== rhs.action)
}

extension JobInstanceUpdateEvent : CustomStringConvertible {

  public var description : String {
    var desc = "JobInstanceUpdateEvent("
    desc += "instanceId=\(self.instanceId), "
    desc += "timestampMs=\(self.timestampMs), "
    desc += "action=\(self.action)"
    desc += ")"
    return desc
  }

}

extension JobInstanceUpdateEvent : Hashable {

  public var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime * result + (instanceId.hashValue)
    result = prime * result + (timestampMs.hashValue)
    result = prime * result + (action.hashValue)
    return result
  }

}

extension JobInstanceUpdateEvent : TStruct {

  public static func readValueFromProtocol(__proto: TProtocol) throws -> JobInstanceUpdateEvent {

    try __proto.readStructBegin()

    var instanceId : Int32!
    var timestampMs : Int64!
    var action : JobUpdateAction!

    fields: while true {

      let (_, fieldType, fieldID) = try __proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .STOP):
          break fields

        case (1, .I32):
          instanceId = try __proto.readValue() as Int32

        case (2, .I64):
          timestampMs = try __proto.readValue() as Int64

        case (3, .I32):
          action = try __proto.readValue() as JobUpdateAction

        case let (_, unknownType):
          try __proto.skipType(unknownType)
      }

      try __proto.readFieldEnd()
    }

    try __proto.readStructEnd()

    // Required fields
    try __proto.validateValue(instanceId, named: "instanceId")
    try __proto.validateValue(timestampMs, named: "timestampMs")
    try __proto.validateValue(action, named: "action")

    return JobInstanceUpdateEvent(instanceId: instanceId, timestampMs: timestampMs, action: action)
  }

  public static func writeValue(__value: JobInstanceUpdateEvent, toProtocol __proto: TProtocol) throws {

    try __proto.writeStructBeginWithName("JobInstanceUpdateEvent")

    try __proto.writeFieldValue(__value.instanceId, name: "instanceId", type: .I32, id: 1)

    try __proto.writeFieldValue(__value.timestampMs, name: "timestampMs", type: .I64, id: 2)

    try __proto.writeFieldValue(__value.action, name: "action", type: .I32, id: 3)

    try __proto.writeFieldStop()

    try __proto.writeStructEnd()
  }

}



public func ==(lhs: InstanceTaskConfig, rhs: InstanceTaskConfig) -> Bool {
  return
    (lhs.task ?== rhs.task) &&
    (lhs.instances ?== rhs.instances)
}

extension InstanceTaskConfig : CustomStringConvertible {

  public var description : String {
    var desc = "InstanceTaskConfig("
    desc += "task=\(self.task), "
    desc += "instances=\(self.instances)"
    desc += ")"
    return desc
  }

}

extension InstanceTaskConfig : Hashable {

  public var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime * result + (task.hashValue)
    result = prime * result + (instances.hashValue)
    return result
  }

}

extension InstanceTaskConfig : TStruct {

  public static func readValueFromProtocol(__proto: TProtocol) throws -> InstanceTaskConfig {

    try __proto.readStructBegin()

    var task : TaskConfig!
    var instances : TSet<Range>!

    fields: while true {

      let (_, fieldType, fieldID) = try __proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .STOP):
          break fields

        case (1, .STRUCT):
          task = try __proto.readValue() as TaskConfig

        case (2, .SET):
          instances = try __proto.readValue() as TSet<Range>

        case let (_, unknownType):
          try __proto.skipType(unknownType)
      }

      try __proto.readFieldEnd()
    }

    try __proto.readStructEnd()

    // Required fields
    try __proto.validateValue(task, named: "task")
    try __proto.validateValue(instances, named: "instances")

    return InstanceTaskConfig(task: task, instances: instances)
  }

  public static func writeValue(__value: InstanceTaskConfig, toProtocol __proto: TProtocol) throws {

    try __proto.writeStructBeginWithName("InstanceTaskConfig")

    try __proto.writeFieldValue(__value.task, name: "task", type: .STRUCT, id: 1)

    try __proto.writeFieldValue(__value.instances, name: "instances", type: .SET, id: 2)

    try __proto.writeFieldStop()

    try __proto.writeStructEnd()
  }

}



public func ==(lhs: JobUpdateState, rhs: JobUpdateState) -> Bool {
  return
    (lhs.status ?== rhs.status) &&
    (lhs.createdTimestampMs ?== rhs.createdTimestampMs) &&
    (lhs.lastModifiedTimestampMs ?== rhs.lastModifiedTimestampMs)
}

extension JobUpdateState : CustomStringConvertible {

  public var description : String {
    var desc = "JobUpdateState("
    desc += "status=\(self.status), "
    desc += "createdTimestampMs=\(self.createdTimestampMs), "
    desc += "lastModifiedTimestampMs=\(self.lastModifiedTimestampMs)"
    desc += ")"
    return desc
  }

}

extension JobUpdateState : Hashable {

  public var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime * result + (status.hashValue)
    result = prime * result + (createdTimestampMs.hashValue)
    result = prime * result + (lastModifiedTimestampMs.hashValue)
    return result
  }

}

extension JobUpdateState : TStruct {

  public static func readValueFromProtocol(__proto: TProtocol) throws -> JobUpdateState {

    try __proto.readStructBegin()

    var status : JobUpdateStatus!
    var createdTimestampMs : Int64!
    var lastModifiedTimestampMs : Int64!

    fields: while true {

      let (_, fieldType, fieldID) = try __proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .STOP):
          break fields

        case (1, .I32):
          status = try __proto.readValue() as JobUpdateStatus

        case (2, .I64):
          createdTimestampMs = try __proto.readValue() as Int64

        case (3, .I64):
          lastModifiedTimestampMs = try __proto.readValue() as Int64

        case let (_, unknownType):
          try __proto.skipType(unknownType)
      }

      try __proto.readFieldEnd()
    }

    try __proto.readStructEnd()

    // Required fields
    try __proto.validateValue(status, named: "status")
    try __proto.validateValue(createdTimestampMs, named: "createdTimestampMs")
    try __proto.validateValue(lastModifiedTimestampMs, named: "lastModifiedTimestampMs")

    return JobUpdateState(status: status, createdTimestampMs: createdTimestampMs, lastModifiedTimestampMs: lastModifiedTimestampMs)
  }

  public static func writeValue(__value: JobUpdateState, toProtocol __proto: TProtocol) throws {

    try __proto.writeStructBeginWithName("JobUpdateState")

    try __proto.writeFieldValue(__value.status, name: "status", type: .I32, id: 1)

    try __proto.writeFieldValue(__value.createdTimestampMs, name: "createdTimestampMs", type: .I64, id: 2)

    try __proto.writeFieldValue(__value.lastModifiedTimestampMs, name: "lastModifiedTimestampMs", type: .I64, id: 3)

    try __proto.writeFieldStop()

    try __proto.writeStructEnd()
  }

}



public func ==(lhs: JobUpdateSummary, rhs: JobUpdateSummary) -> Bool {
  return
    (lhs.key ?== rhs.key) &&
    (lhs.user ?== rhs.user) &&
    (lhs.state ?== rhs.state)
}

extension JobUpdateSummary : CustomStringConvertible {

  public var description : String {
    var desc = "JobUpdateSummary("
    desc += "key=\(self.key), "
    desc += "user=\(self.user), "
    desc += "state=\(self.state)"
    desc += ")"
    return desc
  }

}

extension JobUpdateSummary : Hashable {

  public var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime * result + (key.hashValue)
    result = prime * result + (user.hashValue)
    result = prime * result + (state.hashValue)
    return result
  }

}

extension JobUpdateSummary : TStruct {

  public static func readValueFromProtocol(__proto: TProtocol) throws -> JobUpdateSummary {

    try __proto.readStructBegin()

    var key : JobUpdateKey!
    var user : String!
    var state : JobUpdateState!

    fields: while true {

      let (_, fieldType, fieldID) = try __proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .STOP):
          break fields

        case (5, .STRUCT):
          key = try __proto.readValue() as JobUpdateKey

        case (3, .STRING):
          user = try __proto.readValue() as String

        case (4, .STRUCT):
          state = try __proto.readValue() as JobUpdateState

        case let (_, unknownType):
          try __proto.skipType(unknownType)
      }

      try __proto.readFieldEnd()
    }

    try __proto.readStructEnd()

    // Required fields
    try __proto.validateValue(key, named: "key")
    try __proto.validateValue(user, named: "user")
    try __proto.validateValue(state, named: "state")

    return JobUpdateSummary(key: key, user: user, state: state)
  }

  public static func writeValue(__value: JobUpdateSummary, toProtocol __proto: TProtocol) throws {

    try __proto.writeStructBeginWithName("JobUpdateSummary")

    try __proto.writeFieldValue(__value.key, name: "key", type: .STRUCT, id: 5)

    try __proto.writeFieldValue(__value.user, name: "user", type: .STRING, id: 3)

    try __proto.writeFieldValue(__value.state, name: "state", type: .STRUCT, id: 4)

    try __proto.writeFieldStop()

    try __proto.writeStructEnd()
  }

}



public func ==(lhs: JobUpdateInstructions, rhs: JobUpdateInstructions) -> Bool {
  return
    (lhs.initialState ?== rhs.initialState) &&
    (lhs.desiredState ?== rhs.desiredState) &&
    (lhs.settings ?== rhs.settings)
}

extension JobUpdateInstructions : CustomStringConvertible {

  public var description : String {
    var desc = "JobUpdateInstructions("
    desc += "initialState=\(self.initialState), "
    desc += "desiredState=\(self.desiredState), "
    desc += "settings=\(self.settings)"
    desc += ")"
    return desc
  }

}

extension JobUpdateInstructions : Hashable {

  public var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime * result + (initialState.hashValue)
    result = prime * result + (desiredState.hashValue)
    result = prime * result + (settings.hashValue)
    return result
  }

}

extension JobUpdateInstructions : TStruct {

  public static func readValueFromProtocol(__proto: TProtocol) throws -> JobUpdateInstructions {

    try __proto.readStructBegin()

    var initialState : TSet<InstanceTaskConfig>!
    var desiredState : InstanceTaskConfig!
    var settings : JobUpdateSettings!

    fields: while true {

      let (_, fieldType, fieldID) = try __proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .STOP):
          break fields

        case (1, .SET):
          initialState = try __proto.readValue() as TSet<InstanceTaskConfig>

        case (2, .STRUCT):
          desiredState = try __proto.readValue() as InstanceTaskConfig

        case (3, .STRUCT):
          settings = try __proto.readValue() as JobUpdateSettings

        case let (_, unknownType):
          try __proto.skipType(unknownType)
      }

      try __proto.readFieldEnd()
    }

    try __proto.readStructEnd()

    // Required fields
    try __proto.validateValue(initialState, named: "initialState")
    try __proto.validateValue(desiredState, named: "desiredState")
    try __proto.validateValue(settings, named: "settings")

    return JobUpdateInstructions(initialState: initialState, desiredState: desiredState, settings: settings)
  }

  public static func writeValue(__value: JobUpdateInstructions, toProtocol __proto: TProtocol) throws {

    try __proto.writeStructBeginWithName("JobUpdateInstructions")

    try __proto.writeFieldValue(__value.initialState, name: "initialState", type: .SET, id: 1)

    try __proto.writeFieldValue(__value.desiredState, name: "desiredState", type: .STRUCT, id: 2)

    try __proto.writeFieldValue(__value.settings, name: "settings", type: .STRUCT, id: 3)

    try __proto.writeFieldStop()

    try __proto.writeStructEnd()
  }

}



public func ==(lhs: JobUpdate, rhs: JobUpdate) -> Bool {
  return
    (lhs.summary ?== rhs.summary) &&
    (lhs.instructions ?== rhs.instructions)
}

extension JobUpdate : CustomStringConvertible {

  public var description : String {
    var desc = "JobUpdate("
    desc += "summary=\(self.summary), "
    desc += "instructions=\(self.instructions)"
    desc += ")"
    return desc
  }

}

extension JobUpdate : Hashable {

  public var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime * result + (summary.hashValue)
    result = prime * result + (instructions.hashValue)
    return result
  }

}

extension JobUpdate : TStruct {

  public static func readValueFromProtocol(__proto: TProtocol) throws -> JobUpdate {

    try __proto.readStructBegin()

    var summary : JobUpdateSummary!
    var instructions : JobUpdateInstructions!

    fields: while true {

      let (_, fieldType, fieldID) = try __proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .STOP):
          break fields

        case (1, .STRUCT):
          summary = try __proto.readValue() as JobUpdateSummary

        case (2, .STRUCT):
          instructions = try __proto.readValue() as JobUpdateInstructions

        case let (_, unknownType):
          try __proto.skipType(unknownType)
      }

      try __proto.readFieldEnd()
    }

    try __proto.readStructEnd()

    // Required fields
    try __proto.validateValue(summary, named: "summary")
    try __proto.validateValue(instructions, named: "instructions")

    return JobUpdate(summary: summary, instructions: instructions)
  }

  public static func writeValue(__value: JobUpdate, toProtocol __proto: TProtocol) throws {

    try __proto.writeStructBeginWithName("JobUpdate")

    try __proto.writeFieldValue(__value.summary, name: "summary", type: .STRUCT, id: 1)

    try __proto.writeFieldValue(__value.instructions, name: "instructions", type: .STRUCT, id: 2)

    try __proto.writeFieldStop()

    try __proto.writeStructEnd()
  }

}



public func ==(lhs: JobUpdateDetails, rhs: JobUpdateDetails) -> Bool {
  return
    (lhs.update ?== rhs.update) &&
    (lhs.updateEvents ?== rhs.updateEvents) &&
    (lhs.instanceEvents ?== rhs.instanceEvents)
}

extension JobUpdateDetails : CustomStringConvertible {

  public var description : String {
    var desc = "JobUpdateDetails("
    desc += "update=\(self.update), "
    desc += "updateEvents=\(self.updateEvents), "
    desc += "instanceEvents=\(self.instanceEvents)"
    desc += ")"
    return desc
  }

}

extension JobUpdateDetails : Hashable {

  public var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime * result + (update.hashValue)
    result = prime * result + (updateEvents.hashValue)
    result = prime * result + (instanceEvents.hashValue)
    return result
  }

}

extension JobUpdateDetails : TStruct {

  public static func readValueFromProtocol(__proto: TProtocol) throws -> JobUpdateDetails {

    try __proto.readStructBegin()

    var update : JobUpdate!
    var updateEvents : TList<JobUpdateEvent>!
    var instanceEvents : TList<JobInstanceUpdateEvent>!

    fields: while true {

      let (_, fieldType, fieldID) = try __proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .STOP):
          break fields

        case (1, .STRUCT):
          update = try __proto.readValue() as JobUpdate

        case (2, .LIST):
          updateEvents = try __proto.readValue() as TList<JobUpdateEvent>

        case (3, .LIST):
          instanceEvents = try __proto.readValue() as TList<JobInstanceUpdateEvent>

        case let (_, unknownType):
          try __proto.skipType(unknownType)
      }

      try __proto.readFieldEnd()
    }

    try __proto.readStructEnd()

    // Required fields
    try __proto.validateValue(update, named: "update")
    try __proto.validateValue(updateEvents, named: "updateEvents")
    try __proto.validateValue(instanceEvents, named: "instanceEvents")

    return JobUpdateDetails(update: update, updateEvents: updateEvents, instanceEvents: instanceEvents)
  }

  public static func writeValue(__value: JobUpdateDetails, toProtocol __proto: TProtocol) throws {

    try __proto.writeStructBeginWithName("JobUpdateDetails")

    try __proto.writeFieldValue(__value.update, name: "update", type: .STRUCT, id: 1)

    try __proto.writeFieldValue(__value.updateEvents, name: "updateEvents", type: .LIST, id: 2)

    try __proto.writeFieldValue(__value.instanceEvents, name: "instanceEvents", type: .LIST, id: 3)

    try __proto.writeFieldStop()

    try __proto.writeStructEnd()
  }

}



public func ==(lhs: JobUpdateRequest, rhs: JobUpdateRequest) -> Bool {
  return
    (lhs.taskConfig ?== rhs.taskConfig) &&
    (lhs.instanceCount ?== rhs.instanceCount) &&
    (lhs.settings ?== rhs.settings)
}

extension JobUpdateRequest : CustomStringConvertible {

  public var description : String {
    var desc = "JobUpdateRequest("
    desc += "taskConfig=\(self.taskConfig), "
    desc += "instanceCount=\(self.instanceCount), "
    desc += "settings=\(self.settings)"
    desc += ")"
    return desc
  }

}

extension JobUpdateRequest : Hashable {

  public var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime * result + (taskConfig.hashValue)
    result = prime * result + (instanceCount.hashValue)
    result = prime * result + (settings.hashValue)
    return result
  }

}

extension JobUpdateRequest : TStruct {

  public static func readValueFromProtocol(__proto: TProtocol) throws -> JobUpdateRequest {

    try __proto.readStructBegin()

    var taskConfig : TaskConfig!
    var instanceCount : Int32!
    var settings : JobUpdateSettings!

    fields: while true {

      let (_, fieldType, fieldID) = try __proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .STOP):
          break fields

        case (1, .STRUCT):
          taskConfig = try __proto.readValue() as TaskConfig

        case (2, .I32):
          instanceCount = try __proto.readValue() as Int32

        case (3, .STRUCT):
          settings = try __proto.readValue() as JobUpdateSettings

        case let (_, unknownType):
          try __proto.skipType(unknownType)
      }

      try __proto.readFieldEnd()
    }

    try __proto.readStructEnd()

    // Required fields
    try __proto.validateValue(taskConfig, named: "taskConfig")
    try __proto.validateValue(instanceCount, named: "instanceCount")
    try __proto.validateValue(settings, named: "settings")

    return JobUpdateRequest(taskConfig: taskConfig, instanceCount: instanceCount, settings: settings)
  }

  public static func writeValue(__value: JobUpdateRequest, toProtocol __proto: TProtocol) throws {

    try __proto.writeStructBeginWithName("JobUpdateRequest")

    try __proto.writeFieldValue(__value.taskConfig, name: "taskConfig", type: .STRUCT, id: 1)

    try __proto.writeFieldValue(__value.instanceCount, name: "instanceCount", type: .I32, id: 2)

    try __proto.writeFieldValue(__value.settings, name: "settings", type: .STRUCT, id: 3)

    try __proto.writeFieldStop()

    try __proto.writeStructEnd()
  }

}



public func ==(lhs: JobUpdateQuery, rhs: JobUpdateQuery) -> Bool {
  return
    (lhs.role ?== rhs.role) &&
    (lhs.key ?== rhs.key) &&
    (lhs.jobKey ?== rhs.jobKey) &&
    (lhs.user ?== rhs.user) &&
    (lhs.updateStatuses ?== rhs.updateStatuses) &&
    (lhs.offset ?== rhs.offset) &&
    (lhs.limit ?== rhs.limit)
}

extension JobUpdateQuery : CustomStringConvertible {

  public var description : String {
    var desc = "JobUpdateQuery("
    desc += "role=\(self.role), "
    desc += "key=\(self.key), "
    desc += "jobKey=\(self.jobKey), "
    desc += "user=\(self.user), "
    desc += "updateStatuses=\(self.updateStatuses), "
    desc += "offset=\(self.offset), "
    desc += "limit=\(self.limit)"
    desc += ")"
    return desc
  }

}

extension JobUpdateQuery : Hashable {

  public var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime * result + (role.hashValue)
    result = prime * result + (key.hashValue)
    result = prime * result + (jobKey.hashValue)
    result = prime * result + (user.hashValue)
    result = prime * result + (updateStatuses.hashValue)
    result = prime * result + (offset.hashValue)
    result = prime * result + (limit.hashValue)
    return result
  }

}

extension JobUpdateQuery : TStruct {

  public static func readValueFromProtocol(__proto: TProtocol) throws -> JobUpdateQuery {

    try __proto.readStructBegin()

    var role : String!
    var key : JobUpdateKey!
    var jobKey : JobKey!
    var user : String!
    var updateStatuses : TSet<JobUpdateStatus>!
    var offset : Int32!
    var limit : Int32!

    fields: while true {

      let (_, fieldType, fieldID) = try __proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .STOP):
          break fields

        case (2, .STRING):
          role = try __proto.readValue() as String

        case (8, .STRUCT):
          key = try __proto.readValue() as JobUpdateKey

        case (3, .STRUCT):
          jobKey = try __proto.readValue() as JobKey

        case (4, .STRING):
          user = try __proto.readValue() as String

        case (5, .SET):
          updateStatuses = try __proto.readValue() as TSet<JobUpdateStatus>

        case (6, .I32):
          offset = try __proto.readValue() as Int32

        case (7, .I32):
          limit = try __proto.readValue() as Int32

        case let (_, unknownType):
          try __proto.skipType(unknownType)
      }

      try __proto.readFieldEnd()
    }

    try __proto.readStructEnd()

    // Required fields
    try __proto.validateValue(role, named: "role")
    try __proto.validateValue(key, named: "key")
    try __proto.validateValue(jobKey, named: "jobKey")
    try __proto.validateValue(user, named: "user")
    try __proto.validateValue(updateStatuses, named: "updateStatuses")
    try __proto.validateValue(offset, named: "offset")
    try __proto.validateValue(limit, named: "limit")

    return JobUpdateQuery(role: role, key: key, jobKey: jobKey, user: user, updateStatuses: updateStatuses, offset: offset, limit: limit)
  }

  public static func writeValue(__value: JobUpdateQuery, toProtocol __proto: TProtocol) throws {

    try __proto.writeStructBeginWithName("JobUpdateQuery")

    try __proto.writeFieldValue(__value.role, name: "role", type: .STRING, id: 2)

    try __proto.writeFieldValue(__value.key, name: "key", type: .STRUCT, id: 8)

    try __proto.writeFieldValue(__value.jobKey, name: "jobKey", type: .STRUCT, id: 3)

    try __proto.writeFieldValue(__value.user, name: "user", type: .STRING, id: 4)

    try __proto.writeFieldValue(__value.updateStatuses, name: "updateStatuses", type: .SET, id: 5)

    try __proto.writeFieldValue(__value.offset, name: "offset", type: .I32, id: 6)

    try __proto.writeFieldValue(__value.limit, name: "limit", type: .I32, id: 7)

    try __proto.writeFieldStop()

    try __proto.writeStructEnd()
  }

}



public func ==(lhs: ListBackupsResult, rhs: ListBackupsResult) -> Bool {
  return
    (lhs.backups ?== rhs.backups)
}

extension ListBackupsResult : CustomStringConvertible {

  public var description : String {
    var desc = "ListBackupsResult("
    desc += "backups=\(self.backups)"
    desc += ")"
    return desc
  }

}

extension ListBackupsResult : Hashable {

  public var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime * result + (backups.hashValue)
    return result
  }

}

extension ListBackupsResult : TStruct {

  public static func readValueFromProtocol(__proto: TProtocol) throws -> ListBackupsResult {

    try __proto.readStructBegin()

    var backups : TSet<String>!

    fields: while true {

      let (_, fieldType, fieldID) = try __proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .STOP):
          break fields

        case (1, .SET):
          backups = try __proto.readValue() as TSet<String>

        case let (_, unknownType):
          try __proto.skipType(unknownType)
      }

      try __proto.readFieldEnd()
    }

    try __proto.readStructEnd()

    // Required fields
    try __proto.validateValue(backups, named: "backups")

    return ListBackupsResult(backups: backups)
  }

  public static func writeValue(__value: ListBackupsResult, toProtocol __proto: TProtocol) throws {

    try __proto.writeStructBeginWithName("ListBackupsResult")

    try __proto.writeFieldValue(__value.backups, name: "backups", type: .SET, id: 1)

    try __proto.writeFieldStop()

    try __proto.writeStructEnd()
  }

}



public func ==(lhs: StartMaintenanceResult, rhs: StartMaintenanceResult) -> Bool {
  return
    (lhs.statuses ?== rhs.statuses)
}

extension StartMaintenanceResult : CustomStringConvertible {

  public var description : String {
    var desc = "StartMaintenanceResult("
    desc += "statuses=\(self.statuses)"
    desc += ")"
    return desc
  }

}

extension StartMaintenanceResult : Hashable {

  public var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime * result + (statuses.hashValue)
    return result
  }

}

extension StartMaintenanceResult : TStruct {

  public static func readValueFromProtocol(__proto: TProtocol) throws -> StartMaintenanceResult {

    try __proto.readStructBegin()

    var statuses : TSet<HostStatus>!

    fields: while true {

      let (_, fieldType, fieldID) = try __proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .STOP):
          break fields

        case (1, .SET):
          statuses = try __proto.readValue() as TSet<HostStatus>

        case let (_, unknownType):
          try __proto.skipType(unknownType)
      }

      try __proto.readFieldEnd()
    }

    try __proto.readStructEnd()

    // Required fields
    try __proto.validateValue(statuses, named: "statuses")

    return StartMaintenanceResult(statuses: statuses)
  }

  public static func writeValue(__value: StartMaintenanceResult, toProtocol __proto: TProtocol) throws {

    try __proto.writeStructBeginWithName("StartMaintenanceResult")

    try __proto.writeFieldValue(__value.statuses, name: "statuses", type: .SET, id: 1)

    try __proto.writeFieldStop()

    try __proto.writeStructEnd()
  }

}



public func ==(lhs: DrainHostsResult, rhs: DrainHostsResult) -> Bool {
  return
    (lhs.statuses ?== rhs.statuses)
}

extension DrainHostsResult : CustomStringConvertible {

  public var description : String {
    var desc = "DrainHostsResult("
    desc += "statuses=\(self.statuses)"
    desc += ")"
    return desc
  }

}

extension DrainHostsResult : Hashable {

  public var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime * result + (statuses.hashValue)
    return result
  }

}

extension DrainHostsResult : TStruct {

  public static func readValueFromProtocol(__proto: TProtocol) throws -> DrainHostsResult {

    try __proto.readStructBegin()

    var statuses : TSet<HostStatus>!

    fields: while true {

      let (_, fieldType, fieldID) = try __proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .STOP):
          break fields

        case (1, .SET):
          statuses = try __proto.readValue() as TSet<HostStatus>

        case let (_, unknownType):
          try __proto.skipType(unknownType)
      }

      try __proto.readFieldEnd()
    }

    try __proto.readStructEnd()

    // Required fields
    try __proto.validateValue(statuses, named: "statuses")

    return DrainHostsResult(statuses: statuses)
  }

  public static func writeValue(__value: DrainHostsResult, toProtocol __proto: TProtocol) throws {

    try __proto.writeStructBeginWithName("DrainHostsResult")

    try __proto.writeFieldValue(__value.statuses, name: "statuses", type: .SET, id: 1)

    try __proto.writeFieldStop()

    try __proto.writeStructEnd()
  }

}



public func ==(lhs: QueryRecoveryResult, rhs: QueryRecoveryResult) -> Bool {
  return
    (lhs.tasks ?== rhs.tasks)
}

extension QueryRecoveryResult : CustomStringConvertible {

  public var description : String {
    var desc = "QueryRecoveryResult("
    desc += "tasks=\(self.tasks)"
    desc += ")"
    return desc
  }

}

extension QueryRecoveryResult : Hashable {

  public var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime * result + (tasks.hashValue)
    return result
  }

}

extension QueryRecoveryResult : TStruct {

  public static func readValueFromProtocol(__proto: TProtocol) throws -> QueryRecoveryResult {

    try __proto.readStructBegin()

    var tasks : TSet<ScheduledTask>!

    fields: while true {

      let (_, fieldType, fieldID) = try __proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .STOP):
          break fields

        case (1, .SET):
          tasks = try __proto.readValue() as TSet<ScheduledTask>

        case let (_, unknownType):
          try __proto.skipType(unknownType)
      }

      try __proto.readFieldEnd()
    }

    try __proto.readStructEnd()

    // Required fields
    try __proto.validateValue(tasks, named: "tasks")

    return QueryRecoveryResult(tasks: tasks)
  }

  public static func writeValue(__value: QueryRecoveryResult, toProtocol __proto: TProtocol) throws {

    try __proto.writeStructBeginWithName("QueryRecoveryResult")

    try __proto.writeFieldValue(__value.tasks, name: "tasks", type: .SET, id: 1)

    try __proto.writeFieldStop()

    try __proto.writeStructEnd()
  }

}



public func ==(lhs: MaintenanceStatusResult, rhs: MaintenanceStatusResult) -> Bool {
  return
    (lhs.statuses ?== rhs.statuses)
}

extension MaintenanceStatusResult : CustomStringConvertible {

  public var description : String {
    var desc = "MaintenanceStatusResult("
    desc += "statuses=\(self.statuses)"
    desc += ")"
    return desc
  }

}

extension MaintenanceStatusResult : Hashable {

  public var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime * result + (statuses.hashValue)
    return result
  }

}

extension MaintenanceStatusResult : TStruct {

  public static func readValueFromProtocol(__proto: TProtocol) throws -> MaintenanceStatusResult {

    try __proto.readStructBegin()

    var statuses : TSet<HostStatus>!

    fields: while true {

      let (_, fieldType, fieldID) = try __proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .STOP):
          break fields

        case (1, .SET):
          statuses = try __proto.readValue() as TSet<HostStatus>

        case let (_, unknownType):
          try __proto.skipType(unknownType)
      }

      try __proto.readFieldEnd()
    }

    try __proto.readStructEnd()

    // Required fields
    try __proto.validateValue(statuses, named: "statuses")

    return MaintenanceStatusResult(statuses: statuses)
  }

  public static func writeValue(__value: MaintenanceStatusResult, toProtocol __proto: TProtocol) throws {

    try __proto.writeStructBeginWithName("MaintenanceStatusResult")

    try __proto.writeFieldValue(__value.statuses, name: "statuses", type: .SET, id: 1)

    try __proto.writeFieldStop()

    try __proto.writeStructEnd()
  }

}



public func ==(lhs: EndMaintenanceResult, rhs: EndMaintenanceResult) -> Bool {
  return
    (lhs.statuses ?== rhs.statuses)
}

extension EndMaintenanceResult : CustomStringConvertible {

  public var description : String {
    var desc = "EndMaintenanceResult("
    desc += "statuses=\(self.statuses)"
    desc += ")"
    return desc
  }

}

extension EndMaintenanceResult : Hashable {

  public var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime * result + (statuses.hashValue)
    return result
  }

}

extension EndMaintenanceResult : TStruct {

  public static func readValueFromProtocol(__proto: TProtocol) throws -> EndMaintenanceResult {

    try __proto.readStructBegin()

    var statuses : TSet<HostStatus>!

    fields: while true {

      let (_, fieldType, fieldID) = try __proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .STOP):
          break fields

        case (1, .SET):
          statuses = try __proto.readValue() as TSet<HostStatus>

        case let (_, unknownType):
          try __proto.skipType(unknownType)
      }

      try __proto.readFieldEnd()
    }

    try __proto.readStructEnd()

    // Required fields
    try __proto.validateValue(statuses, named: "statuses")

    return EndMaintenanceResult(statuses: statuses)
  }

  public static func writeValue(__value: EndMaintenanceResult, toProtocol __proto: TProtocol) throws {

    try __proto.writeStructBeginWithName("EndMaintenanceResult")

    try __proto.writeFieldValue(__value.statuses, name: "statuses", type: .SET, id: 1)

    try __proto.writeFieldStop()

    try __proto.writeStructEnd()
  }

}



public func ==(lhs: RoleSummaryResult, rhs: RoleSummaryResult) -> Bool {
  return
    (lhs.summaries ?== rhs.summaries)
}

extension RoleSummaryResult : CustomStringConvertible {

  public var description : String {
    var desc = "RoleSummaryResult("
    desc += "summaries=\(self.summaries)"
    desc += ")"
    return desc
  }

}

extension RoleSummaryResult : Hashable {

  public var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime * result + (summaries.hashValue)
    return result
  }

}

extension RoleSummaryResult : TStruct {

  public static func readValueFromProtocol(__proto: TProtocol) throws -> RoleSummaryResult {

    try __proto.readStructBegin()

    var summaries : TSet<RoleSummary>!

    fields: while true {

      let (_, fieldType, fieldID) = try __proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .STOP):
          break fields

        case (1, .SET):
          summaries = try __proto.readValue() as TSet<RoleSummary>

        case let (_, unknownType):
          try __proto.skipType(unknownType)
      }

      try __proto.readFieldEnd()
    }

    try __proto.readStructEnd()

    // Required fields
    try __proto.validateValue(summaries, named: "summaries")

    return RoleSummaryResult(summaries: summaries)
  }

  public static func writeValue(__value: RoleSummaryResult, toProtocol __proto: TProtocol) throws {

    try __proto.writeStructBeginWithName("RoleSummaryResult")

    try __proto.writeFieldValue(__value.summaries, name: "summaries", type: .SET, id: 1)

    try __proto.writeFieldStop()

    try __proto.writeStructEnd()
  }

}



public func ==(lhs: JobSummaryResult, rhs: JobSummaryResult) -> Bool {
  return
    (lhs.summaries ?== rhs.summaries)
}

extension JobSummaryResult : CustomStringConvertible {

  public var description : String {
    var desc = "JobSummaryResult("
    desc += "summaries=\(self.summaries)"
    desc += ")"
    return desc
  }

}

extension JobSummaryResult : Hashable {

  public var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime * result + (summaries.hashValue)
    return result
  }

}

extension JobSummaryResult : TStruct {

  public static func readValueFromProtocol(__proto: TProtocol) throws -> JobSummaryResult {

    try __proto.readStructBegin()

    var summaries : TSet<JobSummary>!

    fields: while true {

      let (_, fieldType, fieldID) = try __proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .STOP):
          break fields

        case (1, .SET):
          summaries = try __proto.readValue() as TSet<JobSummary>

        case let (_, unknownType):
          try __proto.skipType(unknownType)
      }

      try __proto.readFieldEnd()
    }

    try __proto.readStructEnd()

    // Required fields
    try __proto.validateValue(summaries, named: "summaries")

    return JobSummaryResult(summaries: summaries)
  }

  public static func writeValue(__value: JobSummaryResult, toProtocol __proto: TProtocol) throws {

    try __proto.writeStructBeginWithName("JobSummaryResult")

    try __proto.writeFieldValue(__value.summaries, name: "summaries", type: .SET, id: 1)

    try __proto.writeFieldStop()

    try __proto.writeStructEnd()
  }

}



public func ==(lhs: GetLocksResult, rhs: GetLocksResult) -> Bool {
  return
    (lhs.locks ?== rhs.locks)
}

extension GetLocksResult : CustomStringConvertible {

  public var description : String {
    var desc = "GetLocksResult("
    desc += "locks=\(self.locks)"
    desc += ")"
    return desc
  }

}

extension GetLocksResult : Hashable {

  public var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime * result + (locks.hashValue)
    return result
  }

}

extension GetLocksResult : TStruct {

  public static func readValueFromProtocol(__proto: TProtocol) throws -> GetLocksResult {

    try __proto.readStructBegin()

    var locks : TSet<Lock>!

    fields: while true {

      let (_, fieldType, fieldID) = try __proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .STOP):
          break fields

        case (1, .SET):
          locks = try __proto.readValue() as TSet<Lock>

        case let (_, unknownType):
          try __proto.skipType(unknownType)
      }

      try __proto.readFieldEnd()
    }

    try __proto.readStructEnd()

    // Required fields
    try __proto.validateValue(locks, named: "locks")

    return GetLocksResult(locks: locks)
  }

  public static func writeValue(__value: GetLocksResult, toProtocol __proto: TProtocol) throws {

    try __proto.writeStructBeginWithName("GetLocksResult")

    try __proto.writeFieldValue(__value.locks, name: "locks", type: .SET, id: 1)

    try __proto.writeFieldStop()

    try __proto.writeStructEnd()
  }

}



public func ==(lhs: ConfigSummaryResult, rhs: ConfigSummaryResult) -> Bool {
  return
    (lhs.summary ?== rhs.summary)
}

extension ConfigSummaryResult : CustomStringConvertible {

  public var description : String {
    var desc = "ConfigSummaryResult("
    desc += "summary=\(self.summary)"
    desc += ")"
    return desc
  }

}

extension ConfigSummaryResult : Hashable {

  public var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime * result + (summary.hashValue)
    return result
  }

}

extension ConfigSummaryResult : TStruct {

  public static func readValueFromProtocol(__proto: TProtocol) throws -> ConfigSummaryResult {

    try __proto.readStructBegin()

    var summary : ConfigSummary!

    fields: while true {

      let (_, fieldType, fieldID) = try __proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .STOP):
          break fields

        case (1, .STRUCT):
          summary = try __proto.readValue() as ConfigSummary

        case let (_, unknownType):
          try __proto.skipType(unknownType)
      }

      try __proto.readFieldEnd()
    }

    try __proto.readStructEnd()

    // Required fields
    try __proto.validateValue(summary, named: "summary")

    return ConfigSummaryResult(summary: summary)
  }

  public static func writeValue(__value: ConfigSummaryResult, toProtocol __proto: TProtocol) throws {

    try __proto.writeStructBeginWithName("ConfigSummaryResult")

    try __proto.writeFieldValue(__value.summary, name: "summary", type: .STRUCT, id: 1)

    try __proto.writeFieldStop()

    try __proto.writeStructEnd()
  }

}



public func ==(lhs: GetPendingReasonResult, rhs: GetPendingReasonResult) -> Bool {
  return
    (lhs.reasons ?== rhs.reasons)
}

extension GetPendingReasonResult : CustomStringConvertible {

  public var description : String {
    var desc = "GetPendingReasonResult("
    desc += "reasons=\(self.reasons)"
    desc += ")"
    return desc
  }

}

extension GetPendingReasonResult : Hashable {

  public var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime * result + (reasons.hashValue)
    return result
  }

}

extension GetPendingReasonResult : TStruct {

  public static func readValueFromProtocol(__proto: TProtocol) throws -> GetPendingReasonResult {

    try __proto.readStructBegin()

    var reasons : TSet<PendingReason>!

    fields: while true {

      let (_, fieldType, fieldID) = try __proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .STOP):
          break fields

        case (1, .SET):
          reasons = try __proto.readValue() as TSet<PendingReason>

        case let (_, unknownType):
          try __proto.skipType(unknownType)
      }

      try __proto.readFieldEnd()
    }

    try __proto.readStructEnd()

    // Required fields
    try __proto.validateValue(reasons, named: "reasons")

    return GetPendingReasonResult(reasons: reasons)
  }

  public static func writeValue(__value: GetPendingReasonResult, toProtocol __proto: TProtocol) throws {

    try __proto.writeStructBeginWithName("GetPendingReasonResult")

    try __proto.writeFieldValue(__value.reasons, name: "reasons", type: .SET, id: 1)

    try __proto.writeFieldStop()

    try __proto.writeStructEnd()
  }

}



public func ==(lhs: StartJobUpdateResult, rhs: StartJobUpdateResult) -> Bool {
  return
    (lhs.key ?== rhs.key)
}

extension StartJobUpdateResult : CustomStringConvertible {

  public var description : String {
    var desc = "StartJobUpdateResult("
    desc += "key=\(self.key)"
    desc += ")"
    return desc
  }

}

extension StartJobUpdateResult : Hashable {

  public var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime * result + (key.hashValue)
    return result
  }

}

extension StartJobUpdateResult : TStruct {

  public static func readValueFromProtocol(__proto: TProtocol) throws -> StartJobUpdateResult {

    try __proto.readStructBegin()

    var key : JobUpdateKey!

    fields: while true {

      let (_, fieldType, fieldID) = try __proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .STOP):
          break fields

        case (1, .STRUCT):
          key = try __proto.readValue() as JobUpdateKey

        case let (_, unknownType):
          try __proto.skipType(unknownType)
      }

      try __proto.readFieldEnd()
    }

    try __proto.readStructEnd()

    // Required fields
    try __proto.validateValue(key, named: "key")

    return StartJobUpdateResult(key: key)
  }

  public static func writeValue(__value: StartJobUpdateResult, toProtocol __proto: TProtocol) throws {

    try __proto.writeStructBeginWithName("StartJobUpdateResult")

    try __proto.writeFieldValue(__value.key, name: "key", type: .STRUCT, id: 1)

    try __proto.writeFieldStop()

    try __proto.writeStructEnd()
  }

}



public func ==(lhs: GetJobUpdateSummariesResult, rhs: GetJobUpdateSummariesResult) -> Bool {
  return
    (lhs.updateSummaries ?== rhs.updateSummaries)
}

extension GetJobUpdateSummariesResult : CustomStringConvertible {

  public var description : String {
    var desc = "GetJobUpdateSummariesResult("
    desc += "updateSummaries=\(self.updateSummaries)"
    desc += ")"
    return desc
  }

}

extension GetJobUpdateSummariesResult : Hashable {

  public var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime * result + (updateSummaries.hashValue)
    return result
  }

}

extension GetJobUpdateSummariesResult : TStruct {

  public static func readValueFromProtocol(__proto: TProtocol) throws -> GetJobUpdateSummariesResult {

    try __proto.readStructBegin()

    var updateSummaries : TList<JobUpdateSummary>!

    fields: while true {

      let (_, fieldType, fieldID) = try __proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .STOP):
          break fields

        case (1, .LIST):
          updateSummaries = try __proto.readValue() as TList<JobUpdateSummary>

        case let (_, unknownType):
          try __proto.skipType(unknownType)
      }

      try __proto.readFieldEnd()
    }

    try __proto.readStructEnd()

    // Required fields
    try __proto.validateValue(updateSummaries, named: "updateSummaries")

    return GetJobUpdateSummariesResult(updateSummaries: updateSummaries)
  }

  public static func writeValue(__value: GetJobUpdateSummariesResult, toProtocol __proto: TProtocol) throws {

    try __proto.writeStructBeginWithName("GetJobUpdateSummariesResult")

    try __proto.writeFieldValue(__value.updateSummaries, name: "updateSummaries", type: .LIST, id: 1)

    try __proto.writeFieldStop()

    try __proto.writeStructEnd()
  }

}



public func ==(lhs: GetJobUpdateDetailsResult, rhs: GetJobUpdateDetailsResult) -> Bool {
  return
    (lhs.details ?== rhs.details)
}

extension GetJobUpdateDetailsResult : CustomStringConvertible {

  public var description : String {
    var desc = "GetJobUpdateDetailsResult("
    desc += "details=\(self.details)"
    desc += ")"
    return desc
  }

}

extension GetJobUpdateDetailsResult : Hashable {

  public var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime * result + (details.hashValue)
    return result
  }

}

extension GetJobUpdateDetailsResult : TStruct {

  public static func readValueFromProtocol(__proto: TProtocol) throws -> GetJobUpdateDetailsResult {

    try __proto.readStructBegin()

    var details : JobUpdateDetails!

    fields: while true {

      let (_, fieldType, fieldID) = try __proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .STOP):
          break fields

        case (1, .STRUCT):
          details = try __proto.readValue() as JobUpdateDetails

        case let (_, unknownType):
          try __proto.skipType(unknownType)
      }

      try __proto.readFieldEnd()
    }

    try __proto.readStructEnd()

    // Required fields
    try __proto.validateValue(details, named: "details")

    return GetJobUpdateDetailsResult(details: details)
  }

  public static func writeValue(__value: GetJobUpdateDetailsResult, toProtocol __proto: TProtocol) throws {

    try __proto.writeStructBeginWithName("GetJobUpdateDetailsResult")

    try __proto.writeFieldValue(__value.details, name: "details", type: .STRUCT, id: 1)

    try __proto.writeFieldStop()

    try __proto.writeStructEnd()
  }

}



public func ==(lhs: PulseJobUpdateResult, rhs: PulseJobUpdateResult) -> Bool {
  return
    (lhs.status ?== rhs.status)
}

extension PulseJobUpdateResult : CustomStringConvertible {

  public var description : String {
    var desc = "PulseJobUpdateResult("
    desc += "status=\(self.status)"
    desc += ")"
    return desc
  }

}

extension PulseJobUpdateResult : Hashable {

  public var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime * result + (status.hashValue)
    return result
  }

}

extension PulseJobUpdateResult : TStruct {

  public static func readValueFromProtocol(__proto: TProtocol) throws -> PulseJobUpdateResult {

    try __proto.readStructBegin()

    var status : JobUpdatePulseStatus!

    fields: while true {

      let (_, fieldType, fieldID) = try __proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .STOP):
          break fields

        case (1, .I32):
          status = try __proto.readValue() as JobUpdatePulseStatus

        case let (_, unknownType):
          try __proto.skipType(unknownType)
      }

      try __proto.readFieldEnd()
    }

    try __proto.readStructEnd()

    // Required fields
    try __proto.validateValue(status, named: "status")

    return PulseJobUpdateResult(status: status)
  }

  public static func writeValue(__value: PulseJobUpdateResult, toProtocol __proto: TProtocol) throws {

    try __proto.writeStructBeginWithName("PulseJobUpdateResult")

    try __proto.writeFieldValue(__value.status, name: "status", type: .I32, id: 1)

    try __proto.writeFieldStop()

    try __proto.writeStructEnd()
  }

}



public func ==(lhs: ServerInfo, rhs: ServerInfo) -> Bool {
  return
    (lhs.clusterName ?== rhs.clusterName) &&
    (lhs.thriftAPIVersion ?== rhs.thriftAPIVersion) &&
    (lhs.statsUrlPrefix ?== rhs.statsUrlPrefix)
}

extension ServerInfo : CustomStringConvertible {

  public var description : String {
    var desc = "ServerInfo("
    desc += "clusterName=\(self.clusterName), "
    desc += "thriftAPIVersion=\(self.thriftAPIVersion), "
    desc += "statsUrlPrefix=\(self.statsUrlPrefix)"
    desc += ")"
    return desc
  }

}

extension ServerInfo : Hashable {

  public var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime * result + (clusterName.hashValue)
    result = prime * result + (thriftAPIVersion.hashValue)
    result = prime * result + (statsUrlPrefix.hashValue)
    return result
  }

}

extension ServerInfo : TStruct {

  public static func readValueFromProtocol(__proto: TProtocol) throws -> ServerInfo {

    try __proto.readStructBegin()

    var clusterName : String!
    var thriftAPIVersion : Int32!
    var statsUrlPrefix : String!

    fields: while true {

      let (_, fieldType, fieldID) = try __proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .STOP):
          break fields

        case (1, .STRING):
          clusterName = try __proto.readValue() as String

        case (2, .I32):
          thriftAPIVersion = try __proto.readValue() as Int32

        case (3, .STRING):
          statsUrlPrefix = try __proto.readValue() as String

        case let (_, unknownType):
          try __proto.skipType(unknownType)
      }

      try __proto.readFieldEnd()
    }

    try __proto.readStructEnd()

    // Required fields
    try __proto.validateValue(clusterName, named: "clusterName")
    try __proto.validateValue(thriftAPIVersion, named: "thriftAPIVersion")
    try __proto.validateValue(statsUrlPrefix, named: "statsUrlPrefix")

    return ServerInfo(clusterName: clusterName, thriftAPIVersion: thriftAPIVersion, statsUrlPrefix: statsUrlPrefix)
  }

  public static func writeValue(__value: ServerInfo, toProtocol __proto: TProtocol) throws {

    try __proto.writeStructBeginWithName("ServerInfo")

    try __proto.writeFieldValue(__value.clusterName, name: "clusterName", type: .STRING, id: 1)

    try __proto.writeFieldValue(__value.thriftAPIVersion, name: "thriftAPIVersion", type: .I32, id: 2)

    try __proto.writeFieldValue(__value.statsUrlPrefix, name: "statsUrlPrefix", type: .STRING, id: 3)

    try __proto.writeFieldStop()

    try __proto.writeStructEnd()
  }

}



public func ==(lhs: Result, rhs: Result) -> Bool {
  return
    (lhs.populateJobResult ?== rhs.populateJobResult) &&
    (lhs.scheduleStatusResult ?== rhs.scheduleStatusResult) &&
    (lhs.getJobsResult ?== rhs.getJobsResult) &&
    (lhs.getQuotaResult ?== rhs.getQuotaResult) &&
    (lhs.listBackupsResult ?== rhs.listBackupsResult) &&
    (lhs.startMaintenanceResult ?== rhs.startMaintenanceResult) &&
    (lhs.drainHostsResult ?== rhs.drainHostsResult) &&
    (lhs.queryRecoveryResult ?== rhs.queryRecoveryResult) &&
    (lhs.maintenanceStatusResult ?== rhs.maintenanceStatusResult) &&
    (lhs.endMaintenanceResult ?== rhs.endMaintenanceResult) &&
    (lhs.getVersionResult ?== rhs.getVersionResult) &&
    (lhs.acquireLockResult ?== rhs.acquireLockResult) &&
    (lhs.roleSummaryResult ?== rhs.roleSummaryResult) &&
    (lhs.jobSummaryResult ?== rhs.jobSummaryResult) &&
    (lhs.getLocksResult ?== rhs.getLocksResult) &&
    (lhs.configSummaryResult ?== rhs.configSummaryResult) &&
    (lhs.getPendingReasonResult ?== rhs.getPendingReasonResult) &&
    (lhs.startJobUpdateResult ?== rhs.startJobUpdateResult) &&
    (lhs.getJobUpdateSummariesResult ?== rhs.getJobUpdateSummariesResult) &&
    (lhs.getJobUpdateDetailsResult ?== rhs.getJobUpdateDetailsResult) &&
    (lhs.pulseJobUpdateResult ?== rhs.pulseJobUpdateResult)
}

extension Result : CustomStringConvertible {

  public var description : String {
    var desc = "Result("
    desc += "populateJobResult=\(self.populateJobResult), "
    desc += "scheduleStatusResult=\(self.scheduleStatusResult), "
    desc += "getJobsResult=\(self.getJobsResult), "
    desc += "getQuotaResult=\(self.getQuotaResult), "
    desc += "listBackupsResult=\(self.listBackupsResult), "
    desc += "startMaintenanceResult=\(self.startMaintenanceResult), "
    desc += "drainHostsResult=\(self.drainHostsResult), "
    desc += "queryRecoveryResult=\(self.queryRecoveryResult), "
    desc += "maintenanceStatusResult=\(self.maintenanceStatusResult), "
    desc += "endMaintenanceResult=\(self.endMaintenanceResult), "
    desc += "getVersionResult=\(self.getVersionResult), "
    desc += "acquireLockResult=\(self.acquireLockResult), "
    desc += "roleSummaryResult=\(self.roleSummaryResult), "
    desc += "jobSummaryResult=\(self.jobSummaryResult), "
    desc += "getLocksResult=\(self.getLocksResult), "
    desc += "configSummaryResult=\(self.configSummaryResult), "
    desc += "getPendingReasonResult=\(self.getPendingReasonResult), "
    desc += "startJobUpdateResult=\(self.startJobUpdateResult), "
    desc += "getJobUpdateSummariesResult=\(self.getJobUpdateSummariesResult), "
    desc += "getJobUpdateDetailsResult=\(self.getJobUpdateDetailsResult), "
    desc += "pulseJobUpdateResult=\(self.pulseJobUpdateResult)"
    desc += ")"
    return desc
  }

}

extension Result : Hashable {

  public var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime * result + (populateJobResult.hashValue)
    result = prime * result + (scheduleStatusResult.hashValue)
    result = prime * result + (getJobsResult.hashValue)
    result = prime * result + (getQuotaResult.hashValue)
    result = prime * result + (listBackupsResult.hashValue)
    result = prime * result + (startMaintenanceResult.hashValue)
    result = prime * result + (drainHostsResult.hashValue)
    result = prime * result + (queryRecoveryResult.hashValue)
    result = prime * result + (maintenanceStatusResult.hashValue)
    result = prime * result + (endMaintenanceResult.hashValue)
    result = prime * result + (getVersionResult.hashValue)
    result = prime * result + (acquireLockResult.hashValue)
    result = prime * result + (roleSummaryResult.hashValue)
    result = prime * result + (jobSummaryResult.hashValue)
    result = prime * result + (getLocksResult.hashValue)
    result = prime * result + (configSummaryResult.hashValue)
    result = prime * result + (getPendingReasonResult.hashValue)
    result = prime * result + (startJobUpdateResult.hashValue)
    result = prime * result + (getJobUpdateSummariesResult.hashValue)
    result = prime * result + (getJobUpdateDetailsResult.hashValue)
    result = prime * result + (pulseJobUpdateResult.hashValue)
    return result
  }

}

extension Result : TStruct {

  public static func readValueFromProtocol(__proto: TProtocol) throws -> Result {

    try __proto.readStructBegin()

    var populateJobResult : PopulateJobResult!
    var scheduleStatusResult : ScheduleStatusResult!
    var getJobsResult : GetJobsResult!
    var getQuotaResult : GetQuotaResult!
    var listBackupsResult : ListBackupsResult!
    var startMaintenanceResult : StartMaintenanceResult!
    var drainHostsResult : DrainHostsResult!
    var queryRecoveryResult : QueryRecoveryResult!
    var maintenanceStatusResult : MaintenanceStatusResult!
    var endMaintenanceResult : EndMaintenanceResult!
    var getVersionResult : APIVersion!
    var acquireLockResult : AcquireLockResult!
    var roleSummaryResult : RoleSummaryResult!
    var jobSummaryResult : JobSummaryResult!
    var getLocksResult : GetLocksResult!
    var configSummaryResult : ConfigSummaryResult!
    var getPendingReasonResult : GetPendingReasonResult!
    var startJobUpdateResult : StartJobUpdateResult!
    var getJobUpdateSummariesResult : GetJobUpdateSummariesResult!
    var getJobUpdateDetailsResult : GetJobUpdateDetailsResult!
    var pulseJobUpdateResult : PulseJobUpdateResult!

    fields: while true {

      let (_, fieldType, fieldID) = try __proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .STOP):
          break fields

        case (1, .STRUCT):
          populateJobResult = try __proto.readValue() as PopulateJobResult

        case (3, .STRUCT):
          scheduleStatusResult = try __proto.readValue() as ScheduleStatusResult

        case (4, .STRUCT):
          getJobsResult = try __proto.readValue() as GetJobsResult

        case (5, .STRUCT):
          getQuotaResult = try __proto.readValue() as GetQuotaResult

        case (6, .STRUCT):
          listBackupsResult = try __proto.readValue() as ListBackupsResult

        case (7, .STRUCT):
          startMaintenanceResult = try __proto.readValue() as StartMaintenanceResult

        case (8, .STRUCT):
          drainHostsResult = try __proto.readValue() as DrainHostsResult

        case (9, .STRUCT):
          queryRecoveryResult = try __proto.readValue() as QueryRecoveryResult

        case (10, .STRUCT):
          maintenanceStatusResult = try __proto.readValue() as MaintenanceStatusResult

        case (11, .STRUCT):
          endMaintenanceResult = try __proto.readValue() as EndMaintenanceResult

        case (15, .STRUCT):
          getVersionResult = try __proto.readValue() as APIVersion

        case (16, .STRUCT):
          acquireLockResult = try __proto.readValue() as AcquireLockResult

        case (17, .STRUCT):
          roleSummaryResult = try __proto.readValue() as RoleSummaryResult

        case (18, .STRUCT):
          jobSummaryResult = try __proto.readValue() as JobSummaryResult

        case (19, .STRUCT):
          getLocksResult = try __proto.readValue() as GetLocksResult

        case (20, .STRUCT):
          configSummaryResult = try __proto.readValue() as ConfigSummaryResult

        case (21, .STRUCT):
          getPendingReasonResult = try __proto.readValue() as GetPendingReasonResult

        case (22, .STRUCT):
          startJobUpdateResult = try __proto.readValue() as StartJobUpdateResult

        case (23, .STRUCT):
          getJobUpdateSummariesResult = try __proto.readValue() as GetJobUpdateSummariesResult

        case (24, .STRUCT):
          getJobUpdateDetailsResult = try __proto.readValue() as GetJobUpdateDetailsResult

        case (25, .STRUCT):
          pulseJobUpdateResult = try __proto.readValue() as PulseJobUpdateResult

        case let (_, unknownType):
          try __proto.skipType(unknownType)
      }

      try __proto.readFieldEnd()
    }

    try __proto.readStructEnd()

    // Required fields
    try __proto.validateValue(populateJobResult, named: "populateJobResult")
    try __proto.validateValue(scheduleStatusResult, named: "scheduleStatusResult")
    try __proto.validateValue(getJobsResult, named: "getJobsResult")
    try __proto.validateValue(getQuotaResult, named: "getQuotaResult")
    try __proto.validateValue(listBackupsResult, named: "listBackupsResult")
    try __proto.validateValue(startMaintenanceResult, named: "startMaintenanceResult")
    try __proto.validateValue(drainHostsResult, named: "drainHostsResult")
    try __proto.validateValue(queryRecoveryResult, named: "queryRecoveryResult")
    try __proto.validateValue(maintenanceStatusResult, named: "maintenanceStatusResult")
    try __proto.validateValue(endMaintenanceResult, named: "endMaintenanceResult")
    try __proto.validateValue(getVersionResult, named: "getVersionResult")
    try __proto.validateValue(acquireLockResult, named: "acquireLockResult")
    try __proto.validateValue(roleSummaryResult, named: "roleSummaryResult")
    try __proto.validateValue(jobSummaryResult, named: "jobSummaryResult")
    try __proto.validateValue(getLocksResult, named: "getLocksResult")
    try __proto.validateValue(configSummaryResult, named: "configSummaryResult")
    try __proto.validateValue(getPendingReasonResult, named: "getPendingReasonResult")
    try __proto.validateValue(startJobUpdateResult, named: "startJobUpdateResult")
    try __proto.validateValue(getJobUpdateSummariesResult, named: "getJobUpdateSummariesResult")
    try __proto.validateValue(getJobUpdateDetailsResult, named: "getJobUpdateDetailsResult")
    try __proto.validateValue(pulseJobUpdateResult, named: "pulseJobUpdateResult")

    return Result(populateJobResult: populateJobResult, scheduleStatusResult: scheduleStatusResult, getJobsResult: getJobsResult, getQuotaResult: getQuotaResult, listBackupsResult: listBackupsResult, startMaintenanceResult: startMaintenanceResult, drainHostsResult: drainHostsResult, queryRecoveryResult: queryRecoveryResult, maintenanceStatusResult: maintenanceStatusResult, endMaintenanceResult: endMaintenanceResult, getVersionResult: getVersionResult, acquireLockResult: acquireLockResult, roleSummaryResult: roleSummaryResult, jobSummaryResult: jobSummaryResult, getLocksResult: getLocksResult, configSummaryResult: configSummaryResult, getPendingReasonResult: getPendingReasonResult, startJobUpdateResult: startJobUpdateResult, getJobUpdateSummariesResult: getJobUpdateSummariesResult, getJobUpdateDetailsResult: getJobUpdateDetailsResult, pulseJobUpdateResult: pulseJobUpdateResult)
  }

  public static func writeValue(__value: Result, toProtocol __proto: TProtocol) throws {

    try __proto.writeStructBeginWithName("Result")

    try __proto.writeFieldValue(__value.populateJobResult, name: "populateJobResult", type: .STRUCT, id: 1)

    try __proto.writeFieldValue(__value.scheduleStatusResult, name: "scheduleStatusResult", type: .STRUCT, id: 3)

    try __proto.writeFieldValue(__value.getJobsResult, name: "getJobsResult", type: .STRUCT, id: 4)

    try __proto.writeFieldValue(__value.getQuotaResult, name: "getQuotaResult", type: .STRUCT, id: 5)

    try __proto.writeFieldValue(__value.listBackupsResult, name: "listBackupsResult", type: .STRUCT, id: 6)

    try __proto.writeFieldValue(__value.startMaintenanceResult, name: "startMaintenanceResult", type: .STRUCT, id: 7)

    try __proto.writeFieldValue(__value.drainHostsResult, name: "drainHostsResult", type: .STRUCT, id: 8)

    try __proto.writeFieldValue(__value.queryRecoveryResult, name: "queryRecoveryResult", type: .STRUCT, id: 9)

    try __proto.writeFieldValue(__value.maintenanceStatusResult, name: "maintenanceStatusResult", type: .STRUCT, id: 10)

    try __proto.writeFieldValue(__value.endMaintenanceResult, name: "endMaintenanceResult", type: .STRUCT, id: 11)

    try __proto.writeFieldValue(__value.getVersionResult, name: "getVersionResult", type: .STRUCT, id: 15)

    try __proto.writeFieldValue(__value.acquireLockResult, name: "acquireLockResult", type: .STRUCT, id: 16)

    try __proto.writeFieldValue(__value.roleSummaryResult, name: "roleSummaryResult", type: .STRUCT, id: 17)

    try __proto.writeFieldValue(__value.jobSummaryResult, name: "jobSummaryResult", type: .STRUCT, id: 18)

    try __proto.writeFieldValue(__value.getLocksResult, name: "getLocksResult", type: .STRUCT, id: 19)

    try __proto.writeFieldValue(__value.configSummaryResult, name: "configSummaryResult", type: .STRUCT, id: 20)

    try __proto.writeFieldValue(__value.getPendingReasonResult, name: "getPendingReasonResult", type: .STRUCT, id: 21)

    try __proto.writeFieldValue(__value.startJobUpdateResult, name: "startJobUpdateResult", type: .STRUCT, id: 22)

    try __proto.writeFieldValue(__value.getJobUpdateSummariesResult, name: "getJobUpdateSummariesResult", type: .STRUCT, id: 23)

    try __proto.writeFieldValue(__value.getJobUpdateDetailsResult, name: "getJobUpdateDetailsResult", type: .STRUCT, id: 24)

    try __proto.writeFieldValue(__value.pulseJobUpdateResult, name: "pulseJobUpdateResult", type: .STRUCT, id: 25)

    try __proto.writeFieldStop()

    try __proto.writeStructEnd()
  }

}



public func ==(lhs: ResponseDetail, rhs: ResponseDetail) -> Bool {
  return
    (lhs.message ?== rhs.message)
}

extension ResponseDetail : CustomStringConvertible {

  public var description : String {
    var desc = "ResponseDetail("
    desc += "message=\(self.message)"
    desc += ")"
    return desc
  }

}

extension ResponseDetail : Hashable {

  public var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime * result + (message.hashValue)
    return result
  }

}

extension ResponseDetail : TStruct {

  public static func readValueFromProtocol(__proto: TProtocol) throws -> ResponseDetail {

    try __proto.readStructBegin()

    var message : String!

    fields: while true {

      let (_, fieldType, fieldID) = try __proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .STOP):
          break fields

        case (1, .STRING):
          message = try __proto.readValue() as String

        case let (_, unknownType):
          try __proto.skipType(unknownType)
      }

      try __proto.readFieldEnd()
    }

    try __proto.readStructEnd()

    // Required fields
    try __proto.validateValue(message, named: "message")

    return ResponseDetail(message: message)
  }

  public static func writeValue(__value: ResponseDetail, toProtocol __proto: TProtocol) throws {

    try __proto.writeStructBeginWithName("ResponseDetail")

    try __proto.writeFieldValue(__value.message, name: "message", type: .STRING, id: 1)

    try __proto.writeFieldStop()

    try __proto.writeStructEnd()
  }

}



public func ==(lhs: Response, rhs: Response) -> Bool {
  return
    (lhs.responseCode ?== rhs.responseCode) &&
    (lhs.serverInfo ?== rhs.serverInfo) &&
    (lhs.result ?== rhs.result) &&
    (lhs.details ?== rhs.details)
}

extension Response : CustomStringConvertible {

  public var description : String {
    var desc = "Response("
    desc += "responseCode=\(self.responseCode), "
    desc += "serverInfo=\(self.serverInfo), "
    desc += "result=\(self.result), "
    desc += "details=\(self.details)"
    desc += ")"
    return desc
  }

}

extension Response : Hashable {

  public var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime * result + (responseCode.hashValue)
    result = prime * result + (serverInfo.hashValue)
    result = prime * result + (result?.hashValue ?? 0)
    result = prime * result + (details.hashValue)
    return result
  }

}

extension Response : TStruct {

  public static func readValueFromProtocol(__proto: TProtocol) throws -> Response {

    try __proto.readStructBegin()

    var responseCode : ResponseCode!
    var serverInfo : ServerInfo!
    var result : Result?
    var details : TList<ResponseDetail>!

    fields: while true {

      let (_, fieldType, fieldID) = try __proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .STOP):
          break fields

        case (1, .I32):
          responseCode = try __proto.readValue() as ResponseCode

        case (5, .STRUCT):
          serverInfo = try __proto.readValue() as ServerInfo

        case (3, .STRUCT):
          result = try __proto.readValue() as Result

        case (6, .LIST):
          details = try __proto.readValue() as TList<ResponseDetail>

        case let (_, unknownType):
          try __proto.skipType(unknownType)
      }

      try __proto.readFieldEnd()
    }

    try __proto.readStructEnd()

    // Required fields
    try __proto.validateValue(responseCode, named: "responseCode")
    try __proto.validateValue(serverInfo, named: "serverInfo")
    try __proto.validateValue(details, named: "details")

    return Response(responseCode: responseCode, serverInfo: serverInfo, result: result, details: details)
  }

  public static func writeValue(__value: Response, toProtocol __proto: TProtocol) throws {

    try __proto.writeStructBeginWithName("Response")

    try __proto.writeFieldValue(__value.responseCode, name: "responseCode", type: .I32, id: 1)

    try __proto.writeFieldValue(__value.serverInfo, name: "serverInfo", type: .STRUCT, id: 5)

    if let result = __value.result {
      try __proto.writeFieldValue(result, name: "result", type: .STRUCT, id: 3)
    }

    try __proto.writeFieldValue(__value.details, name: "details", type: .LIST, id: 6)

    try __proto.writeFieldStop()

    try __proto.writeStructEnd()
  }

}



public func ==(lhs: InstanceConfigRewrite, rhs: InstanceConfigRewrite) -> Bool {
  return
    (lhs.instanceKey ?== rhs.instanceKey) &&
    (lhs.oldTask ?== rhs.oldTask) &&
    (lhs.rewrittenTask ?== rhs.rewrittenTask)
}

extension InstanceConfigRewrite : CustomStringConvertible {

  public var description : String {
    var desc = "InstanceConfigRewrite("
    desc += "instanceKey=\(self.instanceKey), "
    desc += "oldTask=\(self.oldTask), "
    desc += "rewrittenTask=\(self.rewrittenTask)"
    desc += ")"
    return desc
  }

}

extension InstanceConfigRewrite : Hashable {

  public var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime * result + (instanceKey.hashValue)
    result = prime * result + (oldTask.hashValue)
    result = prime * result + (rewrittenTask.hashValue)
    return result
  }

}

extension InstanceConfigRewrite : TStruct {

  public static func readValueFromProtocol(__proto: TProtocol) throws -> InstanceConfigRewrite {

    try __proto.readStructBegin()

    var instanceKey : InstanceKey!
    var oldTask : TaskConfig!
    var rewrittenTask : TaskConfig!

    fields: while true {

      let (_, fieldType, fieldID) = try __proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .STOP):
          break fields

        case (1, .STRUCT):
          instanceKey = try __proto.readValue() as InstanceKey

        case (2, .STRUCT):
          oldTask = try __proto.readValue() as TaskConfig

        case (3, .STRUCT):
          rewrittenTask = try __proto.readValue() as TaskConfig

        case let (_, unknownType):
          try __proto.skipType(unknownType)
      }

      try __proto.readFieldEnd()
    }

    try __proto.readStructEnd()

    // Required fields
    try __proto.validateValue(instanceKey, named: "instanceKey")
    try __proto.validateValue(oldTask, named: "oldTask")
    try __proto.validateValue(rewrittenTask, named: "rewrittenTask")

    return InstanceConfigRewrite(instanceKey: instanceKey, oldTask: oldTask, rewrittenTask: rewrittenTask)
  }

  public static func writeValue(__value: InstanceConfigRewrite, toProtocol __proto: TProtocol) throws {

    try __proto.writeStructBeginWithName("InstanceConfigRewrite")

    try __proto.writeFieldValue(__value.instanceKey, name: "instanceKey", type: .STRUCT, id: 1)

    try __proto.writeFieldValue(__value.oldTask, name: "oldTask", type: .STRUCT, id: 2)

    try __proto.writeFieldValue(__value.rewrittenTask, name: "rewrittenTask", type: .STRUCT, id: 3)

    try __proto.writeFieldStop()

    try __proto.writeStructEnd()
  }

}



public func ==(lhs: JobConfigRewrite, rhs: JobConfigRewrite) -> Bool {
  return
    (lhs.oldJob ?== rhs.oldJob) &&
    (lhs.rewrittenJob ?== rhs.rewrittenJob)
}

extension JobConfigRewrite : CustomStringConvertible {

  public var description : String {
    var desc = "JobConfigRewrite("
    desc += "oldJob=\(self.oldJob), "
    desc += "rewrittenJob=\(self.rewrittenJob)"
    desc += ")"
    return desc
  }

}

extension JobConfigRewrite : Hashable {

  public var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime * result + (oldJob.hashValue)
    result = prime * result + (rewrittenJob.hashValue)
    return result
  }

}

extension JobConfigRewrite : TStruct {

  public static func readValueFromProtocol(__proto: TProtocol) throws -> JobConfigRewrite {

    try __proto.readStructBegin()

    var oldJob : JobConfiguration!
    var rewrittenJob : JobConfiguration!

    fields: while true {

      let (_, fieldType, fieldID) = try __proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .STOP):
          break fields

        case (1, .STRUCT):
          oldJob = try __proto.readValue() as JobConfiguration

        case (2, .STRUCT):
          rewrittenJob = try __proto.readValue() as JobConfiguration

        case let (_, unknownType):
          try __proto.skipType(unknownType)
      }

      try __proto.readFieldEnd()
    }

    try __proto.readStructEnd()

    // Required fields
    try __proto.validateValue(oldJob, named: "oldJob")
    try __proto.validateValue(rewrittenJob, named: "rewrittenJob")

    return JobConfigRewrite(oldJob: oldJob, rewrittenJob: rewrittenJob)
  }

  public static func writeValue(__value: JobConfigRewrite, toProtocol __proto: TProtocol) throws {

    try __proto.writeStructBeginWithName("JobConfigRewrite")

    try __proto.writeFieldValue(__value.oldJob, name: "oldJob", type: .STRUCT, id: 1)

    try __proto.writeFieldValue(__value.rewrittenJob, name: "rewrittenJob", type: .STRUCT, id: 2)

    try __proto.writeFieldStop()

    try __proto.writeStructEnd()
  }

}



public func ==(lhs: ConfigRewrite, rhs: ConfigRewrite) -> Bool {
  return
    (lhs.jobRewrite ?== rhs.jobRewrite) &&
    (lhs.instanceRewrite ?== rhs.instanceRewrite)
}

extension ConfigRewrite : CustomStringConvertible {

  public var description : String {
    var desc = "ConfigRewrite("
    desc += "jobRewrite=\(self.jobRewrite), "
    desc += "instanceRewrite=\(self.instanceRewrite)"
    desc += ")"
    return desc
  }

}

extension ConfigRewrite : Hashable {

  public var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime * result + (jobRewrite.hashValue)
    result = prime * result + (instanceRewrite.hashValue)
    return result
  }

}

extension ConfigRewrite : TStruct {

  public static func readValueFromProtocol(__proto: TProtocol) throws -> ConfigRewrite {

    try __proto.readStructBegin()

    var jobRewrite : JobConfigRewrite!
    var instanceRewrite : InstanceConfigRewrite!

    fields: while true {

      let (_, fieldType, fieldID) = try __proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .STOP):
          break fields

        case (1, .STRUCT):
          jobRewrite = try __proto.readValue() as JobConfigRewrite

        case (2, .STRUCT):
          instanceRewrite = try __proto.readValue() as InstanceConfigRewrite

        case let (_, unknownType):
          try __proto.skipType(unknownType)
      }

      try __proto.readFieldEnd()
    }

    try __proto.readStructEnd()

    // Required fields
    try __proto.validateValue(jobRewrite, named: "jobRewrite")
    try __proto.validateValue(instanceRewrite, named: "instanceRewrite")

    return ConfigRewrite(jobRewrite: jobRewrite, instanceRewrite: instanceRewrite)
  }

  public static func writeValue(__value: ConfigRewrite, toProtocol __proto: TProtocol) throws {

    try __proto.writeStructBeginWithName("ConfigRewrite")

    try __proto.writeFieldValue(__value.jobRewrite, name: "jobRewrite", type: .STRUCT, id: 1)

    try __proto.writeFieldValue(__value.instanceRewrite, name: "instanceRewrite", type: .STRUCT, id: 2)

    try __proto.writeFieldStop()

    try __proto.writeStructEnd()
  }

}



public func ==(lhs: RewriteConfigsRequest, rhs: RewriteConfigsRequest) -> Bool {
  return
    (lhs.rewriteCommands ?== rhs.rewriteCommands)
}

extension RewriteConfigsRequest : CustomStringConvertible {

  public var description : String {
    var desc = "RewriteConfigsRequest("
    desc += "rewriteCommands=\(self.rewriteCommands)"
    desc += ")"
    return desc
  }

}

extension RewriteConfigsRequest : Hashable {

  public var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime * result + (rewriteCommands.hashValue)
    return result
  }

}

extension RewriteConfigsRequest : TStruct {

  public static func readValueFromProtocol(__proto: TProtocol) throws -> RewriteConfigsRequest {

    try __proto.readStructBegin()

    var rewriteCommands : TList<ConfigRewrite>!

    fields: while true {

      let (_, fieldType, fieldID) = try __proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .STOP):
          break fields

        case (1, .LIST):
          rewriteCommands = try __proto.readValue() as TList<ConfigRewrite>

        case let (_, unknownType):
          try __proto.skipType(unknownType)
      }

      try __proto.readFieldEnd()
    }

    try __proto.readStructEnd()

    // Required fields
    try __proto.validateValue(rewriteCommands, named: "rewriteCommands")

    return RewriteConfigsRequest(rewriteCommands: rewriteCommands)
  }

  public static func writeValue(__value: RewriteConfigsRequest, toProtocol __proto: TProtocol) throws {

    try __proto.writeStructBeginWithName("RewriteConfigsRequest")

    try __proto.writeFieldValue(__value.rewriteCommands, name: "rewriteCommands", type: .LIST, id: 1)

    try __proto.writeFieldStop()

    try __proto.writeStructEnd()
  }

}



private struct ReadOnlyScheduler_getRoleSummary_args {

  private init() {
  }

}

private func ==(lhs: ReadOnlyScheduler_getRoleSummary_args, rhs: ReadOnlyScheduler_getRoleSummary_args) -> Bool {
  return true
}

extension ReadOnlyScheduler_getRoleSummary_args : Hashable {

  private var hashValue : Int {
    return 31
  }

}

extension ReadOnlyScheduler_getRoleSummary_args : TStruct {

  private static func readValueFromProtocol(__proto: TProtocol) throws -> ReadOnlyScheduler_getRoleSummary_args {

    try __proto.readStructBegin()


    fields: while true {

      let (_, fieldType, fieldID) = try __proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .STOP):
          break fields

        case let (_, unknownType):
          try __proto.skipType(unknownType)
      }

      try __proto.readFieldEnd()
    }

    try __proto.readStructEnd()


    return ReadOnlyScheduler_getRoleSummary_args()
  }

  private static func writeValue(__value: ReadOnlyScheduler_getRoleSummary_args, toProtocol __proto: TProtocol) throws {

    try __proto.writeStructBeginWithName("ReadOnlyScheduler_getRoleSummary_args")

    try __proto.writeFieldStop()

    try __proto.writeStructEnd()
  }

}



private struct ReadOnlyScheduler_getRoleSummary_result {

  private var success : Response?

  private init() {
  }

  private init(success: Response?) {
    self.success = success
  }

}

private func ==(lhs: ReadOnlyScheduler_getRoleSummary_result, rhs: ReadOnlyScheduler_getRoleSummary_result) -> Bool {
  return
    (lhs.success ?== rhs.success)
}

extension ReadOnlyScheduler_getRoleSummary_result : Hashable {

  private var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime * result + (success?.hashValue ?? 0)
    return result
  }

}

extension ReadOnlyScheduler_getRoleSummary_result : TStruct {

  private static func readValueFromProtocol(__proto: TProtocol) throws -> ReadOnlyScheduler_getRoleSummary_result {

    try __proto.readStructBegin()

    var success : Response?

    fields: while true {

      let (_, fieldType, fieldID) = try __proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .STOP):
          break fields

        case (0, .STRUCT):
          success = try __proto.readValue() as Response

        case let (_, unknownType):
          try __proto.skipType(unknownType)
      }

      try __proto.readFieldEnd()
    }

    try __proto.readStructEnd()


    return ReadOnlyScheduler_getRoleSummary_result(success: success)
  }

  private static func writeValue(__value: ReadOnlyScheduler_getRoleSummary_result, toProtocol __proto: TProtocol) throws {

    try __proto.writeStructBeginWithName("ReadOnlyScheduler_getRoleSummary_result")

    if let result = __value.success {
      try __proto.writeFieldValue(result, name: "success", type: .STRUCT, id: 0)
    }
    try __proto.writeFieldStop()

    try __proto.writeStructEnd()
  }

}



private struct ReadOnlyScheduler_getJobSummary_args {

  private var role = String()

  private init() {
  }

  private init(role: String) {
    self.role = role
  }

}

private func ==(lhs: ReadOnlyScheduler_getJobSummary_args, rhs: ReadOnlyScheduler_getJobSummary_args) -> Bool {
  return
    (lhs.role ?== rhs.role)
}

extension ReadOnlyScheduler_getJobSummary_args : Hashable {

  private var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime * result + (role.hashValue)
    return result
  }

}

extension ReadOnlyScheduler_getJobSummary_args : TStruct {

  private static func readValueFromProtocol(__proto: TProtocol) throws -> ReadOnlyScheduler_getJobSummary_args {

    try __proto.readStructBegin()

    var role : String!

    fields: while true {

      let (_, fieldType, fieldID) = try __proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .STOP):
          break fields

        case (1, .STRING):
          role = try __proto.readValue() as String

        case let (_, unknownType):
          try __proto.skipType(unknownType)
      }

      try __proto.readFieldEnd()
    }

    try __proto.readStructEnd()

    // Required fields
    try __proto.validateValue(role, named: "role")

    return ReadOnlyScheduler_getJobSummary_args(role: role)
  }

  private static func writeValue(__value: ReadOnlyScheduler_getJobSummary_args, toProtocol __proto: TProtocol) throws {

    try __proto.writeStructBeginWithName("ReadOnlyScheduler_getJobSummary_args")

    try __proto.writeFieldValue(__value.role, name: "role", type: .STRING, id: 1)

    try __proto.writeFieldStop()

    try __proto.writeStructEnd()
  }

}



private struct ReadOnlyScheduler_getJobSummary_result {

  private var success : Response?

  private init() {
  }

  private init(success: Response?) {
    self.success = success
  }

}

private func ==(lhs: ReadOnlyScheduler_getJobSummary_result, rhs: ReadOnlyScheduler_getJobSummary_result) -> Bool {
  return
    (lhs.success ?== rhs.success)
}

extension ReadOnlyScheduler_getJobSummary_result : Hashable {

  private var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime * result + (success?.hashValue ?? 0)
    return result
  }

}

extension ReadOnlyScheduler_getJobSummary_result : TStruct {

  private static func readValueFromProtocol(__proto: TProtocol) throws -> ReadOnlyScheduler_getJobSummary_result {

    try __proto.readStructBegin()

    var success : Response?

    fields: while true {

      let (_, fieldType, fieldID) = try __proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .STOP):
          break fields

        case (0, .STRUCT):
          success = try __proto.readValue() as Response

        case let (_, unknownType):
          try __proto.skipType(unknownType)
      }

      try __proto.readFieldEnd()
    }

    try __proto.readStructEnd()


    return ReadOnlyScheduler_getJobSummary_result(success: success)
  }

  private static func writeValue(__value: ReadOnlyScheduler_getJobSummary_result, toProtocol __proto: TProtocol) throws {

    try __proto.writeStructBeginWithName("ReadOnlyScheduler_getJobSummary_result")

    if let result = __value.success {
      try __proto.writeFieldValue(result, name: "success", type: .STRUCT, id: 0)
    }
    try __proto.writeFieldStop()

    try __proto.writeStructEnd()
  }

}



private struct ReadOnlyScheduler_getTasksStatus_args {

  private var query = TaskQuery()

  private init() {
  }

  private init(query: TaskQuery) {
    self.query = query
  }

}

private func ==(lhs: ReadOnlyScheduler_getTasksStatus_args, rhs: ReadOnlyScheduler_getTasksStatus_args) -> Bool {
  return
    (lhs.query ?== rhs.query)
}

extension ReadOnlyScheduler_getTasksStatus_args : Hashable {

  private var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime * result + (query.hashValue)
    return result
  }

}

extension ReadOnlyScheduler_getTasksStatus_args : TStruct {

  private static func readValueFromProtocol(__proto: TProtocol) throws -> ReadOnlyScheduler_getTasksStatus_args {

    try __proto.readStructBegin()

    var query : TaskQuery!

    fields: while true {

      let (_, fieldType, fieldID) = try __proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .STOP):
          break fields

        case (1, .STRUCT):
          query = try __proto.readValue() as TaskQuery

        case let (_, unknownType):
          try __proto.skipType(unknownType)
      }

      try __proto.readFieldEnd()
    }

    try __proto.readStructEnd()

    // Required fields
    try __proto.validateValue(query, named: "query")

    return ReadOnlyScheduler_getTasksStatus_args(query: query)
  }

  private static func writeValue(__value: ReadOnlyScheduler_getTasksStatus_args, toProtocol __proto: TProtocol) throws {

    try __proto.writeStructBeginWithName("ReadOnlyScheduler_getTasksStatus_args")

    try __proto.writeFieldValue(__value.query, name: "query", type: .STRUCT, id: 1)

    try __proto.writeFieldStop()

    try __proto.writeStructEnd()
  }

}



private struct ReadOnlyScheduler_getTasksStatus_result {

  private var success : Response?

  private init() {
  }

  private init(success: Response?) {
    self.success = success
  }

}

private func ==(lhs: ReadOnlyScheduler_getTasksStatus_result, rhs: ReadOnlyScheduler_getTasksStatus_result) -> Bool {
  return
    (lhs.success ?== rhs.success)
}

extension ReadOnlyScheduler_getTasksStatus_result : Hashable {

  private var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime * result + (success?.hashValue ?? 0)
    return result
  }

}

extension ReadOnlyScheduler_getTasksStatus_result : TStruct {

  private static func readValueFromProtocol(__proto: TProtocol) throws -> ReadOnlyScheduler_getTasksStatus_result {

    try __proto.readStructBegin()

    var success : Response?

    fields: while true {

      let (_, fieldType, fieldID) = try __proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .STOP):
          break fields

        case (0, .STRUCT):
          success = try __proto.readValue() as Response

        case let (_, unknownType):
          try __proto.skipType(unknownType)
      }

      try __proto.readFieldEnd()
    }

    try __proto.readStructEnd()


    return ReadOnlyScheduler_getTasksStatus_result(success: success)
  }

  private static func writeValue(__value: ReadOnlyScheduler_getTasksStatus_result, toProtocol __proto: TProtocol) throws {

    try __proto.writeStructBeginWithName("ReadOnlyScheduler_getTasksStatus_result")

    if let result = __value.success {
      try __proto.writeFieldValue(result, name: "success", type: .STRUCT, id: 0)
    }
    try __proto.writeFieldStop()

    try __proto.writeStructEnd()
  }

}



private struct ReadOnlyScheduler_getTasksWithoutConfigs_args {

  private var query = TaskQuery()

  private init() {
  }

  private init(query: TaskQuery) {
    self.query = query
  }

}

private func ==(lhs: ReadOnlyScheduler_getTasksWithoutConfigs_args, rhs: ReadOnlyScheduler_getTasksWithoutConfigs_args) -> Bool {
  return
    (lhs.query ?== rhs.query)
}

extension ReadOnlyScheduler_getTasksWithoutConfigs_args : Hashable {

  private var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime * result + (query.hashValue)
    return result
  }

}

extension ReadOnlyScheduler_getTasksWithoutConfigs_args : TStruct {

  private static func readValueFromProtocol(__proto: TProtocol) throws -> ReadOnlyScheduler_getTasksWithoutConfigs_args {

    try __proto.readStructBegin()

    var query : TaskQuery!

    fields: while true {

      let (_, fieldType, fieldID) = try __proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .STOP):
          break fields

        case (1, .STRUCT):
          query = try __proto.readValue() as TaskQuery

        case let (_, unknownType):
          try __proto.skipType(unknownType)
      }

      try __proto.readFieldEnd()
    }

    try __proto.readStructEnd()

    // Required fields
    try __proto.validateValue(query, named: "query")

    return ReadOnlyScheduler_getTasksWithoutConfigs_args(query: query)
  }

  private static func writeValue(__value: ReadOnlyScheduler_getTasksWithoutConfigs_args, toProtocol __proto: TProtocol) throws {

    try __proto.writeStructBeginWithName("ReadOnlyScheduler_getTasksWithoutConfigs_args")

    try __proto.writeFieldValue(__value.query, name: "query", type: .STRUCT, id: 1)

    try __proto.writeFieldStop()

    try __proto.writeStructEnd()
  }

}



private struct ReadOnlyScheduler_getTasksWithoutConfigs_result {

  private var success : Response?

  private init() {
  }

  private init(success: Response?) {
    self.success = success
  }

}

private func ==(lhs: ReadOnlyScheduler_getTasksWithoutConfigs_result, rhs: ReadOnlyScheduler_getTasksWithoutConfigs_result) -> Bool {
  return
    (lhs.success ?== rhs.success)
}

extension ReadOnlyScheduler_getTasksWithoutConfigs_result : Hashable {

  private var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime * result + (success?.hashValue ?? 0)
    return result
  }

}

extension ReadOnlyScheduler_getTasksWithoutConfigs_result : TStruct {

  private static func readValueFromProtocol(__proto: TProtocol) throws -> ReadOnlyScheduler_getTasksWithoutConfigs_result {

    try __proto.readStructBegin()

    var success : Response?

    fields: while true {

      let (_, fieldType, fieldID) = try __proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .STOP):
          break fields

        case (0, .STRUCT):
          success = try __proto.readValue() as Response

        case let (_, unknownType):
          try __proto.skipType(unknownType)
      }

      try __proto.readFieldEnd()
    }

    try __proto.readStructEnd()


    return ReadOnlyScheduler_getTasksWithoutConfigs_result(success: success)
  }

  private static func writeValue(__value: ReadOnlyScheduler_getTasksWithoutConfigs_result, toProtocol __proto: TProtocol) throws {

    try __proto.writeStructBeginWithName("ReadOnlyScheduler_getTasksWithoutConfigs_result")

    if let result = __value.success {
      try __proto.writeFieldValue(result, name: "success", type: .STRUCT, id: 0)
    }
    try __proto.writeFieldStop()

    try __proto.writeStructEnd()
  }

}



private struct ReadOnlyScheduler_getPendingReason_args {

  private var query = TaskQuery()

  private init() {
  }

  private init(query: TaskQuery) {
    self.query = query
  }

}

private func ==(lhs: ReadOnlyScheduler_getPendingReason_args, rhs: ReadOnlyScheduler_getPendingReason_args) -> Bool {
  return
    (lhs.query ?== rhs.query)
}

extension ReadOnlyScheduler_getPendingReason_args : Hashable {

  private var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime * result + (query.hashValue)
    return result
  }

}

extension ReadOnlyScheduler_getPendingReason_args : TStruct {

  private static func readValueFromProtocol(__proto: TProtocol) throws -> ReadOnlyScheduler_getPendingReason_args {

    try __proto.readStructBegin()

    var query : TaskQuery!

    fields: while true {

      let (_, fieldType, fieldID) = try __proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .STOP):
          break fields

        case (1, .STRUCT):
          query = try __proto.readValue() as TaskQuery

        case let (_, unknownType):
          try __proto.skipType(unknownType)
      }

      try __proto.readFieldEnd()
    }

    try __proto.readStructEnd()

    // Required fields
    try __proto.validateValue(query, named: "query")

    return ReadOnlyScheduler_getPendingReason_args(query: query)
  }

  private static func writeValue(__value: ReadOnlyScheduler_getPendingReason_args, toProtocol __proto: TProtocol) throws {

    try __proto.writeStructBeginWithName("ReadOnlyScheduler_getPendingReason_args")

    try __proto.writeFieldValue(__value.query, name: "query", type: .STRUCT, id: 1)

    try __proto.writeFieldStop()

    try __proto.writeStructEnd()
  }

}



private struct ReadOnlyScheduler_getPendingReason_result {

  private var success : Response?

  private init() {
  }

  private init(success: Response?) {
    self.success = success
  }

}

private func ==(lhs: ReadOnlyScheduler_getPendingReason_result, rhs: ReadOnlyScheduler_getPendingReason_result) -> Bool {
  return
    (lhs.success ?== rhs.success)
}

extension ReadOnlyScheduler_getPendingReason_result : Hashable {

  private var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime * result + (success?.hashValue ?? 0)
    return result
  }

}

extension ReadOnlyScheduler_getPendingReason_result : TStruct {

  private static func readValueFromProtocol(__proto: TProtocol) throws -> ReadOnlyScheduler_getPendingReason_result {

    try __proto.readStructBegin()

    var success : Response?

    fields: while true {

      let (_, fieldType, fieldID) = try __proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .STOP):
          break fields

        case (0, .STRUCT):
          success = try __proto.readValue() as Response

        case let (_, unknownType):
          try __proto.skipType(unknownType)
      }

      try __proto.readFieldEnd()
    }

    try __proto.readStructEnd()


    return ReadOnlyScheduler_getPendingReason_result(success: success)
  }

  private static func writeValue(__value: ReadOnlyScheduler_getPendingReason_result, toProtocol __proto: TProtocol) throws {

    try __proto.writeStructBeginWithName("ReadOnlyScheduler_getPendingReason_result")

    if let result = __value.success {
      try __proto.writeFieldValue(result, name: "success", type: .STRUCT, id: 0)
    }
    try __proto.writeFieldStop()

    try __proto.writeStructEnd()
  }

}



private struct ReadOnlyScheduler_getConfigSummary_args {

  private var job = JobKey()

  private init() {
  }

  private init(job: JobKey) {
    self.job = job
  }

}

private func ==(lhs: ReadOnlyScheduler_getConfigSummary_args, rhs: ReadOnlyScheduler_getConfigSummary_args) -> Bool {
  return
    (lhs.job ?== rhs.job)
}

extension ReadOnlyScheduler_getConfigSummary_args : Hashable {

  private var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime * result + (job.hashValue)
    return result
  }

}

extension ReadOnlyScheduler_getConfigSummary_args : TStruct {

  private static func readValueFromProtocol(__proto: TProtocol) throws -> ReadOnlyScheduler_getConfigSummary_args {

    try __proto.readStructBegin()

    var job : JobKey!

    fields: while true {

      let (_, fieldType, fieldID) = try __proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .STOP):
          break fields

        case (1, .STRUCT):
          job = try __proto.readValue() as JobKey

        case let (_, unknownType):
          try __proto.skipType(unknownType)
      }

      try __proto.readFieldEnd()
    }

    try __proto.readStructEnd()

    // Required fields
    try __proto.validateValue(job, named: "job")

    return ReadOnlyScheduler_getConfigSummary_args(job: job)
  }

  private static func writeValue(__value: ReadOnlyScheduler_getConfigSummary_args, toProtocol __proto: TProtocol) throws {

    try __proto.writeStructBeginWithName("ReadOnlyScheduler_getConfigSummary_args")

    try __proto.writeFieldValue(__value.job, name: "job", type: .STRUCT, id: 1)

    try __proto.writeFieldStop()

    try __proto.writeStructEnd()
  }

}



private struct ReadOnlyScheduler_getConfigSummary_result {

  private var success : Response?

  private init() {
  }

  private init(success: Response?) {
    self.success = success
  }

}

private func ==(lhs: ReadOnlyScheduler_getConfigSummary_result, rhs: ReadOnlyScheduler_getConfigSummary_result) -> Bool {
  return
    (lhs.success ?== rhs.success)
}

extension ReadOnlyScheduler_getConfigSummary_result : Hashable {

  private var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime * result + (success?.hashValue ?? 0)
    return result
  }

}

extension ReadOnlyScheduler_getConfigSummary_result : TStruct {

  private static func readValueFromProtocol(__proto: TProtocol) throws -> ReadOnlyScheduler_getConfigSummary_result {

    try __proto.readStructBegin()

    var success : Response?

    fields: while true {

      let (_, fieldType, fieldID) = try __proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .STOP):
          break fields

        case (0, .STRUCT):
          success = try __proto.readValue() as Response

        case let (_, unknownType):
          try __proto.skipType(unknownType)
      }

      try __proto.readFieldEnd()
    }

    try __proto.readStructEnd()


    return ReadOnlyScheduler_getConfigSummary_result(success: success)
  }

  private static func writeValue(__value: ReadOnlyScheduler_getConfigSummary_result, toProtocol __proto: TProtocol) throws {

    try __proto.writeStructBeginWithName("ReadOnlyScheduler_getConfigSummary_result")

    if let result = __value.success {
      try __proto.writeFieldValue(result, name: "success", type: .STRUCT, id: 0)
    }
    try __proto.writeFieldStop()

    try __proto.writeStructEnd()
  }

}



private struct ReadOnlyScheduler_getJobs_args {

  private var ownerRole = String()

  private init() {
  }

  private init(ownerRole: String) {
    self.ownerRole = ownerRole
  }

}

private func ==(lhs: ReadOnlyScheduler_getJobs_args, rhs: ReadOnlyScheduler_getJobs_args) -> Bool {
  return
    (lhs.ownerRole ?== rhs.ownerRole)
}

extension ReadOnlyScheduler_getJobs_args : Hashable {

  private var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime * result + (ownerRole.hashValue)
    return result
  }

}

extension ReadOnlyScheduler_getJobs_args : TStruct {

  private static func readValueFromProtocol(__proto: TProtocol) throws -> ReadOnlyScheduler_getJobs_args {

    try __proto.readStructBegin()

    var ownerRole : String!

    fields: while true {

      let (_, fieldType, fieldID) = try __proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .STOP):
          break fields

        case (1, .STRING):
          ownerRole = try __proto.readValue() as String

        case let (_, unknownType):
          try __proto.skipType(unknownType)
      }

      try __proto.readFieldEnd()
    }

    try __proto.readStructEnd()

    // Required fields
    try __proto.validateValue(ownerRole, named: "ownerRole")

    return ReadOnlyScheduler_getJobs_args(ownerRole: ownerRole)
  }

  private static func writeValue(__value: ReadOnlyScheduler_getJobs_args, toProtocol __proto: TProtocol) throws {

    try __proto.writeStructBeginWithName("ReadOnlyScheduler_getJobs_args")

    try __proto.writeFieldValue(__value.ownerRole, name: "ownerRole", type: .STRING, id: 1)

    try __proto.writeFieldStop()

    try __proto.writeStructEnd()
  }

}



private struct ReadOnlyScheduler_getJobs_result {

  private var success : Response?

  private init() {
  }

  private init(success: Response?) {
    self.success = success
  }

}

private func ==(lhs: ReadOnlyScheduler_getJobs_result, rhs: ReadOnlyScheduler_getJobs_result) -> Bool {
  return
    (lhs.success ?== rhs.success)
}

extension ReadOnlyScheduler_getJobs_result : Hashable {

  private var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime * result + (success?.hashValue ?? 0)
    return result
  }

}

extension ReadOnlyScheduler_getJobs_result : TStruct {

  private static func readValueFromProtocol(__proto: TProtocol) throws -> ReadOnlyScheduler_getJobs_result {

    try __proto.readStructBegin()

    var success : Response?

    fields: while true {

      let (_, fieldType, fieldID) = try __proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .STOP):
          break fields

        case (0, .STRUCT):
          success = try __proto.readValue() as Response

        case let (_, unknownType):
          try __proto.skipType(unknownType)
      }

      try __proto.readFieldEnd()
    }

    try __proto.readStructEnd()


    return ReadOnlyScheduler_getJobs_result(success: success)
  }

  private static func writeValue(__value: ReadOnlyScheduler_getJobs_result, toProtocol __proto: TProtocol) throws {

    try __proto.writeStructBeginWithName("ReadOnlyScheduler_getJobs_result")

    if let result = __value.success {
      try __proto.writeFieldValue(result, name: "success", type: .STRUCT, id: 0)
    }
    try __proto.writeFieldStop()

    try __proto.writeStructEnd()
  }

}



private struct ReadOnlyScheduler_getQuota_args {

  private var ownerRole = String()

  private init() {
  }

  private init(ownerRole: String) {
    self.ownerRole = ownerRole
  }

}

private func ==(lhs: ReadOnlyScheduler_getQuota_args, rhs: ReadOnlyScheduler_getQuota_args) -> Bool {
  return
    (lhs.ownerRole ?== rhs.ownerRole)
}

extension ReadOnlyScheduler_getQuota_args : Hashable {

  private var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime * result + (ownerRole.hashValue)
    return result
  }

}

extension ReadOnlyScheduler_getQuota_args : TStruct {

  private static func readValueFromProtocol(__proto: TProtocol) throws -> ReadOnlyScheduler_getQuota_args {

    try __proto.readStructBegin()

    var ownerRole : String!

    fields: while true {

      let (_, fieldType, fieldID) = try __proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .STOP):
          break fields

        case (1, .STRING):
          ownerRole = try __proto.readValue() as String

        case let (_, unknownType):
          try __proto.skipType(unknownType)
      }

      try __proto.readFieldEnd()
    }

    try __proto.readStructEnd()

    // Required fields
    try __proto.validateValue(ownerRole, named: "ownerRole")

    return ReadOnlyScheduler_getQuota_args(ownerRole: ownerRole)
  }

  private static func writeValue(__value: ReadOnlyScheduler_getQuota_args, toProtocol __proto: TProtocol) throws {

    try __proto.writeStructBeginWithName("ReadOnlyScheduler_getQuota_args")

    try __proto.writeFieldValue(__value.ownerRole, name: "ownerRole", type: .STRING, id: 1)

    try __proto.writeFieldStop()

    try __proto.writeStructEnd()
  }

}



private struct ReadOnlyScheduler_getQuota_result {

  private var success : Response?

  private init() {
  }

  private init(success: Response?) {
    self.success = success
  }

}

private func ==(lhs: ReadOnlyScheduler_getQuota_result, rhs: ReadOnlyScheduler_getQuota_result) -> Bool {
  return
    (lhs.success ?== rhs.success)
}

extension ReadOnlyScheduler_getQuota_result : Hashable {

  private var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime * result + (success?.hashValue ?? 0)
    return result
  }

}

extension ReadOnlyScheduler_getQuota_result : TStruct {

  private static func readValueFromProtocol(__proto: TProtocol) throws -> ReadOnlyScheduler_getQuota_result {

    try __proto.readStructBegin()

    var success : Response?

    fields: while true {

      let (_, fieldType, fieldID) = try __proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .STOP):
          break fields

        case (0, .STRUCT):
          success = try __proto.readValue() as Response

        case let (_, unknownType):
          try __proto.skipType(unknownType)
      }

      try __proto.readFieldEnd()
    }

    try __proto.readStructEnd()


    return ReadOnlyScheduler_getQuota_result(success: success)
  }

  private static func writeValue(__value: ReadOnlyScheduler_getQuota_result, toProtocol __proto: TProtocol) throws {

    try __proto.writeStructBeginWithName("ReadOnlyScheduler_getQuota_result")

    if let result = __value.success {
      try __proto.writeFieldValue(result, name: "success", type: .STRUCT, id: 0)
    }
    try __proto.writeFieldStop()

    try __proto.writeStructEnd()
  }

}



private struct ReadOnlyScheduler_populateJobConfig_args {

  private var description = JobConfiguration()

  private init() {
  }

  private init(description: JobConfiguration) {
    self.description = description
  }

}

private func ==(lhs: ReadOnlyScheduler_populateJobConfig_args, rhs: ReadOnlyScheduler_populateJobConfig_args) -> Bool {
  return
    (lhs.description ?== rhs.description)
}

extension ReadOnlyScheduler_populateJobConfig_args : Hashable {

  private var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime * result + (description.hashValue)
    return result
  }

}

extension ReadOnlyScheduler_populateJobConfig_args : TStruct {

  private static func readValueFromProtocol(__proto: TProtocol) throws -> ReadOnlyScheduler_populateJobConfig_args {

    try __proto.readStructBegin()

    var description : JobConfiguration!

    fields: while true {

      let (_, fieldType, fieldID) = try __proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .STOP):
          break fields

        case (1, .STRUCT):
          description = try __proto.readValue() as JobConfiguration

        case let (_, unknownType):
          try __proto.skipType(unknownType)
      }

      try __proto.readFieldEnd()
    }

    try __proto.readStructEnd()

    // Required fields
    try __proto.validateValue(description, named: "description")

    return ReadOnlyScheduler_populateJobConfig_args(description: description)
  }

  private static func writeValue(__value: ReadOnlyScheduler_populateJobConfig_args, toProtocol __proto: TProtocol) throws {

    try __proto.writeStructBeginWithName("ReadOnlyScheduler_populateJobConfig_args")

    try __proto.writeFieldValue(__value.description, name: "description", type: .STRUCT, id: 1)

    try __proto.writeFieldStop()

    try __proto.writeStructEnd()
  }

}



private struct ReadOnlyScheduler_populateJobConfig_result {

  private var success : Response?

  private init() {
  }

  private init(success: Response?) {
    self.success = success
  }

}

private func ==(lhs: ReadOnlyScheduler_populateJobConfig_result, rhs: ReadOnlyScheduler_populateJobConfig_result) -> Bool {
  return
    (lhs.success ?== rhs.success)
}

extension ReadOnlyScheduler_populateJobConfig_result : Hashable {

  private var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime * result + (success?.hashValue ?? 0)
    return result
  }

}

extension ReadOnlyScheduler_populateJobConfig_result : TStruct {

  private static func readValueFromProtocol(__proto: TProtocol) throws -> ReadOnlyScheduler_populateJobConfig_result {

    try __proto.readStructBegin()

    var success : Response?

    fields: while true {

      let (_, fieldType, fieldID) = try __proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .STOP):
          break fields

        case (0, .STRUCT):
          success = try __proto.readValue() as Response

        case let (_, unknownType):
          try __proto.skipType(unknownType)
      }

      try __proto.readFieldEnd()
    }

    try __proto.readStructEnd()


    return ReadOnlyScheduler_populateJobConfig_result(success: success)
  }

  private static func writeValue(__value: ReadOnlyScheduler_populateJobConfig_result, toProtocol __proto: TProtocol) throws {

    try __proto.writeStructBeginWithName("ReadOnlyScheduler_populateJobConfig_result")

    if let result = __value.success {
      try __proto.writeFieldValue(result, name: "success", type: .STRUCT, id: 0)
    }
    try __proto.writeFieldStop()

    try __proto.writeStructEnd()
  }

}



private struct ReadOnlyScheduler_getLocks_args {

  private init() {
  }

}

private func ==(lhs: ReadOnlyScheduler_getLocks_args, rhs: ReadOnlyScheduler_getLocks_args) -> Bool {
  return true
}

extension ReadOnlyScheduler_getLocks_args : Hashable {

  private var hashValue : Int {
    return 31
  }

}

extension ReadOnlyScheduler_getLocks_args : TStruct {

  private static func readValueFromProtocol(__proto: TProtocol) throws -> ReadOnlyScheduler_getLocks_args {

    try __proto.readStructBegin()


    fields: while true {

      let (_, fieldType, fieldID) = try __proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .STOP):
          break fields

        case let (_, unknownType):
          try __proto.skipType(unknownType)
      }

      try __proto.readFieldEnd()
    }

    try __proto.readStructEnd()


    return ReadOnlyScheduler_getLocks_args()
  }

  private static func writeValue(__value: ReadOnlyScheduler_getLocks_args, toProtocol __proto: TProtocol) throws {

    try __proto.writeStructBeginWithName("ReadOnlyScheduler_getLocks_args")

    try __proto.writeFieldStop()

    try __proto.writeStructEnd()
  }

}



private struct ReadOnlyScheduler_getLocks_result {

  private var success : Response?

  private init() {
  }

  private init(success: Response?) {
    self.success = success
  }

}

private func ==(lhs: ReadOnlyScheduler_getLocks_result, rhs: ReadOnlyScheduler_getLocks_result) -> Bool {
  return
    (lhs.success ?== rhs.success)
}

extension ReadOnlyScheduler_getLocks_result : Hashable {

  private var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime * result + (success?.hashValue ?? 0)
    return result
  }

}

extension ReadOnlyScheduler_getLocks_result : TStruct {

  private static func readValueFromProtocol(__proto: TProtocol) throws -> ReadOnlyScheduler_getLocks_result {

    try __proto.readStructBegin()

    var success : Response?

    fields: while true {

      let (_, fieldType, fieldID) = try __proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .STOP):
          break fields

        case (0, .STRUCT):
          success = try __proto.readValue() as Response

        case let (_, unknownType):
          try __proto.skipType(unknownType)
      }

      try __proto.readFieldEnd()
    }

    try __proto.readStructEnd()


    return ReadOnlyScheduler_getLocks_result(success: success)
  }

  private static func writeValue(__value: ReadOnlyScheduler_getLocks_result, toProtocol __proto: TProtocol) throws {

    try __proto.writeStructBeginWithName("ReadOnlyScheduler_getLocks_result")

    if let result = __value.success {
      try __proto.writeFieldValue(result, name: "success", type: .STRUCT, id: 0)
    }
    try __proto.writeFieldStop()

    try __proto.writeStructEnd()
  }

}



private struct ReadOnlyScheduler_getJobUpdateSummaries_args {

  private var jobUpdateQuery = JobUpdateQuery()

  private init() {
  }

  private init(jobUpdateQuery: JobUpdateQuery) {
    self.jobUpdateQuery = jobUpdateQuery
  }

}

private func ==(lhs: ReadOnlyScheduler_getJobUpdateSummaries_args, rhs: ReadOnlyScheduler_getJobUpdateSummaries_args) -> Bool {
  return
    (lhs.jobUpdateQuery ?== rhs.jobUpdateQuery)
}

extension ReadOnlyScheduler_getJobUpdateSummaries_args : Hashable {

  private var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime * result + (jobUpdateQuery.hashValue)
    return result
  }

}

extension ReadOnlyScheduler_getJobUpdateSummaries_args : TStruct {

  private static func readValueFromProtocol(__proto: TProtocol) throws -> ReadOnlyScheduler_getJobUpdateSummaries_args {

    try __proto.readStructBegin()

    var jobUpdateQuery : JobUpdateQuery!

    fields: while true {

      let (_, fieldType, fieldID) = try __proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .STOP):
          break fields

        case (1, .STRUCT):
          jobUpdateQuery = try __proto.readValue() as JobUpdateQuery

        case let (_, unknownType):
          try __proto.skipType(unknownType)
      }

      try __proto.readFieldEnd()
    }

    try __proto.readStructEnd()

    // Required fields
    try __proto.validateValue(jobUpdateQuery, named: "jobUpdateQuery")

    return ReadOnlyScheduler_getJobUpdateSummaries_args(jobUpdateQuery: jobUpdateQuery)
  }

  private static func writeValue(__value: ReadOnlyScheduler_getJobUpdateSummaries_args, toProtocol __proto: TProtocol) throws {

    try __proto.writeStructBeginWithName("ReadOnlyScheduler_getJobUpdateSummaries_args")

    try __proto.writeFieldValue(__value.jobUpdateQuery, name: "jobUpdateQuery", type: .STRUCT, id: 1)

    try __proto.writeFieldStop()

    try __proto.writeStructEnd()
  }

}



private struct ReadOnlyScheduler_getJobUpdateSummaries_result {

  private var success : Response?

  private init() {
  }

  private init(success: Response?) {
    self.success = success
  }

}

private func ==(lhs: ReadOnlyScheduler_getJobUpdateSummaries_result, rhs: ReadOnlyScheduler_getJobUpdateSummaries_result) -> Bool {
  return
    (lhs.success ?== rhs.success)
}

extension ReadOnlyScheduler_getJobUpdateSummaries_result : Hashable {

  private var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime * result + (success?.hashValue ?? 0)
    return result
  }

}

extension ReadOnlyScheduler_getJobUpdateSummaries_result : TStruct {

  private static func readValueFromProtocol(__proto: TProtocol) throws -> ReadOnlyScheduler_getJobUpdateSummaries_result {

    try __proto.readStructBegin()

    var success : Response?

    fields: while true {

      let (_, fieldType, fieldID) = try __proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .STOP):
          break fields

        case (0, .STRUCT):
          success = try __proto.readValue() as Response

        case let (_, unknownType):
          try __proto.skipType(unknownType)
      }

      try __proto.readFieldEnd()
    }

    try __proto.readStructEnd()


    return ReadOnlyScheduler_getJobUpdateSummaries_result(success: success)
  }

  private static func writeValue(__value: ReadOnlyScheduler_getJobUpdateSummaries_result, toProtocol __proto: TProtocol) throws {

    try __proto.writeStructBeginWithName("ReadOnlyScheduler_getJobUpdateSummaries_result")

    if let result = __value.success {
      try __proto.writeFieldValue(result, name: "success", type: .STRUCT, id: 0)
    }
    try __proto.writeFieldStop()

    try __proto.writeStructEnd()
  }

}



private struct ReadOnlyScheduler_getJobUpdateDetails_args {

  private var key = JobUpdateKey()

  private init() {
  }

  private init(key: JobUpdateKey) {
    self.key = key
  }

}

private func ==(lhs: ReadOnlyScheduler_getJobUpdateDetails_args, rhs: ReadOnlyScheduler_getJobUpdateDetails_args) -> Bool {
  return
    (lhs.key ?== rhs.key)
}

extension ReadOnlyScheduler_getJobUpdateDetails_args : Hashable {

  private var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime * result + (key.hashValue)
    return result
  }

}

extension ReadOnlyScheduler_getJobUpdateDetails_args : TStruct {

  private static func readValueFromProtocol(__proto: TProtocol) throws -> ReadOnlyScheduler_getJobUpdateDetails_args {

    try __proto.readStructBegin()

    var key : JobUpdateKey!

    fields: while true {

      let (_, fieldType, fieldID) = try __proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .STOP):
          break fields

        case (1, .STRUCT):
          key = try __proto.readValue() as JobUpdateKey

        case let (_, unknownType):
          try __proto.skipType(unknownType)
      }

      try __proto.readFieldEnd()
    }

    try __proto.readStructEnd()

    // Required fields
    try __proto.validateValue(key, named: "key")

    return ReadOnlyScheduler_getJobUpdateDetails_args(key: key)
  }

  private static func writeValue(__value: ReadOnlyScheduler_getJobUpdateDetails_args, toProtocol __proto: TProtocol) throws {

    try __proto.writeStructBeginWithName("ReadOnlyScheduler_getJobUpdateDetails_args")

    try __proto.writeFieldValue(__value.key, name: "key", type: .STRUCT, id: 1)

    try __proto.writeFieldStop()

    try __proto.writeStructEnd()
  }

}



private struct ReadOnlyScheduler_getJobUpdateDetails_result {

  private var success : Response?

  private init() {
  }

  private init(success: Response?) {
    self.success = success
  }

}

private func ==(lhs: ReadOnlyScheduler_getJobUpdateDetails_result, rhs: ReadOnlyScheduler_getJobUpdateDetails_result) -> Bool {
  return
    (lhs.success ?== rhs.success)
}

extension ReadOnlyScheduler_getJobUpdateDetails_result : Hashable {

  private var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime * result + (success?.hashValue ?? 0)
    return result
  }

}

extension ReadOnlyScheduler_getJobUpdateDetails_result : TStruct {

  private static func readValueFromProtocol(__proto: TProtocol) throws -> ReadOnlyScheduler_getJobUpdateDetails_result {

    try __proto.readStructBegin()

    var success : Response?

    fields: while true {

      let (_, fieldType, fieldID) = try __proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .STOP):
          break fields

        case (0, .STRUCT):
          success = try __proto.readValue() as Response

        case let (_, unknownType):
          try __proto.skipType(unknownType)
      }

      try __proto.readFieldEnd()
    }

    try __proto.readStructEnd()


    return ReadOnlyScheduler_getJobUpdateDetails_result(success: success)
  }

  private static func writeValue(__value: ReadOnlyScheduler_getJobUpdateDetails_result, toProtocol __proto: TProtocol) throws {

    try __proto.writeStructBeginWithName("ReadOnlyScheduler_getJobUpdateDetails_result")

    if let result = __value.success {
      try __proto.writeFieldValue(result, name: "success", type: .STRUCT, id: 0)
    }
    try __proto.writeFieldStop()

    try __proto.writeStructEnd()
  }

}



extension ReadOnlySchedulerClient : ReadOnlyScheduler {

  private func send_getRoleSummary() throws {

    try __outProtocol.writeMessageBeginWithName("getRoleSummary", type: .CALL, sequenceID: 0)

    let __args = ReadOnlyScheduler_getRoleSummary_args()
    try ReadOnlyScheduler_getRoleSummary_args.writeValue(__args, toProtocol: __outProtocol)

    try __outProtocol.writeMessageEnd()
  }

  private func recv_getRoleSummary() throws -> Response {

    try __inProtocol.readResultMessageBegin() 

    let __result = try ReadOnlyScheduler_getRoleSummary_result.readValueFromProtocol(__inProtocol)

    try __inProtocol.readMessageEnd()

    if let __success = __result.success {
      return __success
    }
    throw NSError(
      domain: TApplicationErrorDomain, 
      code: Int(TApplicationError.MissingResult.rawValue),
      userInfo: [TApplicationErrorMethodKey: "getRoleSummary"])
  }

  public func getRoleSummary() throws -> Response {

    try send_getRoleSummary()

    try __outProtocol.transport().flush()

    return try recv_getRoleSummary()
  }

  private func send_getJobSummary(role role: String) throws {

    try __outProtocol.writeMessageBeginWithName("getJobSummary", type: .CALL, sequenceID: 0)

    let __args = ReadOnlyScheduler_getJobSummary_args(role: role)
    try ReadOnlyScheduler_getJobSummary_args.writeValue(__args, toProtocol: __outProtocol)

    try __outProtocol.writeMessageEnd()
  }

  private func recv_getJobSummary() throws -> Response {

    try __inProtocol.readResultMessageBegin() 

    let __result = try ReadOnlyScheduler_getJobSummary_result.readValueFromProtocol(__inProtocol)

    try __inProtocol.readMessageEnd()

    if let __success = __result.success {
      return __success
    }
    throw NSError(
      domain: TApplicationErrorDomain, 
      code: Int(TApplicationError.MissingResult.rawValue),
      userInfo: [TApplicationErrorMethodKey: "getJobSummary"])
  }

  public func getJobSummaryWithRole(role: String) throws -> Response {

    try send_getJobSummary(role: role)

    try __outProtocol.transport().flush()

    return try recv_getJobSummary()
  }

  private func send_getTasksStatus(query query: TaskQuery) throws {

    try __outProtocol.writeMessageBeginWithName("getTasksStatus", type: .CALL, sequenceID: 0)

    let __args = ReadOnlyScheduler_getTasksStatus_args(query: query)
    try ReadOnlyScheduler_getTasksStatus_args.writeValue(__args, toProtocol: __outProtocol)

    try __outProtocol.writeMessageEnd()
  }

  private func recv_getTasksStatus() throws -> Response {

    try __inProtocol.readResultMessageBegin() 

    let __result = try ReadOnlyScheduler_getTasksStatus_result.readValueFromProtocol(__inProtocol)

    try __inProtocol.readMessageEnd()

    if let __success = __result.success {
      return __success
    }
    throw NSError(
      domain: TApplicationErrorDomain, 
      code: Int(TApplicationError.MissingResult.rawValue),
      userInfo: [TApplicationErrorMethodKey: "getTasksStatus"])
  }

  public func getTasksStatusWithQuery(query: TaskQuery) throws -> Response {

    try send_getTasksStatus(query: query)

    try __outProtocol.transport().flush()

    return try recv_getTasksStatus()
  }

  private func send_getTasksWithoutConfigs(query query: TaskQuery) throws {

    try __outProtocol.writeMessageBeginWithName("getTasksWithoutConfigs", type: .CALL, sequenceID: 0)

    let __args = ReadOnlyScheduler_getTasksWithoutConfigs_args(query: query)
    try ReadOnlyScheduler_getTasksWithoutConfigs_args.writeValue(__args, toProtocol: __outProtocol)

    try __outProtocol.writeMessageEnd()
  }

  private func recv_getTasksWithoutConfigs() throws -> Response {

    try __inProtocol.readResultMessageBegin() 

    let __result = try ReadOnlyScheduler_getTasksWithoutConfigs_result.readValueFromProtocol(__inProtocol)

    try __inProtocol.readMessageEnd()

    if let __success = __result.success {
      return __success
    }
    throw NSError(
      domain: TApplicationErrorDomain, 
      code: Int(TApplicationError.MissingResult.rawValue),
      userInfo: [TApplicationErrorMethodKey: "getTasksWithoutConfigs"])
  }

  public func getTasksWithoutConfigsWithQuery(query: TaskQuery) throws -> Response {

    try send_getTasksWithoutConfigs(query: query)

    try __outProtocol.transport().flush()

    return try recv_getTasksWithoutConfigs()
  }

  private func send_getPendingReason(query query: TaskQuery) throws {

    try __outProtocol.writeMessageBeginWithName("getPendingReason", type: .CALL, sequenceID: 0)

    let __args = ReadOnlyScheduler_getPendingReason_args(query: query)
    try ReadOnlyScheduler_getPendingReason_args.writeValue(__args, toProtocol: __outProtocol)

    try __outProtocol.writeMessageEnd()
  }

  private func recv_getPendingReason() throws -> Response {

    try __inProtocol.readResultMessageBegin() 

    let __result = try ReadOnlyScheduler_getPendingReason_result.readValueFromProtocol(__inProtocol)

    try __inProtocol.readMessageEnd()

    if let __success = __result.success {
      return __success
    }
    throw NSError(
      domain: TApplicationErrorDomain, 
      code: Int(TApplicationError.MissingResult.rawValue),
      userInfo: [TApplicationErrorMethodKey: "getPendingReason"])
  }

  public func getPendingReasonWithQuery(query: TaskQuery) throws -> Response {

    try send_getPendingReason(query: query)

    try __outProtocol.transport().flush()

    return try recv_getPendingReason()
  }

  private func send_getConfigSummary(job job: JobKey) throws {

    try __outProtocol.writeMessageBeginWithName("getConfigSummary", type: .CALL, sequenceID: 0)

    let __args = ReadOnlyScheduler_getConfigSummary_args(job: job)
    try ReadOnlyScheduler_getConfigSummary_args.writeValue(__args, toProtocol: __outProtocol)

    try __outProtocol.writeMessageEnd()
  }

  private func recv_getConfigSummary() throws -> Response {

    try __inProtocol.readResultMessageBegin() 

    let __result = try ReadOnlyScheduler_getConfigSummary_result.readValueFromProtocol(__inProtocol)

    try __inProtocol.readMessageEnd()

    if let __success = __result.success {
      return __success
    }
    throw NSError(
      domain: TApplicationErrorDomain, 
      code: Int(TApplicationError.MissingResult.rawValue),
      userInfo: [TApplicationErrorMethodKey: "getConfigSummary"])
  }

  public func getConfigSummaryWithJob(job: JobKey) throws -> Response {

    try send_getConfigSummary(job: job)

    try __outProtocol.transport().flush()

    return try recv_getConfigSummary()
  }

  private func send_getJobs(ownerRole ownerRole: String) throws {

    try __outProtocol.writeMessageBeginWithName("getJobs", type: .CALL, sequenceID: 0)

    let __args = ReadOnlyScheduler_getJobs_args(ownerRole: ownerRole)
    try ReadOnlyScheduler_getJobs_args.writeValue(__args, toProtocol: __outProtocol)

    try __outProtocol.writeMessageEnd()
  }

  private func recv_getJobs() throws -> Response {

    try __inProtocol.readResultMessageBegin() 

    let __result = try ReadOnlyScheduler_getJobs_result.readValueFromProtocol(__inProtocol)

    try __inProtocol.readMessageEnd()

    if let __success = __result.success {
      return __success
    }
    throw NSError(
      domain: TApplicationErrorDomain, 
      code: Int(TApplicationError.MissingResult.rawValue),
      userInfo: [TApplicationErrorMethodKey: "getJobs"])
  }

  public func getJobsWithOwnerRole(ownerRole: String) throws -> Response {

    try send_getJobs(ownerRole: ownerRole)

    try __outProtocol.transport().flush()

    return try recv_getJobs()
  }

  private func send_getQuota(ownerRole ownerRole: String) throws {

    try __outProtocol.writeMessageBeginWithName("getQuota", type: .CALL, sequenceID: 0)

    let __args = ReadOnlyScheduler_getQuota_args(ownerRole: ownerRole)
    try ReadOnlyScheduler_getQuota_args.writeValue(__args, toProtocol: __outProtocol)

    try __outProtocol.writeMessageEnd()
  }

  private func recv_getQuota() throws -> Response {

    try __inProtocol.readResultMessageBegin() 

    let __result = try ReadOnlyScheduler_getQuota_result.readValueFromProtocol(__inProtocol)

    try __inProtocol.readMessageEnd()

    if let __success = __result.success {
      return __success
    }
    throw NSError(
      domain: TApplicationErrorDomain, 
      code: Int(TApplicationError.MissingResult.rawValue),
      userInfo: [TApplicationErrorMethodKey: "getQuota"])
  }

  public func getQuotaWithOwnerRole(ownerRole: String) throws -> Response {

    try send_getQuota(ownerRole: ownerRole)

    try __outProtocol.transport().flush()

    return try recv_getQuota()
  }

  private func send_populateJobConfig(description description: JobConfiguration) throws {

    try __outProtocol.writeMessageBeginWithName("populateJobConfig", type: .CALL, sequenceID: 0)

    let __args = ReadOnlyScheduler_populateJobConfig_args(description: description)
    try ReadOnlyScheduler_populateJobConfig_args.writeValue(__args, toProtocol: __outProtocol)

    try __outProtocol.writeMessageEnd()
  }

  private func recv_populateJobConfig() throws -> Response {

    try __inProtocol.readResultMessageBegin() 

    let __result = try ReadOnlyScheduler_populateJobConfig_result.readValueFromProtocol(__inProtocol)

    try __inProtocol.readMessageEnd()

    if let __success = __result.success {
      return __success
    }
    throw NSError(
      domain: TApplicationErrorDomain, 
      code: Int(TApplicationError.MissingResult.rawValue),
      userInfo: [TApplicationErrorMethodKey: "populateJobConfig"])
  }

  public func populateJobConfigWithDescription(description: JobConfiguration) throws -> Response {

    try send_populateJobConfig(description: description)

    try __outProtocol.transport().flush()

    return try recv_populateJobConfig()
  }

  private func send_getLocks() throws {

    try __outProtocol.writeMessageBeginWithName("getLocks", type: .CALL, sequenceID: 0)

    let __args = ReadOnlyScheduler_getLocks_args()
    try ReadOnlyScheduler_getLocks_args.writeValue(__args, toProtocol: __outProtocol)

    try __outProtocol.writeMessageEnd()
  }

  private func recv_getLocks() throws -> Response {

    try __inProtocol.readResultMessageBegin() 

    let __result = try ReadOnlyScheduler_getLocks_result.readValueFromProtocol(__inProtocol)

    try __inProtocol.readMessageEnd()

    if let __success = __result.success {
      return __success
    }
    throw NSError(
      domain: TApplicationErrorDomain, 
      code: Int(TApplicationError.MissingResult.rawValue),
      userInfo: [TApplicationErrorMethodKey: "getLocks"])
  }

  public func getLocks() throws -> Response {

    try send_getLocks()

    try __outProtocol.transport().flush()

    return try recv_getLocks()
  }

  private func send_getJobUpdateSummaries(jobUpdateQuery jobUpdateQuery: JobUpdateQuery) throws {

    try __outProtocol.writeMessageBeginWithName("getJobUpdateSummaries", type: .CALL, sequenceID: 0)

    let __args = ReadOnlyScheduler_getJobUpdateSummaries_args(jobUpdateQuery: jobUpdateQuery)
    try ReadOnlyScheduler_getJobUpdateSummaries_args.writeValue(__args, toProtocol: __outProtocol)

    try __outProtocol.writeMessageEnd()
  }

  private func recv_getJobUpdateSummaries() throws -> Response {

    try __inProtocol.readResultMessageBegin() 

    let __result = try ReadOnlyScheduler_getJobUpdateSummaries_result.readValueFromProtocol(__inProtocol)

    try __inProtocol.readMessageEnd()

    if let __success = __result.success {
      return __success
    }
    throw NSError(
      domain: TApplicationErrorDomain, 
      code: Int(TApplicationError.MissingResult.rawValue),
      userInfo: [TApplicationErrorMethodKey: "getJobUpdateSummaries"])
  }

  public func getJobUpdateSummariesWithJobUpdateQuery(jobUpdateQuery: JobUpdateQuery) throws -> Response {

    try send_getJobUpdateSummaries(jobUpdateQuery: jobUpdateQuery)

    try __outProtocol.transport().flush()

    return try recv_getJobUpdateSummaries()
  }

  private func send_getJobUpdateDetails(key key: JobUpdateKey) throws {

    try __outProtocol.writeMessageBeginWithName("getJobUpdateDetails", type: .CALL, sequenceID: 0)

    let __args = ReadOnlyScheduler_getJobUpdateDetails_args(key: key)
    try ReadOnlyScheduler_getJobUpdateDetails_args.writeValue(__args, toProtocol: __outProtocol)

    try __outProtocol.writeMessageEnd()
  }

  private func recv_getJobUpdateDetails() throws -> Response {

    try __inProtocol.readResultMessageBegin() 

    let __result = try ReadOnlyScheduler_getJobUpdateDetails_result.readValueFromProtocol(__inProtocol)

    try __inProtocol.readMessageEnd()

    if let __success = __result.success {
      return __success
    }
    throw NSError(
      domain: TApplicationErrorDomain, 
      code: Int(TApplicationError.MissingResult.rawValue),
      userInfo: [TApplicationErrorMethodKey: "getJobUpdateDetails"])
  }

  public func getJobUpdateDetailsWithKey(key: JobUpdateKey) throws -> Response {

    try send_getJobUpdateDetails(key: key)

    try __outProtocol.transport().flush()

    return try recv_getJobUpdateDetails()
  }

}

extension ReadOnlySchedulerProcessor : TProcessor {

  static let processorHandlers : ProcessorHandlerDictionary = {

    var processorHandlers = ProcessorHandlerDictionary()

    processorHandlers["getRoleSummary"] = { sequenceID, inProtocol, outProtocol, handler in

      let args = try ReadOnlyScheduler_getRoleSummary_args.readValueFromProtocol(inProtocol)

      try inProtocol.readMessageEnd()

      var result = ReadOnlyScheduler_getRoleSummary_result()
      do {
        result.success = try handler.getRoleSummary()
      }
      catch let error {
        throw error
      }

      try outProtocol.writeMessageBeginWithName("getRoleSummary", type: .REPLY, sequenceID: sequenceID)
      try ReadOnlyScheduler_getRoleSummary_result.writeValue(result, toProtocol: outProtocol)
      try outProtocol.writeMessageEnd()
    }
    processorHandlers["getJobSummary"] = { sequenceID, inProtocol, outProtocol, handler in

      let args = try ReadOnlyScheduler_getJobSummary_args.readValueFromProtocol(inProtocol)

      try inProtocol.readMessageEnd()

      var result = ReadOnlyScheduler_getJobSummary_result()
      do {
        result.success = try handler.getJobSummaryWithRole(args.role)
      }
      catch let error {
        throw error
      }

      try outProtocol.writeMessageBeginWithName("getJobSummary", type: .REPLY, sequenceID: sequenceID)
      try ReadOnlyScheduler_getJobSummary_result.writeValue(result, toProtocol: outProtocol)
      try outProtocol.writeMessageEnd()
    }
    processorHandlers["getTasksStatus"] = { sequenceID, inProtocol, outProtocol, handler in

      let args = try ReadOnlyScheduler_getTasksStatus_args.readValueFromProtocol(inProtocol)

      try inProtocol.readMessageEnd()

      var result = ReadOnlyScheduler_getTasksStatus_result()
      do {
        result.success = try handler.getTasksStatusWithQuery(args.query)
      }
      catch let error {
        throw error
      }

      try outProtocol.writeMessageBeginWithName("getTasksStatus", type: .REPLY, sequenceID: sequenceID)
      try ReadOnlyScheduler_getTasksStatus_result.writeValue(result, toProtocol: outProtocol)
      try outProtocol.writeMessageEnd()
    }
    processorHandlers["getTasksWithoutConfigs"] = { sequenceID, inProtocol, outProtocol, handler in

      let args = try ReadOnlyScheduler_getTasksWithoutConfigs_args.readValueFromProtocol(inProtocol)

      try inProtocol.readMessageEnd()

      var result = ReadOnlyScheduler_getTasksWithoutConfigs_result()
      do {
        result.success = try handler.getTasksWithoutConfigsWithQuery(args.query)
      }
      catch let error {
        throw error
      }

      try outProtocol.writeMessageBeginWithName("getTasksWithoutConfigs", type: .REPLY, sequenceID: sequenceID)
      try ReadOnlyScheduler_getTasksWithoutConfigs_result.writeValue(result, toProtocol: outProtocol)
      try outProtocol.writeMessageEnd()
    }
    processorHandlers["getPendingReason"] = { sequenceID, inProtocol, outProtocol, handler in

      let args = try ReadOnlyScheduler_getPendingReason_args.readValueFromProtocol(inProtocol)

      try inProtocol.readMessageEnd()

      var result = ReadOnlyScheduler_getPendingReason_result()
      do {
        result.success = try handler.getPendingReasonWithQuery(args.query)
      }
      catch let error {
        throw error
      }

      try outProtocol.writeMessageBeginWithName("getPendingReason", type: .REPLY, sequenceID: sequenceID)
      try ReadOnlyScheduler_getPendingReason_result.writeValue(result, toProtocol: outProtocol)
      try outProtocol.writeMessageEnd()
    }
    processorHandlers["getConfigSummary"] = { sequenceID, inProtocol, outProtocol, handler in

      let args = try ReadOnlyScheduler_getConfigSummary_args.readValueFromProtocol(inProtocol)

      try inProtocol.readMessageEnd()

      var result = ReadOnlyScheduler_getConfigSummary_result()
      do {
        result.success = try handler.getConfigSummaryWithJob(args.job)
      }
      catch let error {
        throw error
      }

      try outProtocol.writeMessageBeginWithName("getConfigSummary", type: .REPLY, sequenceID: sequenceID)
      try ReadOnlyScheduler_getConfigSummary_result.writeValue(result, toProtocol: outProtocol)
      try outProtocol.writeMessageEnd()
    }
    processorHandlers["getJobs"] = { sequenceID, inProtocol, outProtocol, handler in

      let args = try ReadOnlyScheduler_getJobs_args.readValueFromProtocol(inProtocol)

      try inProtocol.readMessageEnd()

      var result = ReadOnlyScheduler_getJobs_result()
      do {
        result.success = try handler.getJobsWithOwnerRole(args.ownerRole)
      }
      catch let error {
        throw error
      }

      try outProtocol.writeMessageBeginWithName("getJobs", type: .REPLY, sequenceID: sequenceID)
      try ReadOnlyScheduler_getJobs_result.writeValue(result, toProtocol: outProtocol)
      try outProtocol.writeMessageEnd()
    }
    processorHandlers["getQuota"] = { sequenceID, inProtocol, outProtocol, handler in

      let args = try ReadOnlyScheduler_getQuota_args.readValueFromProtocol(inProtocol)

      try inProtocol.readMessageEnd()

      var result = ReadOnlyScheduler_getQuota_result()
      do {
        result.success = try handler.getQuotaWithOwnerRole(args.ownerRole)
      }
      catch let error {
        throw error
      }

      try outProtocol.writeMessageBeginWithName("getQuota", type: .REPLY, sequenceID: sequenceID)
      try ReadOnlyScheduler_getQuota_result.writeValue(result, toProtocol: outProtocol)
      try outProtocol.writeMessageEnd()
    }
    processorHandlers["populateJobConfig"] = { sequenceID, inProtocol, outProtocol, handler in

      let args = try ReadOnlyScheduler_populateJobConfig_args.readValueFromProtocol(inProtocol)

      try inProtocol.readMessageEnd()

      var result = ReadOnlyScheduler_populateJobConfig_result()
      do {
        result.success = try handler.populateJobConfigWithDescription(args.description)
      }
      catch let error {
        throw error
      }

      try outProtocol.writeMessageBeginWithName("populateJobConfig", type: .REPLY, sequenceID: sequenceID)
      try ReadOnlyScheduler_populateJobConfig_result.writeValue(result, toProtocol: outProtocol)
      try outProtocol.writeMessageEnd()
    }
    processorHandlers["getLocks"] = { sequenceID, inProtocol, outProtocol, handler in

      let args = try ReadOnlyScheduler_getLocks_args.readValueFromProtocol(inProtocol)

      try inProtocol.readMessageEnd()

      var result = ReadOnlyScheduler_getLocks_result()
      do {
        result.success = try handler.getLocks()
      }
      catch let error {
        throw error
      }

      try outProtocol.writeMessageBeginWithName("getLocks", type: .REPLY, sequenceID: sequenceID)
      try ReadOnlyScheduler_getLocks_result.writeValue(result, toProtocol: outProtocol)
      try outProtocol.writeMessageEnd()
    }
    processorHandlers["getJobUpdateSummaries"] = { sequenceID, inProtocol, outProtocol, handler in

      let args = try ReadOnlyScheduler_getJobUpdateSummaries_args.readValueFromProtocol(inProtocol)

      try inProtocol.readMessageEnd()

      var result = ReadOnlyScheduler_getJobUpdateSummaries_result()
      do {
        result.success = try handler.getJobUpdateSummariesWithJobUpdateQuery(args.jobUpdateQuery)
      }
      catch let error {
        throw error
      }

      try outProtocol.writeMessageBeginWithName("getJobUpdateSummaries", type: .REPLY, sequenceID: sequenceID)
      try ReadOnlyScheduler_getJobUpdateSummaries_result.writeValue(result, toProtocol: outProtocol)
      try outProtocol.writeMessageEnd()
    }
    processorHandlers["getJobUpdateDetails"] = { sequenceID, inProtocol, outProtocol, handler in

      let args = try ReadOnlyScheduler_getJobUpdateDetails_args.readValueFromProtocol(inProtocol)

      try inProtocol.readMessageEnd()

      var result = ReadOnlyScheduler_getJobUpdateDetails_result()
      do {
        result.success = try handler.getJobUpdateDetailsWithKey(args.key)
      }
      catch let error {
        throw error
      }

      try outProtocol.writeMessageBeginWithName("getJobUpdateDetails", type: .REPLY, sequenceID: sequenceID)
      try ReadOnlyScheduler_getJobUpdateDetails_result.writeValue(result, toProtocol: outProtocol)
      try outProtocol.writeMessageEnd()
    }
    return processorHandlers
  }()

  public func processOnInputProtocol(inProtocol: TProtocol, outputProtocol outProtocol: TProtocol) throws {

    let (messageName, _, sequenceID) = try inProtocol.readMessageBegin()

    if let processorHandler = ReadOnlySchedulerProcessor.processorHandlers[messageName] {
      do {
        try processorHandler(sequenceID, inProtocol, outProtocol, service)
      }
      catch let error as NSError {
        try outProtocol.writeExceptionForMessageName(messageName, sequenceID: sequenceID, ex: error)
      }
    }
    else {
      try inProtocol.skipType(.STRUCT)
      try inProtocol.readMessageEnd()
      try outProtocol.writeExceptionForMessageName(messageName,
        sequenceID: sequenceID,
        ex: NSError(
          domain: TApplicationErrorDomain, 
          code: Int(TApplicationError.UnknownMethod.rawValue), 
          userInfo: [TApplicationErrorMethodKey: messageName]))
    }
  }
}

private struct AuroraSchedulerManager_createJob_args {

  private var description = JobConfiguration()

  private var lock = Lock()

  private var session = SessionKey()

  private init() {
  }

  private init(description: JobConfiguration, lock: Lock, session: SessionKey) {
    self.description = description
    self.lock = lock
    self.session = session
  }

}

private func ==(lhs: AuroraSchedulerManager_createJob_args, rhs: AuroraSchedulerManager_createJob_args) -> Bool {
  return
    (lhs.description ?== rhs.description) &&
    (lhs.lock ?== rhs.lock) &&
    (lhs.session ?== rhs.session)
}

extension AuroraSchedulerManager_createJob_args : Hashable {

  private var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime * result + (description.hashValue)
    result = prime * result + (lock.hashValue)
    result = prime * result + (session.hashValue)
    return result
  }

}

extension AuroraSchedulerManager_createJob_args : TStruct {

  private static func readValueFromProtocol(__proto: TProtocol) throws -> AuroraSchedulerManager_createJob_args {

    try __proto.readStructBegin()

    var description : JobConfiguration!
    var lock : Lock!
    var session : SessionKey!

    fields: while true {

      let (_, fieldType, fieldID) = try __proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .STOP):
          break fields

        case (1, .STRUCT):
          description = try __proto.readValue() as JobConfiguration

        case (3, .STRUCT):
          lock = try __proto.readValue() as Lock

        case (2, .STRUCT):
          session = try __proto.readValue() as SessionKey

        case let (_, unknownType):
          try __proto.skipType(unknownType)
      }

      try __proto.readFieldEnd()
    }

    try __proto.readStructEnd()

    // Required fields
    try __proto.validateValue(description, named: "description")
    try __proto.validateValue(lock, named: "lock")
    try __proto.validateValue(session, named: "session")

    return AuroraSchedulerManager_createJob_args(description: description, lock: lock, session: session)
  }

  private static func writeValue(__value: AuroraSchedulerManager_createJob_args, toProtocol __proto: TProtocol) throws {

    try __proto.writeStructBeginWithName("AuroraSchedulerManager_createJob_args")

    try __proto.writeFieldValue(__value.description, name: "description", type: .STRUCT, id: 1)

    try __proto.writeFieldValue(__value.lock, name: "lock", type: .STRUCT, id: 3)

    try __proto.writeFieldValue(__value.session, name: "session", type: .STRUCT, id: 2)

    try __proto.writeFieldStop()

    try __proto.writeStructEnd()
  }

}



private struct AuroraSchedulerManager_createJob_result {

  private var success : Response?

  private init() {
  }

  private init(success: Response?) {
    self.success = success
  }

}

private func ==(lhs: AuroraSchedulerManager_createJob_result, rhs: AuroraSchedulerManager_createJob_result) -> Bool {
  return
    (lhs.success ?== rhs.success)
}

extension AuroraSchedulerManager_createJob_result : Hashable {

  private var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime * result + (success?.hashValue ?? 0)
    return result
  }

}

extension AuroraSchedulerManager_createJob_result : TStruct {

  private static func readValueFromProtocol(__proto: TProtocol) throws -> AuroraSchedulerManager_createJob_result {

    try __proto.readStructBegin()

    var success : Response?

    fields: while true {

      let (_, fieldType, fieldID) = try __proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .STOP):
          break fields

        case (0, .STRUCT):
          success = try __proto.readValue() as Response

        case let (_, unknownType):
          try __proto.skipType(unknownType)
      }

      try __proto.readFieldEnd()
    }

    try __proto.readStructEnd()


    return AuroraSchedulerManager_createJob_result(success: success)
  }

  private static func writeValue(__value: AuroraSchedulerManager_createJob_result, toProtocol __proto: TProtocol) throws {

    try __proto.writeStructBeginWithName("AuroraSchedulerManager_createJob_result")

    if let result = __value.success {
      try __proto.writeFieldValue(result, name: "success", type: .STRUCT, id: 0)
    }
    try __proto.writeFieldStop()

    try __proto.writeStructEnd()
  }

}



private struct AuroraSchedulerManager_scheduleCronJob_args {

  private var description = JobConfiguration()

  private var lock = Lock()

  private var session = SessionKey()

  private init() {
  }

  private init(description: JobConfiguration, lock: Lock, session: SessionKey) {
    self.description = description
    self.lock = lock
    self.session = session
  }

}

private func ==(lhs: AuroraSchedulerManager_scheduleCronJob_args, rhs: AuroraSchedulerManager_scheduleCronJob_args) -> Bool {
  return
    (lhs.description ?== rhs.description) &&
    (lhs.lock ?== rhs.lock) &&
    (lhs.session ?== rhs.session)
}

extension AuroraSchedulerManager_scheduleCronJob_args : Hashable {

  private var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime * result + (description.hashValue)
    result = prime * result + (lock.hashValue)
    result = prime * result + (session.hashValue)
    return result
  }

}

extension AuroraSchedulerManager_scheduleCronJob_args : TStruct {

  private static func readValueFromProtocol(__proto: TProtocol) throws -> AuroraSchedulerManager_scheduleCronJob_args {

    try __proto.readStructBegin()

    var description : JobConfiguration!
    var lock : Lock!
    var session : SessionKey!

    fields: while true {

      let (_, fieldType, fieldID) = try __proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .STOP):
          break fields

        case (1, .STRUCT):
          description = try __proto.readValue() as JobConfiguration

        case (3, .STRUCT):
          lock = try __proto.readValue() as Lock

        case (2, .STRUCT):
          session = try __proto.readValue() as SessionKey

        case let (_, unknownType):
          try __proto.skipType(unknownType)
      }

      try __proto.readFieldEnd()
    }

    try __proto.readStructEnd()

    // Required fields
    try __proto.validateValue(description, named: "description")
    try __proto.validateValue(lock, named: "lock")
    try __proto.validateValue(session, named: "session")

    return AuroraSchedulerManager_scheduleCronJob_args(description: description, lock: lock, session: session)
  }

  private static func writeValue(__value: AuroraSchedulerManager_scheduleCronJob_args, toProtocol __proto: TProtocol) throws {

    try __proto.writeStructBeginWithName("AuroraSchedulerManager_scheduleCronJob_args")

    try __proto.writeFieldValue(__value.description, name: "description", type: .STRUCT, id: 1)

    try __proto.writeFieldValue(__value.lock, name: "lock", type: .STRUCT, id: 3)

    try __proto.writeFieldValue(__value.session, name: "session", type: .STRUCT, id: 2)

    try __proto.writeFieldStop()

    try __proto.writeStructEnd()
  }

}



private struct AuroraSchedulerManager_scheduleCronJob_result {

  private var success : Response?

  private init() {
  }

  private init(success: Response?) {
    self.success = success
  }

}

private func ==(lhs: AuroraSchedulerManager_scheduleCronJob_result, rhs: AuroraSchedulerManager_scheduleCronJob_result) -> Bool {
  return
    (lhs.success ?== rhs.success)
}

extension AuroraSchedulerManager_scheduleCronJob_result : Hashable {

  private var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime * result + (success?.hashValue ?? 0)
    return result
  }

}

extension AuroraSchedulerManager_scheduleCronJob_result : TStruct {

  private static func readValueFromProtocol(__proto: TProtocol) throws -> AuroraSchedulerManager_scheduleCronJob_result {

    try __proto.readStructBegin()

    var success : Response?

    fields: while true {

      let (_, fieldType, fieldID) = try __proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .STOP):
          break fields

        case (0, .STRUCT):
          success = try __proto.readValue() as Response

        case let (_, unknownType):
          try __proto.skipType(unknownType)
      }

      try __proto.readFieldEnd()
    }

    try __proto.readStructEnd()


    return AuroraSchedulerManager_scheduleCronJob_result(success: success)
  }

  private static func writeValue(__value: AuroraSchedulerManager_scheduleCronJob_result, toProtocol __proto: TProtocol) throws {

    try __proto.writeStructBeginWithName("AuroraSchedulerManager_scheduleCronJob_result")

    if let result = __value.success {
      try __proto.writeFieldValue(result, name: "success", type: .STRUCT, id: 0)
    }
    try __proto.writeFieldStop()

    try __proto.writeStructEnd()
  }

}



private struct AuroraSchedulerManager_descheduleCronJob_args {

  private var job = JobKey()

  private var lock = Lock()

  private var session = SessionKey()

  private init() {
  }

  private init(job: JobKey, lock: Lock, session: SessionKey) {
    self.job = job
    self.lock = lock
    self.session = session
  }

}

private func ==(lhs: AuroraSchedulerManager_descheduleCronJob_args, rhs: AuroraSchedulerManager_descheduleCronJob_args) -> Bool {
  return
    (lhs.job ?== rhs.job) &&
    (lhs.lock ?== rhs.lock) &&
    (lhs.session ?== rhs.session)
}

extension AuroraSchedulerManager_descheduleCronJob_args : Hashable {

  private var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime * result + (job.hashValue)
    result = prime * result + (lock.hashValue)
    result = prime * result + (session.hashValue)
    return result
  }

}

extension AuroraSchedulerManager_descheduleCronJob_args : TStruct {

  private static func readValueFromProtocol(__proto: TProtocol) throws -> AuroraSchedulerManager_descheduleCronJob_args {

    try __proto.readStructBegin()

    var job : JobKey!
    var lock : Lock!
    var session : SessionKey!

    fields: while true {

      let (_, fieldType, fieldID) = try __proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .STOP):
          break fields

        case (4, .STRUCT):
          job = try __proto.readValue() as JobKey

        case (3, .STRUCT):
          lock = try __proto.readValue() as Lock

        case (2, .STRUCT):
          session = try __proto.readValue() as SessionKey

        case let (_, unknownType):
          try __proto.skipType(unknownType)
      }

      try __proto.readFieldEnd()
    }

    try __proto.readStructEnd()

    // Required fields
    try __proto.validateValue(job, named: "job")
    try __proto.validateValue(lock, named: "lock")
    try __proto.validateValue(session, named: "session")

    return AuroraSchedulerManager_descheduleCronJob_args(job: job, lock: lock, session: session)
  }

  private static func writeValue(__value: AuroraSchedulerManager_descheduleCronJob_args, toProtocol __proto: TProtocol) throws {

    try __proto.writeStructBeginWithName("AuroraSchedulerManager_descheduleCronJob_args")

    try __proto.writeFieldValue(__value.job, name: "job", type: .STRUCT, id: 4)

    try __proto.writeFieldValue(__value.lock, name: "lock", type: .STRUCT, id: 3)

    try __proto.writeFieldValue(__value.session, name: "session", type: .STRUCT, id: 2)

    try __proto.writeFieldStop()

    try __proto.writeStructEnd()
  }

}



private struct AuroraSchedulerManager_descheduleCronJob_result {

  private var success : Response?

  private init() {
  }

  private init(success: Response?) {
    self.success = success
  }

}

private func ==(lhs: AuroraSchedulerManager_descheduleCronJob_result, rhs: AuroraSchedulerManager_descheduleCronJob_result) -> Bool {
  return
    (lhs.success ?== rhs.success)
}

extension AuroraSchedulerManager_descheduleCronJob_result : Hashable {

  private var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime * result + (success?.hashValue ?? 0)
    return result
  }

}

extension AuroraSchedulerManager_descheduleCronJob_result : TStruct {

  private static func readValueFromProtocol(__proto: TProtocol) throws -> AuroraSchedulerManager_descheduleCronJob_result {

    try __proto.readStructBegin()

    var success : Response?

    fields: while true {

      let (_, fieldType, fieldID) = try __proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .STOP):
          break fields

        case (0, .STRUCT):
          success = try __proto.readValue() as Response

        case let (_, unknownType):
          try __proto.skipType(unknownType)
      }

      try __proto.readFieldEnd()
    }

    try __proto.readStructEnd()


    return AuroraSchedulerManager_descheduleCronJob_result(success: success)
  }

  private static func writeValue(__value: AuroraSchedulerManager_descheduleCronJob_result, toProtocol __proto: TProtocol) throws {

    try __proto.writeStructBeginWithName("AuroraSchedulerManager_descheduleCronJob_result")

    if let result = __value.success {
      try __proto.writeFieldValue(result, name: "success", type: .STRUCT, id: 0)
    }
    try __proto.writeFieldStop()

    try __proto.writeStructEnd()
  }

}



private struct AuroraSchedulerManager_startCronJob_args {

  private var job = JobKey()

  private var session = SessionKey()

  private init() {
  }

  private init(job: JobKey, session: SessionKey) {
    self.job = job
    self.session = session
  }

}

private func ==(lhs: AuroraSchedulerManager_startCronJob_args, rhs: AuroraSchedulerManager_startCronJob_args) -> Bool {
  return
    (lhs.job ?== rhs.job) &&
    (lhs.session ?== rhs.session)
}

extension AuroraSchedulerManager_startCronJob_args : Hashable {

  private var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime * result + (job.hashValue)
    result = prime * result + (session.hashValue)
    return result
  }

}

extension AuroraSchedulerManager_startCronJob_args : TStruct {

  private static func readValueFromProtocol(__proto: TProtocol) throws -> AuroraSchedulerManager_startCronJob_args {

    try __proto.readStructBegin()

    var job : JobKey!
    var session : SessionKey!

    fields: while true {

      let (_, fieldType, fieldID) = try __proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .STOP):
          break fields

        case (4, .STRUCT):
          job = try __proto.readValue() as JobKey

        case (3, .STRUCT):
          session = try __proto.readValue() as SessionKey

        case let (_, unknownType):
          try __proto.skipType(unknownType)
      }

      try __proto.readFieldEnd()
    }

    try __proto.readStructEnd()

    // Required fields
    try __proto.validateValue(job, named: "job")
    try __proto.validateValue(session, named: "session")

    return AuroraSchedulerManager_startCronJob_args(job: job, session: session)
  }

  private static func writeValue(__value: AuroraSchedulerManager_startCronJob_args, toProtocol __proto: TProtocol) throws {

    try __proto.writeStructBeginWithName("AuroraSchedulerManager_startCronJob_args")

    try __proto.writeFieldValue(__value.job, name: "job", type: .STRUCT, id: 4)

    try __proto.writeFieldValue(__value.session, name: "session", type: .STRUCT, id: 3)

    try __proto.writeFieldStop()

    try __proto.writeStructEnd()
  }

}



private struct AuroraSchedulerManager_startCronJob_result {

  private var success : Response?

  private init() {
  }

  private init(success: Response?) {
    self.success = success
  }

}

private func ==(lhs: AuroraSchedulerManager_startCronJob_result, rhs: AuroraSchedulerManager_startCronJob_result) -> Bool {
  return
    (lhs.success ?== rhs.success)
}

extension AuroraSchedulerManager_startCronJob_result : Hashable {

  private var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime * result + (success?.hashValue ?? 0)
    return result
  }

}

extension AuroraSchedulerManager_startCronJob_result : TStruct {

  private static func readValueFromProtocol(__proto: TProtocol) throws -> AuroraSchedulerManager_startCronJob_result {

    try __proto.readStructBegin()

    var success : Response?

    fields: while true {

      let (_, fieldType, fieldID) = try __proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .STOP):
          break fields

        case (0, .STRUCT):
          success = try __proto.readValue() as Response

        case let (_, unknownType):
          try __proto.skipType(unknownType)
      }

      try __proto.readFieldEnd()
    }

    try __proto.readStructEnd()


    return AuroraSchedulerManager_startCronJob_result(success: success)
  }

  private static func writeValue(__value: AuroraSchedulerManager_startCronJob_result, toProtocol __proto: TProtocol) throws {

    try __proto.writeStructBeginWithName("AuroraSchedulerManager_startCronJob_result")

    if let result = __value.success {
      try __proto.writeFieldValue(result, name: "success", type: .STRUCT, id: 0)
    }
    try __proto.writeFieldStop()

    try __proto.writeStructEnd()
  }

}



private struct AuroraSchedulerManager_restartShards_args {

  private var job = JobKey()

  private var shardIds = TSet<Int32>()

  private var lock = Lock()

  private var session = SessionKey()

  private init() {
  }

  private init(job: JobKey, shardIds: TSet<Int32>, lock: Lock, session: SessionKey) {
    self.job = job
    self.shardIds = shardIds
    self.lock = lock
    self.session = session
  }

}

private func ==(lhs: AuroraSchedulerManager_restartShards_args, rhs: AuroraSchedulerManager_restartShards_args) -> Bool {
  return
    (lhs.job ?== rhs.job) &&
    (lhs.shardIds ?== rhs.shardIds) &&
    (lhs.lock ?== rhs.lock) &&
    (lhs.session ?== rhs.session)
}

extension AuroraSchedulerManager_restartShards_args : Hashable {

  private var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime * result + (job.hashValue)
    result = prime * result + (shardIds.hashValue)
    result = prime * result + (lock.hashValue)
    result = prime * result + (session.hashValue)
    return result
  }

}

extension AuroraSchedulerManager_restartShards_args : TStruct {

  private static func readValueFromProtocol(__proto: TProtocol) throws -> AuroraSchedulerManager_restartShards_args {

    try __proto.readStructBegin()

    var job : JobKey!
    var shardIds : TSet<Int32>!
    var lock : Lock!
    var session : SessionKey!

    fields: while true {

      let (_, fieldType, fieldID) = try __proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .STOP):
          break fields

        case (5, .STRUCT):
          job = try __proto.readValue() as JobKey

        case (3, .SET):
          shardIds = try __proto.readValue() as TSet<Int32>

        case (6, .STRUCT):
          lock = try __proto.readValue() as Lock

        case (4, .STRUCT):
          session = try __proto.readValue() as SessionKey

        case let (_, unknownType):
          try __proto.skipType(unknownType)
      }

      try __proto.readFieldEnd()
    }

    try __proto.readStructEnd()

    // Required fields
    try __proto.validateValue(job, named: "job")
    try __proto.validateValue(shardIds, named: "shardIds")
    try __proto.validateValue(lock, named: "lock")
    try __proto.validateValue(session, named: "session")

    return AuroraSchedulerManager_restartShards_args(job: job, shardIds: shardIds, lock: lock, session: session)
  }

  private static func writeValue(__value: AuroraSchedulerManager_restartShards_args, toProtocol __proto: TProtocol) throws {

    try __proto.writeStructBeginWithName("AuroraSchedulerManager_restartShards_args")

    try __proto.writeFieldValue(__value.job, name: "job", type: .STRUCT, id: 5)

    try __proto.writeFieldValue(__value.shardIds, name: "shardIds", type: .SET, id: 3)

    try __proto.writeFieldValue(__value.lock, name: "lock", type: .STRUCT, id: 6)

    try __proto.writeFieldValue(__value.session, name: "session", type: .STRUCT, id: 4)

    try __proto.writeFieldStop()

    try __proto.writeStructEnd()
  }

}



private struct AuroraSchedulerManager_restartShards_result {

  private var success : Response?

  private init() {
  }

  private init(success: Response?) {
    self.success = success
  }

}

private func ==(lhs: AuroraSchedulerManager_restartShards_result, rhs: AuroraSchedulerManager_restartShards_result) -> Bool {
  return
    (lhs.success ?== rhs.success)
}

extension AuroraSchedulerManager_restartShards_result : Hashable {

  private var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime * result + (success?.hashValue ?? 0)
    return result
  }

}

extension AuroraSchedulerManager_restartShards_result : TStruct {

  private static func readValueFromProtocol(__proto: TProtocol) throws -> AuroraSchedulerManager_restartShards_result {

    try __proto.readStructBegin()

    var success : Response?

    fields: while true {

      let (_, fieldType, fieldID) = try __proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .STOP):
          break fields

        case (0, .STRUCT):
          success = try __proto.readValue() as Response

        case let (_, unknownType):
          try __proto.skipType(unknownType)
      }

      try __proto.readFieldEnd()
    }

    try __proto.readStructEnd()


    return AuroraSchedulerManager_restartShards_result(success: success)
  }

  private static func writeValue(__value: AuroraSchedulerManager_restartShards_result, toProtocol __proto: TProtocol) throws {

    try __proto.writeStructBeginWithName("AuroraSchedulerManager_restartShards_result")

    if let result = __value.success {
      try __proto.writeFieldValue(result, name: "success", type: .STRUCT, id: 0)
    }
    try __proto.writeFieldStop()

    try __proto.writeStructEnd()
  }

}



private struct AuroraSchedulerManager_killTasks_args {

  private var query = TaskQuery()

  private var lock = Lock()

  private var session = SessionKey()

  private init() {
  }

  private init(query: TaskQuery, lock: Lock, session: SessionKey) {
    self.query = query
    self.lock = lock
    self.session = session
  }

}

private func ==(lhs: AuroraSchedulerManager_killTasks_args, rhs: AuroraSchedulerManager_killTasks_args) -> Bool {
  return
    (lhs.query ?== rhs.query) &&
    (lhs.lock ?== rhs.lock) &&
    (lhs.session ?== rhs.session)
}

extension AuroraSchedulerManager_killTasks_args : Hashable {

  private var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime * result + (query.hashValue)
    result = prime * result + (lock.hashValue)
    result = prime * result + (session.hashValue)
    return result
  }

}

extension AuroraSchedulerManager_killTasks_args : TStruct {

  private static func readValueFromProtocol(__proto: TProtocol) throws -> AuroraSchedulerManager_killTasks_args {

    try __proto.readStructBegin()

    var query : TaskQuery!
    var lock : Lock!
    var session : SessionKey!

    fields: while true {

      let (_, fieldType, fieldID) = try __proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .STOP):
          break fields

        case (1, .STRUCT):
          query = try __proto.readValue() as TaskQuery

        case (3, .STRUCT):
          lock = try __proto.readValue() as Lock

        case (2, .STRUCT):
          session = try __proto.readValue() as SessionKey

        case let (_, unknownType):
          try __proto.skipType(unknownType)
      }

      try __proto.readFieldEnd()
    }

    try __proto.readStructEnd()

    // Required fields
    try __proto.validateValue(query, named: "query")
    try __proto.validateValue(lock, named: "lock")
    try __proto.validateValue(session, named: "session")

    return AuroraSchedulerManager_killTasks_args(query: query, lock: lock, session: session)
  }

  private static func writeValue(__value: AuroraSchedulerManager_killTasks_args, toProtocol __proto: TProtocol) throws {

    try __proto.writeStructBeginWithName("AuroraSchedulerManager_killTasks_args")

    try __proto.writeFieldValue(__value.query, name: "query", type: .STRUCT, id: 1)

    try __proto.writeFieldValue(__value.lock, name: "lock", type: .STRUCT, id: 3)

    try __proto.writeFieldValue(__value.session, name: "session", type: .STRUCT, id: 2)

    try __proto.writeFieldStop()

    try __proto.writeStructEnd()
  }

}



private struct AuroraSchedulerManager_killTasks_result {

  private var success : Response?

  private init() {
  }

  private init(success: Response?) {
    self.success = success
  }

}

private func ==(lhs: AuroraSchedulerManager_killTasks_result, rhs: AuroraSchedulerManager_killTasks_result) -> Bool {
  return
    (lhs.success ?== rhs.success)
}

extension AuroraSchedulerManager_killTasks_result : Hashable {

  private var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime * result + (success?.hashValue ?? 0)
    return result
  }

}

extension AuroraSchedulerManager_killTasks_result : TStruct {

  private static func readValueFromProtocol(__proto: TProtocol) throws -> AuroraSchedulerManager_killTasks_result {

    try __proto.readStructBegin()

    var success : Response?

    fields: while true {

      let (_, fieldType, fieldID) = try __proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .STOP):
          break fields

        case (0, .STRUCT):
          success = try __proto.readValue() as Response

        case let (_, unknownType):
          try __proto.skipType(unknownType)
      }

      try __proto.readFieldEnd()
    }

    try __proto.readStructEnd()


    return AuroraSchedulerManager_killTasks_result(success: success)
  }

  private static func writeValue(__value: AuroraSchedulerManager_killTasks_result, toProtocol __proto: TProtocol) throws {

    try __proto.writeStructBeginWithName("AuroraSchedulerManager_killTasks_result")

    if let result = __value.success {
      try __proto.writeFieldValue(result, name: "success", type: .STRUCT, id: 0)
    }
    try __proto.writeFieldStop()

    try __proto.writeStructEnd()
  }

}



private struct AuroraSchedulerManager_addInstances_args {

  private var config = AddInstancesConfig()

  private var lock = Lock()

  private var session = SessionKey()

  private init() {
  }

  private init(config: AddInstancesConfig, lock: Lock, session: SessionKey) {
    self.config = config
    self.lock = lock
    self.session = session
  }

}

private func ==(lhs: AuroraSchedulerManager_addInstances_args, rhs: AuroraSchedulerManager_addInstances_args) -> Bool {
  return
    (lhs.config ?== rhs.config) &&
    (lhs.lock ?== rhs.lock) &&
    (lhs.session ?== rhs.session)
}

extension AuroraSchedulerManager_addInstances_args : Hashable {

  private var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime * result + (config.hashValue)
    result = prime * result + (lock.hashValue)
    result = prime * result + (session.hashValue)
    return result
  }

}

extension AuroraSchedulerManager_addInstances_args : TStruct {

  private static func readValueFromProtocol(__proto: TProtocol) throws -> AuroraSchedulerManager_addInstances_args {

    try __proto.readStructBegin()

    var config : AddInstancesConfig!
    var lock : Lock!
    var session : SessionKey!

    fields: while true {

      let (_, fieldType, fieldID) = try __proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .STOP):
          break fields

        case (1, .STRUCT):
          config = try __proto.readValue() as AddInstancesConfig

        case (2, .STRUCT):
          lock = try __proto.readValue() as Lock

        case (3, .STRUCT):
          session = try __proto.readValue() as SessionKey

        case let (_, unknownType):
          try __proto.skipType(unknownType)
      }

      try __proto.readFieldEnd()
    }

    try __proto.readStructEnd()

    // Required fields
    try __proto.validateValue(config, named: "config")
    try __proto.validateValue(lock, named: "lock")
    try __proto.validateValue(session, named: "session")

    return AuroraSchedulerManager_addInstances_args(config: config, lock: lock, session: session)
  }

  private static func writeValue(__value: AuroraSchedulerManager_addInstances_args, toProtocol __proto: TProtocol) throws {

    try __proto.writeStructBeginWithName("AuroraSchedulerManager_addInstances_args")

    try __proto.writeFieldValue(__value.config, name: "config", type: .STRUCT, id: 1)

    try __proto.writeFieldValue(__value.lock, name: "lock", type: .STRUCT, id: 2)

    try __proto.writeFieldValue(__value.session, name: "session", type: .STRUCT, id: 3)

    try __proto.writeFieldStop()

    try __proto.writeStructEnd()
  }

}



private struct AuroraSchedulerManager_addInstances_result {

  private var success : Response?

  private init() {
  }

  private init(success: Response?) {
    self.success = success
  }

}

private func ==(lhs: AuroraSchedulerManager_addInstances_result, rhs: AuroraSchedulerManager_addInstances_result) -> Bool {
  return
    (lhs.success ?== rhs.success)
}

extension AuroraSchedulerManager_addInstances_result : Hashable {

  private var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime * result + (success?.hashValue ?? 0)
    return result
  }

}

extension AuroraSchedulerManager_addInstances_result : TStruct {

  private static func readValueFromProtocol(__proto: TProtocol) throws -> AuroraSchedulerManager_addInstances_result {

    try __proto.readStructBegin()

    var success : Response?

    fields: while true {

      let (_, fieldType, fieldID) = try __proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .STOP):
          break fields

        case (0, .STRUCT):
          success = try __proto.readValue() as Response

        case let (_, unknownType):
          try __proto.skipType(unknownType)
      }

      try __proto.readFieldEnd()
    }

    try __proto.readStructEnd()


    return AuroraSchedulerManager_addInstances_result(success: success)
  }

  private static func writeValue(__value: AuroraSchedulerManager_addInstances_result, toProtocol __proto: TProtocol) throws {

    try __proto.writeStructBeginWithName("AuroraSchedulerManager_addInstances_result")

    if let result = __value.success {
      try __proto.writeFieldValue(result, name: "success", type: .STRUCT, id: 0)
    }
    try __proto.writeFieldStop()

    try __proto.writeStructEnd()
  }

}



private struct AuroraSchedulerManager_acquireLock_args {

  private var lockKey = LockKey()

  private var session = SessionKey()

  private init() {
  }

  private init(lockKey: LockKey, session: SessionKey) {
    self.lockKey = lockKey
    self.session = session
  }

}

private func ==(lhs: AuroraSchedulerManager_acquireLock_args, rhs: AuroraSchedulerManager_acquireLock_args) -> Bool {
  return
    (lhs.lockKey ?== rhs.lockKey) &&
    (lhs.session ?== rhs.session)
}

extension AuroraSchedulerManager_acquireLock_args : Hashable {

  private var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime * result + (lockKey.hashValue)
    result = prime * result + (session.hashValue)
    return result
  }

}

extension AuroraSchedulerManager_acquireLock_args : TStruct {

  private static func readValueFromProtocol(__proto: TProtocol) throws -> AuroraSchedulerManager_acquireLock_args {

    try __proto.readStructBegin()

    var lockKey : LockKey!
    var session : SessionKey!

    fields: while true {

      let (_, fieldType, fieldID) = try __proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .STOP):
          break fields

        case (1, .STRUCT):
          lockKey = try __proto.readValue() as LockKey

        case (2, .STRUCT):
          session = try __proto.readValue() as SessionKey

        case let (_, unknownType):
          try __proto.skipType(unknownType)
      }

      try __proto.readFieldEnd()
    }

    try __proto.readStructEnd()

    // Required fields
    try __proto.validateValue(lockKey, named: "lockKey")
    try __proto.validateValue(session, named: "session")

    return AuroraSchedulerManager_acquireLock_args(lockKey: lockKey, session: session)
  }

  private static func writeValue(__value: AuroraSchedulerManager_acquireLock_args, toProtocol __proto: TProtocol) throws {

    try __proto.writeStructBeginWithName("AuroraSchedulerManager_acquireLock_args")

    try __proto.writeFieldValue(__value.lockKey, name: "lockKey", type: .STRUCT, id: 1)

    try __proto.writeFieldValue(__value.session, name: "session", type: .STRUCT, id: 2)

    try __proto.writeFieldStop()

    try __proto.writeStructEnd()
  }

}



private struct AuroraSchedulerManager_acquireLock_result {

  private var success : Response?

  private init() {
  }

  private init(success: Response?) {
    self.success = success
  }

}

private func ==(lhs: AuroraSchedulerManager_acquireLock_result, rhs: AuroraSchedulerManager_acquireLock_result) -> Bool {
  return
    (lhs.success ?== rhs.success)
}

extension AuroraSchedulerManager_acquireLock_result : Hashable {

  private var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime * result + (success?.hashValue ?? 0)
    return result
  }

}

extension AuroraSchedulerManager_acquireLock_result : TStruct {

  private static func readValueFromProtocol(__proto: TProtocol) throws -> AuroraSchedulerManager_acquireLock_result {

    try __proto.readStructBegin()

    var success : Response?

    fields: while true {

      let (_, fieldType, fieldID) = try __proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .STOP):
          break fields

        case (0, .STRUCT):
          success = try __proto.readValue() as Response

        case let (_, unknownType):
          try __proto.skipType(unknownType)
      }

      try __proto.readFieldEnd()
    }

    try __proto.readStructEnd()


    return AuroraSchedulerManager_acquireLock_result(success: success)
  }

  private static func writeValue(__value: AuroraSchedulerManager_acquireLock_result, toProtocol __proto: TProtocol) throws {

    try __proto.writeStructBeginWithName("AuroraSchedulerManager_acquireLock_result")

    if let result = __value.success {
      try __proto.writeFieldValue(result, name: "success", type: .STRUCT, id: 0)
    }
    try __proto.writeFieldStop()

    try __proto.writeStructEnd()
  }

}



private struct AuroraSchedulerManager_releaseLock_args {

  private var lock = Lock()

  private var validation = LockValidation()

  private var session = SessionKey()

  private init() {
  }

  private init(lock: Lock, validation: LockValidation, session: SessionKey) {
    self.lock = lock
    self.validation = validation
    self.session = session
  }

}

private func ==(lhs: AuroraSchedulerManager_releaseLock_args, rhs: AuroraSchedulerManager_releaseLock_args) -> Bool {
  return
    (lhs.lock ?== rhs.lock) &&
    (lhs.validation ?== rhs.validation) &&
    (lhs.session ?== rhs.session)
}

extension AuroraSchedulerManager_releaseLock_args : Hashable {

  private var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime * result + (lock.hashValue)
    result = prime * result + (validation.hashValue)
    result = prime * result + (session.hashValue)
    return result
  }

}

extension AuroraSchedulerManager_releaseLock_args : TStruct {

  private static func readValueFromProtocol(__proto: TProtocol) throws -> AuroraSchedulerManager_releaseLock_args {

    try __proto.readStructBegin()

    var lock : Lock!
    var validation : LockValidation!
    var session : SessionKey!

    fields: while true {

      let (_, fieldType, fieldID) = try __proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .STOP):
          break fields

        case (1, .STRUCT):
          lock = try __proto.readValue() as Lock

        case (2, .I32):
          validation = try __proto.readValue() as LockValidation

        case (3, .STRUCT):
          session = try __proto.readValue() as SessionKey

        case let (_, unknownType):
          try __proto.skipType(unknownType)
      }

      try __proto.readFieldEnd()
    }

    try __proto.readStructEnd()

    // Required fields
    try __proto.validateValue(lock, named: "lock")
    try __proto.validateValue(validation, named: "validation")
    try __proto.validateValue(session, named: "session")

    return AuroraSchedulerManager_releaseLock_args(lock: lock, validation: validation, session: session)
  }

  private static func writeValue(__value: AuroraSchedulerManager_releaseLock_args, toProtocol __proto: TProtocol) throws {

    try __proto.writeStructBeginWithName("AuroraSchedulerManager_releaseLock_args")

    try __proto.writeFieldValue(__value.lock, name: "lock", type: .STRUCT, id: 1)

    try __proto.writeFieldValue(__value.validation, name: "validation", type: .I32, id: 2)

    try __proto.writeFieldValue(__value.session, name: "session", type: .STRUCT, id: 3)

    try __proto.writeFieldStop()

    try __proto.writeStructEnd()
  }

}



private struct AuroraSchedulerManager_releaseLock_result {

  private var success : Response?

  private init() {
  }

  private init(success: Response?) {
    self.success = success
  }

}

private func ==(lhs: AuroraSchedulerManager_releaseLock_result, rhs: AuroraSchedulerManager_releaseLock_result) -> Bool {
  return
    (lhs.success ?== rhs.success)
}

extension AuroraSchedulerManager_releaseLock_result : Hashable {

  private var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime * result + (success?.hashValue ?? 0)
    return result
  }

}

extension AuroraSchedulerManager_releaseLock_result : TStruct {

  private static func readValueFromProtocol(__proto: TProtocol) throws -> AuroraSchedulerManager_releaseLock_result {

    try __proto.readStructBegin()

    var success : Response?

    fields: while true {

      let (_, fieldType, fieldID) = try __proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .STOP):
          break fields

        case (0, .STRUCT):
          success = try __proto.readValue() as Response

        case let (_, unknownType):
          try __proto.skipType(unknownType)
      }

      try __proto.readFieldEnd()
    }

    try __proto.readStructEnd()


    return AuroraSchedulerManager_releaseLock_result(success: success)
  }

  private static func writeValue(__value: AuroraSchedulerManager_releaseLock_result, toProtocol __proto: TProtocol) throws {

    try __proto.writeStructBeginWithName("AuroraSchedulerManager_releaseLock_result")

    if let result = __value.success {
      try __proto.writeFieldValue(result, name: "success", type: .STRUCT, id: 0)
    }
    try __proto.writeFieldStop()

    try __proto.writeStructEnd()
  }

}



private struct AuroraSchedulerManager_replaceCronTemplate_args {

  private var config = JobConfiguration()

  private var lock = Lock()

  private var session = SessionKey()

  private init() {
  }

  private init(config: JobConfiguration, lock: Lock, session: SessionKey) {
    self.config = config
    self.lock = lock
    self.session = session
  }

}

private func ==(lhs: AuroraSchedulerManager_replaceCronTemplate_args, rhs: AuroraSchedulerManager_replaceCronTemplate_args) -> Bool {
  return
    (lhs.config ?== rhs.config) &&
    (lhs.lock ?== rhs.lock) &&
    (lhs.session ?== rhs.session)
}

extension AuroraSchedulerManager_replaceCronTemplate_args : Hashable {

  private var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime * result + (config.hashValue)
    result = prime * result + (lock.hashValue)
    result = prime * result + (session.hashValue)
    return result
  }

}

extension AuroraSchedulerManager_replaceCronTemplate_args : TStruct {

  private static func readValueFromProtocol(__proto: TProtocol) throws -> AuroraSchedulerManager_replaceCronTemplate_args {

    try __proto.readStructBegin()

    var config : JobConfiguration!
    var lock : Lock!
    var session : SessionKey!

    fields: while true {

      let (_, fieldType, fieldID) = try __proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .STOP):
          break fields

        case (1, .STRUCT):
          config = try __proto.readValue() as JobConfiguration

        case (2, .STRUCT):
          lock = try __proto.readValue() as Lock

        case (3, .STRUCT):
          session = try __proto.readValue() as SessionKey

        case let (_, unknownType):
          try __proto.skipType(unknownType)
      }

      try __proto.readFieldEnd()
    }

    try __proto.readStructEnd()

    // Required fields
    try __proto.validateValue(config, named: "config")
    try __proto.validateValue(lock, named: "lock")
    try __proto.validateValue(session, named: "session")

    return AuroraSchedulerManager_replaceCronTemplate_args(config: config, lock: lock, session: session)
  }

  private static func writeValue(__value: AuroraSchedulerManager_replaceCronTemplate_args, toProtocol __proto: TProtocol) throws {

    try __proto.writeStructBeginWithName("AuroraSchedulerManager_replaceCronTemplate_args")

    try __proto.writeFieldValue(__value.config, name: "config", type: .STRUCT, id: 1)

    try __proto.writeFieldValue(__value.lock, name: "lock", type: .STRUCT, id: 2)

    try __proto.writeFieldValue(__value.session, name: "session", type: .STRUCT, id: 3)

    try __proto.writeFieldStop()

    try __proto.writeStructEnd()
  }

}



private struct AuroraSchedulerManager_replaceCronTemplate_result {

  private var success : Response?

  private init() {
  }

  private init(success: Response?) {
    self.success = success
  }

}

private func ==(lhs: AuroraSchedulerManager_replaceCronTemplate_result, rhs: AuroraSchedulerManager_replaceCronTemplate_result) -> Bool {
  return
    (lhs.success ?== rhs.success)
}

extension AuroraSchedulerManager_replaceCronTemplate_result : Hashable {

  private var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime * result + (success?.hashValue ?? 0)
    return result
  }

}

extension AuroraSchedulerManager_replaceCronTemplate_result : TStruct {

  private static func readValueFromProtocol(__proto: TProtocol) throws -> AuroraSchedulerManager_replaceCronTemplate_result {

    try __proto.readStructBegin()

    var success : Response?

    fields: while true {

      let (_, fieldType, fieldID) = try __proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .STOP):
          break fields

        case (0, .STRUCT):
          success = try __proto.readValue() as Response

        case let (_, unknownType):
          try __proto.skipType(unknownType)
      }

      try __proto.readFieldEnd()
    }

    try __proto.readStructEnd()


    return AuroraSchedulerManager_replaceCronTemplate_result(success: success)
  }

  private static func writeValue(__value: AuroraSchedulerManager_replaceCronTemplate_result, toProtocol __proto: TProtocol) throws {

    try __proto.writeStructBeginWithName("AuroraSchedulerManager_replaceCronTemplate_result")

    if let result = __value.success {
      try __proto.writeFieldValue(result, name: "success", type: .STRUCT, id: 0)
    }
    try __proto.writeFieldStop()

    try __proto.writeStructEnd()
  }

}



private struct AuroraSchedulerManager_startJobUpdate_args {

  private var request = JobUpdateRequest()

  private var message = String()

  private var session = SessionKey()

  private init() {
  }

  private init(request: JobUpdateRequest, message: String, session: SessionKey) {
    self.request = request
    self.message = message
    self.session = session
  }

}

private func ==(lhs: AuroraSchedulerManager_startJobUpdate_args, rhs: AuroraSchedulerManager_startJobUpdate_args) -> Bool {
  return
    (lhs.request ?== rhs.request) &&
    (lhs.message ?== rhs.message) &&
    (lhs.session ?== rhs.session)
}

extension AuroraSchedulerManager_startJobUpdate_args : Hashable {

  private var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime * result + (request.hashValue)
    result = prime * result + (message.hashValue)
    result = prime * result + (session.hashValue)
    return result
  }

}

extension AuroraSchedulerManager_startJobUpdate_args : TStruct {

  private static func readValueFromProtocol(__proto: TProtocol) throws -> AuroraSchedulerManager_startJobUpdate_args {

    try __proto.readStructBegin()

    var request : JobUpdateRequest!
    var message : String!
    var session : SessionKey!

    fields: while true {

      let (_, fieldType, fieldID) = try __proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .STOP):
          break fields

        case (1, .STRUCT):
          request = try __proto.readValue() as JobUpdateRequest

        case (3, .STRING):
          message = try __proto.readValue() as String

        case (2, .STRUCT):
          session = try __proto.readValue() as SessionKey

        case let (_, unknownType):
          try __proto.skipType(unknownType)
      }

      try __proto.readFieldEnd()
    }

    try __proto.readStructEnd()

    // Required fields
    try __proto.validateValue(request, named: "request")
    try __proto.validateValue(message, named: "message")
    try __proto.validateValue(session, named: "session")

    return AuroraSchedulerManager_startJobUpdate_args(request: request, message: message, session: session)
  }

  private static func writeValue(__value: AuroraSchedulerManager_startJobUpdate_args, toProtocol __proto: TProtocol) throws {

    try __proto.writeStructBeginWithName("AuroraSchedulerManager_startJobUpdate_args")

    try __proto.writeFieldValue(__value.request, name: "request", type: .STRUCT, id: 1)

    try __proto.writeFieldValue(__value.message, name: "message", type: .STRING, id: 3)

    try __proto.writeFieldValue(__value.session, name: "session", type: .STRUCT, id: 2)

    try __proto.writeFieldStop()

    try __proto.writeStructEnd()
  }

}



private struct AuroraSchedulerManager_startJobUpdate_result {

  private var success : Response?

  private init() {
  }

  private init(success: Response?) {
    self.success = success
  }

}

private func ==(lhs: AuroraSchedulerManager_startJobUpdate_result, rhs: AuroraSchedulerManager_startJobUpdate_result) -> Bool {
  return
    (lhs.success ?== rhs.success)
}

extension AuroraSchedulerManager_startJobUpdate_result : Hashable {

  private var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime * result + (success?.hashValue ?? 0)
    return result
  }

}

extension AuroraSchedulerManager_startJobUpdate_result : TStruct {

  private static func readValueFromProtocol(__proto: TProtocol) throws -> AuroraSchedulerManager_startJobUpdate_result {

    try __proto.readStructBegin()

    var success : Response?

    fields: while true {

      let (_, fieldType, fieldID) = try __proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .STOP):
          break fields

        case (0, .STRUCT):
          success = try __proto.readValue() as Response

        case let (_, unknownType):
          try __proto.skipType(unknownType)
      }

      try __proto.readFieldEnd()
    }

    try __proto.readStructEnd()


    return AuroraSchedulerManager_startJobUpdate_result(success: success)
  }

  private static func writeValue(__value: AuroraSchedulerManager_startJobUpdate_result, toProtocol __proto: TProtocol) throws {

    try __proto.writeStructBeginWithName("AuroraSchedulerManager_startJobUpdate_result")

    if let result = __value.success {
      try __proto.writeFieldValue(result, name: "success", type: .STRUCT, id: 0)
    }
    try __proto.writeFieldStop()

    try __proto.writeStructEnd()
  }

}



private struct AuroraSchedulerManager_pauseJobUpdate_args {

  private var key = JobUpdateKey()

  private var message = String()

  private var session = SessionKey()

  private init() {
  }

  private init(key: JobUpdateKey, message: String, session: SessionKey) {
    self.key = key
    self.message = message
    self.session = session
  }

}

private func ==(lhs: AuroraSchedulerManager_pauseJobUpdate_args, rhs: AuroraSchedulerManager_pauseJobUpdate_args) -> Bool {
  return
    (lhs.key ?== rhs.key) &&
    (lhs.message ?== rhs.message) &&
    (lhs.session ?== rhs.session)
}

extension AuroraSchedulerManager_pauseJobUpdate_args : Hashable {

  private var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime * result + (key.hashValue)
    result = prime * result + (message.hashValue)
    result = prime * result + (session.hashValue)
    return result
  }

}

extension AuroraSchedulerManager_pauseJobUpdate_args : TStruct {

  private static func readValueFromProtocol(__proto: TProtocol) throws -> AuroraSchedulerManager_pauseJobUpdate_args {

    try __proto.readStructBegin()

    var key : JobUpdateKey!
    var message : String!
    var session : SessionKey!

    fields: while true {

      let (_, fieldType, fieldID) = try __proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .STOP):
          break fields

        case (1, .STRUCT):
          key = try __proto.readValue() as JobUpdateKey

        case (3, .STRING):
          message = try __proto.readValue() as String

        case (2, .STRUCT):
          session = try __proto.readValue() as SessionKey

        case let (_, unknownType):
          try __proto.skipType(unknownType)
      }

      try __proto.readFieldEnd()
    }

    try __proto.readStructEnd()

    // Required fields
    try __proto.validateValue(key, named: "key")
    try __proto.validateValue(message, named: "message")
    try __proto.validateValue(session, named: "session")

    return AuroraSchedulerManager_pauseJobUpdate_args(key: key, message: message, session: session)
  }

  private static func writeValue(__value: AuroraSchedulerManager_pauseJobUpdate_args, toProtocol __proto: TProtocol) throws {

    try __proto.writeStructBeginWithName("AuroraSchedulerManager_pauseJobUpdate_args")

    try __proto.writeFieldValue(__value.key, name: "key", type: .STRUCT, id: 1)

    try __proto.writeFieldValue(__value.message, name: "message", type: .STRING, id: 3)

    try __proto.writeFieldValue(__value.session, name: "session", type: .STRUCT, id: 2)

    try __proto.writeFieldStop()

    try __proto.writeStructEnd()
  }

}



private struct AuroraSchedulerManager_pauseJobUpdate_result {

  private var success : Response?

  private init() {
  }

  private init(success: Response?) {
    self.success = success
  }

}

private func ==(lhs: AuroraSchedulerManager_pauseJobUpdate_result, rhs: AuroraSchedulerManager_pauseJobUpdate_result) -> Bool {
  return
    (lhs.success ?== rhs.success)
}

extension AuroraSchedulerManager_pauseJobUpdate_result : Hashable {

  private var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime * result + (success?.hashValue ?? 0)
    return result
  }

}

extension AuroraSchedulerManager_pauseJobUpdate_result : TStruct {

  private static func readValueFromProtocol(__proto: TProtocol) throws -> AuroraSchedulerManager_pauseJobUpdate_result {

    try __proto.readStructBegin()

    var success : Response?

    fields: while true {

      let (_, fieldType, fieldID) = try __proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .STOP):
          break fields

        case (0, .STRUCT):
          success = try __proto.readValue() as Response

        case let (_, unknownType):
          try __proto.skipType(unknownType)
      }

      try __proto.readFieldEnd()
    }

    try __proto.readStructEnd()


    return AuroraSchedulerManager_pauseJobUpdate_result(success: success)
  }

  private static func writeValue(__value: AuroraSchedulerManager_pauseJobUpdate_result, toProtocol __proto: TProtocol) throws {

    try __proto.writeStructBeginWithName("AuroraSchedulerManager_pauseJobUpdate_result")

    if let result = __value.success {
      try __proto.writeFieldValue(result, name: "success", type: .STRUCT, id: 0)
    }
    try __proto.writeFieldStop()

    try __proto.writeStructEnd()
  }

}



private struct AuroraSchedulerManager_resumeJobUpdate_args {

  private var key = JobUpdateKey()

  private var message = String()

  private var session = SessionKey()

  private init() {
  }

  private init(key: JobUpdateKey, message: String, session: SessionKey) {
    self.key = key
    self.message = message
    self.session = session
  }

}

private func ==(lhs: AuroraSchedulerManager_resumeJobUpdate_args, rhs: AuroraSchedulerManager_resumeJobUpdate_args) -> Bool {
  return
    (lhs.key ?== rhs.key) &&
    (lhs.message ?== rhs.message) &&
    (lhs.session ?== rhs.session)
}

extension AuroraSchedulerManager_resumeJobUpdate_args : Hashable {

  private var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime * result + (key.hashValue)
    result = prime * result + (message.hashValue)
    result = prime * result + (session.hashValue)
    return result
  }

}

extension AuroraSchedulerManager_resumeJobUpdate_args : TStruct {

  private static func readValueFromProtocol(__proto: TProtocol) throws -> AuroraSchedulerManager_resumeJobUpdate_args {

    try __proto.readStructBegin()

    var key : JobUpdateKey!
    var message : String!
    var session : SessionKey!

    fields: while true {

      let (_, fieldType, fieldID) = try __proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .STOP):
          break fields

        case (1, .STRUCT):
          key = try __proto.readValue() as JobUpdateKey

        case (3, .STRING):
          message = try __proto.readValue() as String

        case (2, .STRUCT):
          session = try __proto.readValue() as SessionKey

        case let (_, unknownType):
          try __proto.skipType(unknownType)
      }

      try __proto.readFieldEnd()
    }

    try __proto.readStructEnd()

    // Required fields
    try __proto.validateValue(key, named: "key")
    try __proto.validateValue(message, named: "message")
    try __proto.validateValue(session, named: "session")

    return AuroraSchedulerManager_resumeJobUpdate_args(key: key, message: message, session: session)
  }

  private static func writeValue(__value: AuroraSchedulerManager_resumeJobUpdate_args, toProtocol __proto: TProtocol) throws {

    try __proto.writeStructBeginWithName("AuroraSchedulerManager_resumeJobUpdate_args")

    try __proto.writeFieldValue(__value.key, name: "key", type: .STRUCT, id: 1)

    try __proto.writeFieldValue(__value.message, name: "message", type: .STRING, id: 3)

    try __proto.writeFieldValue(__value.session, name: "session", type: .STRUCT, id: 2)

    try __proto.writeFieldStop()

    try __proto.writeStructEnd()
  }

}



private struct AuroraSchedulerManager_resumeJobUpdate_result {

  private var success : Response?

  private init() {
  }

  private init(success: Response?) {
    self.success = success
  }

}

private func ==(lhs: AuroraSchedulerManager_resumeJobUpdate_result, rhs: AuroraSchedulerManager_resumeJobUpdate_result) -> Bool {
  return
    (lhs.success ?== rhs.success)
}

extension AuroraSchedulerManager_resumeJobUpdate_result : Hashable {

  private var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime * result + (success?.hashValue ?? 0)
    return result
  }

}

extension AuroraSchedulerManager_resumeJobUpdate_result : TStruct {

  private static func readValueFromProtocol(__proto: TProtocol) throws -> AuroraSchedulerManager_resumeJobUpdate_result {

    try __proto.readStructBegin()

    var success : Response?

    fields: while true {

      let (_, fieldType, fieldID) = try __proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .STOP):
          break fields

        case (0, .STRUCT):
          success = try __proto.readValue() as Response

        case let (_, unknownType):
          try __proto.skipType(unknownType)
      }

      try __proto.readFieldEnd()
    }

    try __proto.readStructEnd()


    return AuroraSchedulerManager_resumeJobUpdate_result(success: success)
  }

  private static func writeValue(__value: AuroraSchedulerManager_resumeJobUpdate_result, toProtocol __proto: TProtocol) throws {

    try __proto.writeStructBeginWithName("AuroraSchedulerManager_resumeJobUpdate_result")

    if let result = __value.success {
      try __proto.writeFieldValue(result, name: "success", type: .STRUCT, id: 0)
    }
    try __proto.writeFieldStop()

    try __proto.writeStructEnd()
  }

}



private struct AuroraSchedulerManager_abortJobUpdate_args {

  private var key = JobUpdateKey()

  private var message = String()

  private var session = SessionKey()

  private init() {
  }

  private init(key: JobUpdateKey, message: String, session: SessionKey) {
    self.key = key
    self.message = message
    self.session = session
  }

}

private func ==(lhs: AuroraSchedulerManager_abortJobUpdate_args, rhs: AuroraSchedulerManager_abortJobUpdate_args) -> Bool {
  return
    (lhs.key ?== rhs.key) &&
    (lhs.message ?== rhs.message) &&
    (lhs.session ?== rhs.session)
}

extension AuroraSchedulerManager_abortJobUpdate_args : Hashable {

  private var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime * result + (key.hashValue)
    result = prime * result + (message.hashValue)
    result = prime * result + (session.hashValue)
    return result
  }

}

extension AuroraSchedulerManager_abortJobUpdate_args : TStruct {

  private static func readValueFromProtocol(__proto: TProtocol) throws -> AuroraSchedulerManager_abortJobUpdate_args {

    try __proto.readStructBegin()

    var key : JobUpdateKey!
    var message : String!
    var session : SessionKey!

    fields: while true {

      let (_, fieldType, fieldID) = try __proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .STOP):
          break fields

        case (1, .STRUCT):
          key = try __proto.readValue() as JobUpdateKey

        case (3, .STRING):
          message = try __proto.readValue() as String

        case (2, .STRUCT):
          session = try __proto.readValue() as SessionKey

        case let (_, unknownType):
          try __proto.skipType(unknownType)
      }

      try __proto.readFieldEnd()
    }

    try __proto.readStructEnd()

    // Required fields
    try __proto.validateValue(key, named: "key")
    try __proto.validateValue(message, named: "message")
    try __proto.validateValue(session, named: "session")

    return AuroraSchedulerManager_abortJobUpdate_args(key: key, message: message, session: session)
  }

  private static func writeValue(__value: AuroraSchedulerManager_abortJobUpdate_args, toProtocol __proto: TProtocol) throws {

    try __proto.writeStructBeginWithName("AuroraSchedulerManager_abortJobUpdate_args")

    try __proto.writeFieldValue(__value.key, name: "key", type: .STRUCT, id: 1)

    try __proto.writeFieldValue(__value.message, name: "message", type: .STRING, id: 3)

    try __proto.writeFieldValue(__value.session, name: "session", type: .STRUCT, id: 2)

    try __proto.writeFieldStop()

    try __proto.writeStructEnd()
  }

}



private struct AuroraSchedulerManager_abortJobUpdate_result {

  private var success : Response?

  private init() {
  }

  private init(success: Response?) {
    self.success = success
  }

}

private func ==(lhs: AuroraSchedulerManager_abortJobUpdate_result, rhs: AuroraSchedulerManager_abortJobUpdate_result) -> Bool {
  return
    (lhs.success ?== rhs.success)
}

extension AuroraSchedulerManager_abortJobUpdate_result : Hashable {

  private var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime * result + (success?.hashValue ?? 0)
    return result
  }

}

extension AuroraSchedulerManager_abortJobUpdate_result : TStruct {

  private static func readValueFromProtocol(__proto: TProtocol) throws -> AuroraSchedulerManager_abortJobUpdate_result {

    try __proto.readStructBegin()

    var success : Response?

    fields: while true {

      let (_, fieldType, fieldID) = try __proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .STOP):
          break fields

        case (0, .STRUCT):
          success = try __proto.readValue() as Response

        case let (_, unknownType):
          try __proto.skipType(unknownType)
      }

      try __proto.readFieldEnd()
    }

    try __proto.readStructEnd()


    return AuroraSchedulerManager_abortJobUpdate_result(success: success)
  }

  private static func writeValue(__value: AuroraSchedulerManager_abortJobUpdate_result, toProtocol __proto: TProtocol) throws {

    try __proto.writeStructBeginWithName("AuroraSchedulerManager_abortJobUpdate_result")

    if let result = __value.success {
      try __proto.writeFieldValue(result, name: "success", type: .STRUCT, id: 0)
    }
    try __proto.writeFieldStop()

    try __proto.writeStructEnd()
  }

}



private struct AuroraSchedulerManager_pulseJobUpdate_args {

  private var key = JobUpdateKey()

  private var session = SessionKey()

  private init() {
  }

  private init(key: JobUpdateKey, session: SessionKey) {
    self.key = key
    self.session = session
  }

}

private func ==(lhs: AuroraSchedulerManager_pulseJobUpdate_args, rhs: AuroraSchedulerManager_pulseJobUpdate_args) -> Bool {
  return
    (lhs.key ?== rhs.key) &&
    (lhs.session ?== rhs.session)
}

extension AuroraSchedulerManager_pulseJobUpdate_args : Hashable {

  private var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime * result + (key.hashValue)
    result = prime * result + (session.hashValue)
    return result
  }

}

extension AuroraSchedulerManager_pulseJobUpdate_args : TStruct {

  private static func readValueFromProtocol(__proto: TProtocol) throws -> AuroraSchedulerManager_pulseJobUpdate_args {

    try __proto.readStructBegin()

    var key : JobUpdateKey!
    var session : SessionKey!

    fields: while true {

      let (_, fieldType, fieldID) = try __proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .STOP):
          break fields

        case (1, .STRUCT):
          key = try __proto.readValue() as JobUpdateKey

        case (2, .STRUCT):
          session = try __proto.readValue() as SessionKey

        case let (_, unknownType):
          try __proto.skipType(unknownType)
      }

      try __proto.readFieldEnd()
    }

    try __proto.readStructEnd()

    // Required fields
    try __proto.validateValue(key, named: "key")
    try __proto.validateValue(session, named: "session")

    return AuroraSchedulerManager_pulseJobUpdate_args(key: key, session: session)
  }

  private static func writeValue(__value: AuroraSchedulerManager_pulseJobUpdate_args, toProtocol __proto: TProtocol) throws {

    try __proto.writeStructBeginWithName("AuroraSchedulerManager_pulseJobUpdate_args")

    try __proto.writeFieldValue(__value.key, name: "key", type: .STRUCT, id: 1)

    try __proto.writeFieldValue(__value.session, name: "session", type: .STRUCT, id: 2)

    try __proto.writeFieldStop()

    try __proto.writeStructEnd()
  }

}



private struct AuroraSchedulerManager_pulseJobUpdate_result {

  private var success : Response?

  private init() {
  }

  private init(success: Response?) {
    self.success = success
  }

}

private func ==(lhs: AuroraSchedulerManager_pulseJobUpdate_result, rhs: AuroraSchedulerManager_pulseJobUpdate_result) -> Bool {
  return
    (lhs.success ?== rhs.success)
}

extension AuroraSchedulerManager_pulseJobUpdate_result : Hashable {

  private var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime * result + (success?.hashValue ?? 0)
    return result
  }

}

extension AuroraSchedulerManager_pulseJobUpdate_result : TStruct {

  private static func readValueFromProtocol(__proto: TProtocol) throws -> AuroraSchedulerManager_pulseJobUpdate_result {

    try __proto.readStructBegin()

    var success : Response?

    fields: while true {

      let (_, fieldType, fieldID) = try __proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .STOP):
          break fields

        case (0, .STRUCT):
          success = try __proto.readValue() as Response

        case let (_, unknownType):
          try __proto.skipType(unknownType)
      }

      try __proto.readFieldEnd()
    }

    try __proto.readStructEnd()


    return AuroraSchedulerManager_pulseJobUpdate_result(success: success)
  }

  private static func writeValue(__value: AuroraSchedulerManager_pulseJobUpdate_result, toProtocol __proto: TProtocol) throws {

    try __proto.writeStructBeginWithName("AuroraSchedulerManager_pulseJobUpdate_result")

    if let result = __value.success {
      try __proto.writeFieldValue(result, name: "success", type: .STRUCT, id: 0)
    }
    try __proto.writeFieldStop()

    try __proto.writeStructEnd()
  }

}



extension AuroraSchedulerManagerClient : AuroraSchedulerManager {

  private func send_createJob(description description: JobConfiguration, lock: Lock, session: SessionKey) throws {

    try __outProtocol.writeMessageBeginWithName("createJob", type: .CALL, sequenceID: 0)

    let __args = AuroraSchedulerManager_createJob_args(description: description, lock: lock, session: session)
    try AuroraSchedulerManager_createJob_args.writeValue(__args, toProtocol: __outProtocol)

    try __outProtocol.writeMessageEnd()
  }

  private func recv_createJob() throws -> Response {

    try __inProtocol.readResultMessageBegin() 

    let __result = try AuroraSchedulerManager_createJob_result.readValueFromProtocol(__inProtocol)

    try __inProtocol.readMessageEnd()

    if let __success = __result.success {
      return __success
    }
    throw NSError(
      domain: TApplicationErrorDomain, 
      code: Int(TApplicationError.MissingResult.rawValue),
      userInfo: [TApplicationErrorMethodKey: "createJob"])
  }

  public func createJobWithDescription(description: JobConfiguration, lock: Lock, session: SessionKey) throws -> Response {

    try send_createJob(description: description, lock: lock, session: session)

    try __outProtocol.transport().flush()

    return try recv_createJob()
  }

  private func send_scheduleCronJob(description description: JobConfiguration, lock: Lock, session: SessionKey) throws {

    try __outProtocol.writeMessageBeginWithName("scheduleCronJob", type: .CALL, sequenceID: 0)

    let __args = AuroraSchedulerManager_scheduleCronJob_args(description: description, lock: lock, session: session)
    try AuroraSchedulerManager_scheduleCronJob_args.writeValue(__args, toProtocol: __outProtocol)

    try __outProtocol.writeMessageEnd()
  }

  private func recv_scheduleCronJob() throws -> Response {

    try __inProtocol.readResultMessageBegin() 

    let __result = try AuroraSchedulerManager_scheduleCronJob_result.readValueFromProtocol(__inProtocol)

    try __inProtocol.readMessageEnd()

    if let __success = __result.success {
      return __success
    }
    throw NSError(
      domain: TApplicationErrorDomain, 
      code: Int(TApplicationError.MissingResult.rawValue),
      userInfo: [TApplicationErrorMethodKey: "scheduleCronJob"])
  }

  public func scheduleCronJobWithDescription(description: JobConfiguration, lock: Lock, session: SessionKey) throws -> Response {

    try send_scheduleCronJob(description: description, lock: lock, session: session)

    try __outProtocol.transport().flush()

    return try recv_scheduleCronJob()
  }

  private func send_descheduleCronJob(job job: JobKey, lock: Lock, session: SessionKey) throws {

    try __outProtocol.writeMessageBeginWithName("descheduleCronJob", type: .CALL, sequenceID: 0)

    let __args = AuroraSchedulerManager_descheduleCronJob_args(job: job, lock: lock, session: session)
    try AuroraSchedulerManager_descheduleCronJob_args.writeValue(__args, toProtocol: __outProtocol)

    try __outProtocol.writeMessageEnd()
  }

  private func recv_descheduleCronJob() throws -> Response {

    try __inProtocol.readResultMessageBegin() 

    let __result = try AuroraSchedulerManager_descheduleCronJob_result.readValueFromProtocol(__inProtocol)

    try __inProtocol.readMessageEnd()

    if let __success = __result.success {
      return __success
    }
    throw NSError(
      domain: TApplicationErrorDomain, 
      code: Int(TApplicationError.MissingResult.rawValue),
      userInfo: [TApplicationErrorMethodKey: "descheduleCronJob"])
  }

  public func descheduleCronJob(job: JobKey, lock: Lock, session: SessionKey) throws -> Response {

    try send_descheduleCronJob(job: job, lock: lock, session: session)

    try __outProtocol.transport().flush()

    return try recv_descheduleCronJob()
  }

  private func send_startCronJob(job job: JobKey, session: SessionKey) throws {

    try __outProtocol.writeMessageBeginWithName("startCronJob", type: .CALL, sequenceID: 0)

    let __args = AuroraSchedulerManager_startCronJob_args(job: job, session: session)
    try AuroraSchedulerManager_startCronJob_args.writeValue(__args, toProtocol: __outProtocol)

    try __outProtocol.writeMessageEnd()
  }

  private func recv_startCronJob() throws -> Response {

    try __inProtocol.readResultMessageBegin() 

    let __result = try AuroraSchedulerManager_startCronJob_result.readValueFromProtocol(__inProtocol)

    try __inProtocol.readMessageEnd()

    if let __success = __result.success {
      return __success
    }
    throw NSError(
      domain: TApplicationErrorDomain, 
      code: Int(TApplicationError.MissingResult.rawValue),
      userInfo: [TApplicationErrorMethodKey: "startCronJob"])
  }

  public func startCronJob(job: JobKey, session: SessionKey) throws -> Response {

    try send_startCronJob(job: job, session: session)

    try __outProtocol.transport().flush()

    return try recv_startCronJob()
  }

  private func send_restartShards(job job: JobKey, shardIds: TSet<Int32>, lock: Lock, session: SessionKey) throws {

    try __outProtocol.writeMessageBeginWithName("restartShards", type: .CALL, sequenceID: 0)

    let __args = AuroraSchedulerManager_restartShards_args(job: job, shardIds: shardIds, lock: lock, session: session)
    try AuroraSchedulerManager_restartShards_args.writeValue(__args, toProtocol: __outProtocol)

    try __outProtocol.writeMessageEnd()
  }

  private func recv_restartShards() throws -> Response {

    try __inProtocol.readResultMessageBegin() 

    let __result = try AuroraSchedulerManager_restartShards_result.readValueFromProtocol(__inProtocol)

    try __inProtocol.readMessageEnd()

    if let __success = __result.success {
      return __success
    }
    throw NSError(
      domain: TApplicationErrorDomain, 
      code: Int(TApplicationError.MissingResult.rawValue),
      userInfo: [TApplicationErrorMethodKey: "restartShards"])
  }

  public func restartShardsWithJob(job: JobKey, shardIds: TSet<Int32>, lock: Lock, session: SessionKey) throws -> Response {

    try send_restartShards(job: job, shardIds: shardIds, lock: lock, session: session)

    try __outProtocol.transport().flush()

    return try recv_restartShards()
  }

  private func send_killTasks(query query: TaskQuery, lock: Lock, session: SessionKey) throws {

    try __outProtocol.writeMessageBeginWithName("killTasks", type: .CALL, sequenceID: 0)

    let __args = AuroraSchedulerManager_killTasks_args(query: query, lock: lock, session: session)
    try AuroraSchedulerManager_killTasks_args.writeValue(__args, toProtocol: __outProtocol)

    try __outProtocol.writeMessageEnd()
  }

  private func recv_killTasks() throws -> Response {

    try __inProtocol.readResultMessageBegin() 

    let __result = try AuroraSchedulerManager_killTasks_result.readValueFromProtocol(__inProtocol)

    try __inProtocol.readMessageEnd()

    if let __success = __result.success {
      return __success
    }
    throw NSError(
      domain: TApplicationErrorDomain, 
      code: Int(TApplicationError.MissingResult.rawValue),
      userInfo: [TApplicationErrorMethodKey: "killTasks"])
  }

  public func killTasksWithQuery(query: TaskQuery, lock: Lock, session: SessionKey) throws -> Response {

    try send_killTasks(query: query, lock: lock, session: session)

    try __outProtocol.transport().flush()

    return try recv_killTasks()
  }

  private func send_addInstances(config config: AddInstancesConfig, lock: Lock, session: SessionKey) throws {

    try __outProtocol.writeMessageBeginWithName("addInstances", type: .CALL, sequenceID: 0)

    let __args = AuroraSchedulerManager_addInstances_args(config: config, lock: lock, session: session)
    try AuroraSchedulerManager_addInstances_args.writeValue(__args, toProtocol: __outProtocol)

    try __outProtocol.writeMessageEnd()
  }

  private func recv_addInstances() throws -> Response {

    try __inProtocol.readResultMessageBegin() 

    let __result = try AuroraSchedulerManager_addInstances_result.readValueFromProtocol(__inProtocol)

    try __inProtocol.readMessageEnd()

    if let __success = __result.success {
      return __success
    }
    throw NSError(
      domain: TApplicationErrorDomain, 
      code: Int(TApplicationError.MissingResult.rawValue),
      userInfo: [TApplicationErrorMethodKey: "addInstances"])
  }

  public func addInstancesWithConfig(config: AddInstancesConfig, lock: Lock, session: SessionKey) throws -> Response {

    try send_addInstances(config: config, lock: lock, session: session)

    try __outProtocol.transport().flush()

    return try recv_addInstances()
  }

  private func send_acquireLock(lockKey lockKey: LockKey, session: SessionKey) throws {

    try __outProtocol.writeMessageBeginWithName("acquireLock", type: .CALL, sequenceID: 0)

    let __args = AuroraSchedulerManager_acquireLock_args(lockKey: lockKey, session: session)
    try AuroraSchedulerManager_acquireLock_args.writeValue(__args, toProtocol: __outProtocol)

    try __outProtocol.writeMessageEnd()
  }

  private func recv_acquireLock() throws -> Response {

    try __inProtocol.readResultMessageBegin() 

    let __result = try AuroraSchedulerManager_acquireLock_result.readValueFromProtocol(__inProtocol)

    try __inProtocol.readMessageEnd()

    if let __success = __result.success {
      return __success
    }
    throw NSError(
      domain: TApplicationErrorDomain, 
      code: Int(TApplicationError.MissingResult.rawValue),
      userInfo: [TApplicationErrorMethodKey: "acquireLock"])
  }

  public func acquireLockWithLockKey(lockKey: LockKey, session: SessionKey) throws -> Response {

    try send_acquireLock(lockKey: lockKey, session: session)

    try __outProtocol.transport().flush()

    return try recv_acquireLock()
  }

  private func send_releaseLock(lock lock: Lock, validation: LockValidation, session: SessionKey) throws {

    try __outProtocol.writeMessageBeginWithName("releaseLock", type: .CALL, sequenceID: 0)

    let __args = AuroraSchedulerManager_releaseLock_args(lock: lock, validation: validation, session: session)
    try AuroraSchedulerManager_releaseLock_args.writeValue(__args, toProtocol: __outProtocol)

    try __outProtocol.writeMessageEnd()
  }

  private func recv_releaseLock() throws -> Response {

    try __inProtocol.readResultMessageBegin() 

    let __result = try AuroraSchedulerManager_releaseLock_result.readValueFromProtocol(__inProtocol)

    try __inProtocol.readMessageEnd()

    if let __success = __result.success {
      return __success
    }
    throw NSError(
      domain: TApplicationErrorDomain, 
      code: Int(TApplicationError.MissingResult.rawValue),
      userInfo: [TApplicationErrorMethodKey: "releaseLock"])
  }

  public func releaseLock(lock: Lock, validation: LockValidation, session: SessionKey) throws -> Response {

    try send_releaseLock(lock: lock, validation: validation, session: session)

    try __outProtocol.transport().flush()

    return try recv_releaseLock()
  }

  private func send_replaceCronTemplate(config config: JobConfiguration, lock: Lock, session: SessionKey) throws {

    try __outProtocol.writeMessageBeginWithName("replaceCronTemplate", type: .CALL, sequenceID: 0)

    let __args = AuroraSchedulerManager_replaceCronTemplate_args(config: config, lock: lock, session: session)
    try AuroraSchedulerManager_replaceCronTemplate_args.writeValue(__args, toProtocol: __outProtocol)

    try __outProtocol.writeMessageEnd()
  }

  private func recv_replaceCronTemplate() throws -> Response {

    try __inProtocol.readResultMessageBegin() 

    let __result = try AuroraSchedulerManager_replaceCronTemplate_result.readValueFromProtocol(__inProtocol)

    try __inProtocol.readMessageEnd()

    if let __success = __result.success {
      return __success
    }
    throw NSError(
      domain: TApplicationErrorDomain, 
      code: Int(TApplicationError.MissingResult.rawValue),
      userInfo: [TApplicationErrorMethodKey: "replaceCronTemplate"])
  }

  public func replaceCronTemplateWithConfig(config: JobConfiguration, lock: Lock, session: SessionKey) throws -> Response {

    try send_replaceCronTemplate(config: config, lock: lock, session: session)

    try __outProtocol.transport().flush()

    return try recv_replaceCronTemplate()
  }

  private func send_startJobUpdate(request request: JobUpdateRequest, message: String, session: SessionKey) throws {

    try __outProtocol.writeMessageBeginWithName("startJobUpdate", type: .CALL, sequenceID: 0)

    let __args = AuroraSchedulerManager_startJobUpdate_args(request: request, message: message, session: session)
    try AuroraSchedulerManager_startJobUpdate_args.writeValue(__args, toProtocol: __outProtocol)

    try __outProtocol.writeMessageEnd()
  }

  private func recv_startJobUpdate() throws -> Response {

    try __inProtocol.readResultMessageBegin() 

    let __result = try AuroraSchedulerManager_startJobUpdate_result.readValueFromProtocol(__inProtocol)

    try __inProtocol.readMessageEnd()

    if let __success = __result.success {
      return __success
    }
    throw NSError(
      domain: TApplicationErrorDomain, 
      code: Int(TApplicationError.MissingResult.rawValue),
      userInfo: [TApplicationErrorMethodKey: "startJobUpdate"])
  }

  public func startJobUpdateWithRequest(request: JobUpdateRequest, message: String, session: SessionKey) throws -> Response {

    try send_startJobUpdate(request: request, message: message, session: session)

    try __outProtocol.transport().flush()

    return try recv_startJobUpdate()
  }

  private func send_pauseJobUpdate(key key: JobUpdateKey, message: String, session: SessionKey) throws {

    try __outProtocol.writeMessageBeginWithName("pauseJobUpdate", type: .CALL, sequenceID: 0)

    let __args = AuroraSchedulerManager_pauseJobUpdate_args(key: key, message: message, session: session)
    try AuroraSchedulerManager_pauseJobUpdate_args.writeValue(__args, toProtocol: __outProtocol)

    try __outProtocol.writeMessageEnd()
  }

  private func recv_pauseJobUpdate() throws -> Response {

    try __inProtocol.readResultMessageBegin() 

    let __result = try AuroraSchedulerManager_pauseJobUpdate_result.readValueFromProtocol(__inProtocol)

    try __inProtocol.readMessageEnd()

    if let __success = __result.success {
      return __success
    }
    throw NSError(
      domain: TApplicationErrorDomain, 
      code: Int(TApplicationError.MissingResult.rawValue),
      userInfo: [TApplicationErrorMethodKey: "pauseJobUpdate"])
  }

  public func pauseJobUpdateWithKey(key: JobUpdateKey, message: String, session: SessionKey) throws -> Response {

    try send_pauseJobUpdate(key: key, message: message, session: session)

    try __outProtocol.transport().flush()

    return try recv_pauseJobUpdate()
  }

  private func send_resumeJobUpdate(key key: JobUpdateKey, message: String, session: SessionKey) throws {

    try __outProtocol.writeMessageBeginWithName("resumeJobUpdate", type: .CALL, sequenceID: 0)

    let __args = AuroraSchedulerManager_resumeJobUpdate_args(key: key, message: message, session: session)
    try AuroraSchedulerManager_resumeJobUpdate_args.writeValue(__args, toProtocol: __outProtocol)

    try __outProtocol.writeMessageEnd()
  }

  private func recv_resumeJobUpdate() throws -> Response {

    try __inProtocol.readResultMessageBegin() 

    let __result = try AuroraSchedulerManager_resumeJobUpdate_result.readValueFromProtocol(__inProtocol)

    try __inProtocol.readMessageEnd()

    if let __success = __result.success {
      return __success
    }
    throw NSError(
      domain: TApplicationErrorDomain, 
      code: Int(TApplicationError.MissingResult.rawValue),
      userInfo: [TApplicationErrorMethodKey: "resumeJobUpdate"])
  }

  public func resumeJobUpdateWithKey(key: JobUpdateKey, message: String, session: SessionKey) throws -> Response {

    try send_resumeJobUpdate(key: key, message: message, session: session)

    try __outProtocol.transport().flush()

    return try recv_resumeJobUpdate()
  }

  private func send_abortJobUpdate(key key: JobUpdateKey, message: String, session: SessionKey) throws {

    try __outProtocol.writeMessageBeginWithName("abortJobUpdate", type: .CALL, sequenceID: 0)

    let __args = AuroraSchedulerManager_abortJobUpdate_args(key: key, message: message, session: session)
    try AuroraSchedulerManager_abortJobUpdate_args.writeValue(__args, toProtocol: __outProtocol)

    try __outProtocol.writeMessageEnd()
  }

  private func recv_abortJobUpdate() throws -> Response {

    try __inProtocol.readResultMessageBegin() 

    let __result = try AuroraSchedulerManager_abortJobUpdate_result.readValueFromProtocol(__inProtocol)

    try __inProtocol.readMessageEnd()

    if let __success = __result.success {
      return __success
    }
    throw NSError(
      domain: TApplicationErrorDomain, 
      code: Int(TApplicationError.MissingResult.rawValue),
      userInfo: [TApplicationErrorMethodKey: "abortJobUpdate"])
  }

  public func abortJobUpdateWithKey(key: JobUpdateKey, message: String, session: SessionKey) throws -> Response {

    try send_abortJobUpdate(key: key, message: message, session: session)

    try __outProtocol.transport().flush()

    return try recv_abortJobUpdate()
  }

  private func send_pulseJobUpdate(key key: JobUpdateKey, session: SessionKey) throws {

    try __outProtocol.writeMessageBeginWithName("pulseJobUpdate", type: .CALL, sequenceID: 0)

    let __args = AuroraSchedulerManager_pulseJobUpdate_args(key: key, session: session)
    try AuroraSchedulerManager_pulseJobUpdate_args.writeValue(__args, toProtocol: __outProtocol)

    try __outProtocol.writeMessageEnd()
  }

  private func recv_pulseJobUpdate() throws -> Response {

    try __inProtocol.readResultMessageBegin() 

    let __result = try AuroraSchedulerManager_pulseJobUpdate_result.readValueFromProtocol(__inProtocol)

    try __inProtocol.readMessageEnd()

    if let __success = __result.success {
      return __success
    }
    throw NSError(
      domain: TApplicationErrorDomain, 
      code: Int(TApplicationError.MissingResult.rawValue),
      userInfo: [TApplicationErrorMethodKey: "pulseJobUpdate"])
  }

  public func pulseJobUpdateWithKey(key: JobUpdateKey, session: SessionKey) throws -> Response {

    try send_pulseJobUpdate(key: key, session: session)

    try __outProtocol.transport().flush()

    return try recv_pulseJobUpdate()
  }

}

extension AuroraSchedulerManagerProcessor : TProcessor {

  static let processorHandlers : ProcessorHandlerDictionary = {

    var processorHandlers = ProcessorHandlerDictionary()

    processorHandlers["createJob"] = { sequenceID, inProtocol, outProtocol, handler in

      let args = try AuroraSchedulerManager_createJob_args.readValueFromProtocol(inProtocol)

      try inProtocol.readMessageEnd()

      var result = AuroraSchedulerManager_createJob_result()
      do {
        result.success = try handler.createJobWithDescription(args.description, lock: args.lock, session: args.session)
      }
      catch let error {
        throw error
      }

      try outProtocol.writeMessageBeginWithName("createJob", type: .REPLY, sequenceID: sequenceID)
      try AuroraSchedulerManager_createJob_result.writeValue(result, toProtocol: outProtocol)
      try outProtocol.writeMessageEnd()
    }
    processorHandlers["scheduleCronJob"] = { sequenceID, inProtocol, outProtocol, handler in

      let args = try AuroraSchedulerManager_scheduleCronJob_args.readValueFromProtocol(inProtocol)

      try inProtocol.readMessageEnd()

      var result = AuroraSchedulerManager_scheduleCronJob_result()
      do {
        result.success = try handler.scheduleCronJobWithDescription(args.description, lock: args.lock, session: args.session)
      }
      catch let error {
        throw error
      }

      try outProtocol.writeMessageBeginWithName("scheduleCronJob", type: .REPLY, sequenceID: sequenceID)
      try AuroraSchedulerManager_scheduleCronJob_result.writeValue(result, toProtocol: outProtocol)
      try outProtocol.writeMessageEnd()
    }
    processorHandlers["descheduleCronJob"] = { sequenceID, inProtocol, outProtocol, handler in

      let args = try AuroraSchedulerManager_descheduleCronJob_args.readValueFromProtocol(inProtocol)

      try inProtocol.readMessageEnd()

      var result = AuroraSchedulerManager_descheduleCronJob_result()
      do {
        result.success = try handler.descheduleCronJob(args.job, lock: args.lock, session: args.session)
      }
      catch let error {
        throw error
      }

      try outProtocol.writeMessageBeginWithName("descheduleCronJob", type: .REPLY, sequenceID: sequenceID)
      try AuroraSchedulerManager_descheduleCronJob_result.writeValue(result, toProtocol: outProtocol)
      try outProtocol.writeMessageEnd()
    }
    processorHandlers["startCronJob"] = { sequenceID, inProtocol, outProtocol, handler in

      let args = try AuroraSchedulerManager_startCronJob_args.readValueFromProtocol(inProtocol)

      try inProtocol.readMessageEnd()

      var result = AuroraSchedulerManager_startCronJob_result()
      do {
        result.success = try handler.startCronJob(args.job, session: args.session)
      }
      catch let error {
        throw error
      }

      try outProtocol.writeMessageBeginWithName("startCronJob", type: .REPLY, sequenceID: sequenceID)
      try AuroraSchedulerManager_startCronJob_result.writeValue(result, toProtocol: outProtocol)
      try outProtocol.writeMessageEnd()
    }
    processorHandlers["restartShards"] = { sequenceID, inProtocol, outProtocol, handler in

      let args = try AuroraSchedulerManager_restartShards_args.readValueFromProtocol(inProtocol)

      try inProtocol.readMessageEnd()

      var result = AuroraSchedulerManager_restartShards_result()
      do {
        result.success = try handler.restartShardsWithJob(args.job, shardIds: args.shardIds, lock: args.lock, session: args.session)
      }
      catch let error {
        throw error
      }

      try outProtocol.writeMessageBeginWithName("restartShards", type: .REPLY, sequenceID: sequenceID)
      try AuroraSchedulerManager_restartShards_result.writeValue(result, toProtocol: outProtocol)
      try outProtocol.writeMessageEnd()
    }
    processorHandlers["killTasks"] = { sequenceID, inProtocol, outProtocol, handler in

      let args = try AuroraSchedulerManager_killTasks_args.readValueFromProtocol(inProtocol)

      try inProtocol.readMessageEnd()

      var result = AuroraSchedulerManager_killTasks_result()
      do {
        result.success = try handler.killTasksWithQuery(args.query, lock: args.lock, session: args.session)
      }
      catch let error {
        throw error
      }

      try outProtocol.writeMessageBeginWithName("killTasks", type: .REPLY, sequenceID: sequenceID)
      try AuroraSchedulerManager_killTasks_result.writeValue(result, toProtocol: outProtocol)
      try outProtocol.writeMessageEnd()
    }
    processorHandlers["addInstances"] = { sequenceID, inProtocol, outProtocol, handler in

      let args = try AuroraSchedulerManager_addInstances_args.readValueFromProtocol(inProtocol)

      try inProtocol.readMessageEnd()

      var result = AuroraSchedulerManager_addInstances_result()
      do {
        result.success = try handler.addInstancesWithConfig(args.config, lock: args.lock, session: args.session)
      }
      catch let error {
        throw error
      }

      try outProtocol.writeMessageBeginWithName("addInstances", type: .REPLY, sequenceID: sequenceID)
      try AuroraSchedulerManager_addInstances_result.writeValue(result, toProtocol: outProtocol)
      try outProtocol.writeMessageEnd()
    }
    processorHandlers["acquireLock"] = { sequenceID, inProtocol, outProtocol, handler in

      let args = try AuroraSchedulerManager_acquireLock_args.readValueFromProtocol(inProtocol)

      try inProtocol.readMessageEnd()

      var result = AuroraSchedulerManager_acquireLock_result()
      do {
        result.success = try handler.acquireLockWithLockKey(args.lockKey, session: args.session)
      }
      catch let error {
        throw error
      }

      try outProtocol.writeMessageBeginWithName("acquireLock", type: .REPLY, sequenceID: sequenceID)
      try AuroraSchedulerManager_acquireLock_result.writeValue(result, toProtocol: outProtocol)
      try outProtocol.writeMessageEnd()
    }
    processorHandlers["releaseLock"] = { sequenceID, inProtocol, outProtocol, handler in

      let args = try AuroraSchedulerManager_releaseLock_args.readValueFromProtocol(inProtocol)

      try inProtocol.readMessageEnd()

      var result = AuroraSchedulerManager_releaseLock_result()
      do {
        result.success = try handler.releaseLock(args.lock, validation: args.validation, session: args.session)
      }
      catch let error {
        throw error
      }

      try outProtocol.writeMessageBeginWithName("releaseLock", type: .REPLY, sequenceID: sequenceID)
      try AuroraSchedulerManager_releaseLock_result.writeValue(result, toProtocol: outProtocol)
      try outProtocol.writeMessageEnd()
    }
    processorHandlers["replaceCronTemplate"] = { sequenceID, inProtocol, outProtocol, handler in

      let args = try AuroraSchedulerManager_replaceCronTemplate_args.readValueFromProtocol(inProtocol)

      try inProtocol.readMessageEnd()

      var result = AuroraSchedulerManager_replaceCronTemplate_result()
      do {
        result.success = try handler.replaceCronTemplateWithConfig(args.config, lock: args.lock, session: args.session)
      }
      catch let error {
        throw error
      }

      try outProtocol.writeMessageBeginWithName("replaceCronTemplate", type: .REPLY, sequenceID: sequenceID)
      try AuroraSchedulerManager_replaceCronTemplate_result.writeValue(result, toProtocol: outProtocol)
      try outProtocol.writeMessageEnd()
    }
    processorHandlers["startJobUpdate"] = { sequenceID, inProtocol, outProtocol, handler in

      let args = try AuroraSchedulerManager_startJobUpdate_args.readValueFromProtocol(inProtocol)

      try inProtocol.readMessageEnd()

      var result = AuroraSchedulerManager_startJobUpdate_result()
      do {
        result.success = try handler.startJobUpdateWithRequest(args.request, message: args.message, session: args.session)
      }
      catch let error {
        throw error
      }

      try outProtocol.writeMessageBeginWithName("startJobUpdate", type: .REPLY, sequenceID: sequenceID)
      try AuroraSchedulerManager_startJobUpdate_result.writeValue(result, toProtocol: outProtocol)
      try outProtocol.writeMessageEnd()
    }
    processorHandlers["pauseJobUpdate"] = { sequenceID, inProtocol, outProtocol, handler in

      let args = try AuroraSchedulerManager_pauseJobUpdate_args.readValueFromProtocol(inProtocol)

      try inProtocol.readMessageEnd()

      var result = AuroraSchedulerManager_pauseJobUpdate_result()
      do {
        result.success = try handler.pauseJobUpdateWithKey(args.key, message: args.message, session: args.session)
      }
      catch let error {
        throw error
      }

      try outProtocol.writeMessageBeginWithName("pauseJobUpdate", type: .REPLY, sequenceID: sequenceID)
      try AuroraSchedulerManager_pauseJobUpdate_result.writeValue(result, toProtocol: outProtocol)
      try outProtocol.writeMessageEnd()
    }
    processorHandlers["resumeJobUpdate"] = { sequenceID, inProtocol, outProtocol, handler in

      let args = try AuroraSchedulerManager_resumeJobUpdate_args.readValueFromProtocol(inProtocol)

      try inProtocol.readMessageEnd()

      var result = AuroraSchedulerManager_resumeJobUpdate_result()
      do {
        result.success = try handler.resumeJobUpdateWithKey(args.key, message: args.message, session: args.session)
      }
      catch let error {
        throw error
      }

      try outProtocol.writeMessageBeginWithName("resumeJobUpdate", type: .REPLY, sequenceID: sequenceID)
      try AuroraSchedulerManager_resumeJobUpdate_result.writeValue(result, toProtocol: outProtocol)
      try outProtocol.writeMessageEnd()
    }
    processorHandlers["abortJobUpdate"] = { sequenceID, inProtocol, outProtocol, handler in

      let args = try AuroraSchedulerManager_abortJobUpdate_args.readValueFromProtocol(inProtocol)

      try inProtocol.readMessageEnd()

      var result = AuroraSchedulerManager_abortJobUpdate_result()
      do {
        result.success = try handler.abortJobUpdateWithKey(args.key, message: args.message, session: args.session)
      }
      catch let error {
        throw error
      }

      try outProtocol.writeMessageBeginWithName("abortJobUpdate", type: .REPLY, sequenceID: sequenceID)
      try AuroraSchedulerManager_abortJobUpdate_result.writeValue(result, toProtocol: outProtocol)
      try outProtocol.writeMessageEnd()
    }
    processorHandlers["pulseJobUpdate"] = { sequenceID, inProtocol, outProtocol, handler in

      let args = try AuroraSchedulerManager_pulseJobUpdate_args.readValueFromProtocol(inProtocol)

      try inProtocol.readMessageEnd()

      var result = AuroraSchedulerManager_pulseJobUpdate_result()
      do {
        result.success = try handler.pulseJobUpdateWithKey(args.key, session: args.session)
      }
      catch let error {
        throw error
      }

      try outProtocol.writeMessageBeginWithName("pulseJobUpdate", type: .REPLY, sequenceID: sequenceID)
      try AuroraSchedulerManager_pulseJobUpdate_result.writeValue(result, toProtocol: outProtocol)
      try outProtocol.writeMessageEnd()
    }
    return processorHandlers
  }()

  public func processOnInputProtocol(inProtocol: TProtocol, outputProtocol outProtocol: TProtocol) throws {

    let (messageName, _, sequenceID) = try inProtocol.readMessageBegin()

    if let processorHandler = AuroraSchedulerManagerProcessor.processorHandlers[messageName] {
      do {
        try processorHandler(sequenceID, inProtocol, outProtocol, service)
      }
      catch let error as NSError {
        try outProtocol.writeExceptionForMessageName(messageName, sequenceID: sequenceID, ex: error)
      }
    }
    else {
      try inProtocol.skipType(.STRUCT)
      try inProtocol.readMessageEnd()
      try outProtocol.writeExceptionForMessageName(messageName,
        sequenceID: sequenceID,
        ex: NSError(
          domain: TApplicationErrorDomain, 
          code: Int(TApplicationError.UnknownMethod.rawValue), 
          userInfo: [TApplicationErrorMethodKey: messageName]))
    }
  }
}

private struct AuroraAdmin_setQuota_args {

  private var ownerRole = String()

  private var quota = ResourceAggregate()

  private var session = SessionKey()

  private init() {
  }

  private init(ownerRole: String, quota: ResourceAggregate, session: SessionKey) {
    self.ownerRole = ownerRole
    self.quota = quota
    self.session = session
  }

}

private func ==(lhs: AuroraAdmin_setQuota_args, rhs: AuroraAdmin_setQuota_args) -> Bool {
  return
    (lhs.ownerRole ?== rhs.ownerRole) &&
    (lhs.quota ?== rhs.quota) &&
    (lhs.session ?== rhs.session)
}

extension AuroraAdmin_setQuota_args : Hashable {

  private var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime * result + (ownerRole.hashValue)
    result = prime * result + (quota.hashValue)
    result = prime * result + (session.hashValue)
    return result
  }

}

extension AuroraAdmin_setQuota_args : TStruct {

  private static func readValueFromProtocol(__proto: TProtocol) throws -> AuroraAdmin_setQuota_args {

    try __proto.readStructBegin()

    var ownerRole : String!
    var quota : ResourceAggregate!
    var session : SessionKey!

    fields: while true {

      let (_, fieldType, fieldID) = try __proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .STOP):
          break fields

        case (1, .STRING):
          ownerRole = try __proto.readValue() as String

        case (2, .STRUCT):
          quota = try __proto.readValue() as ResourceAggregate

        case (3, .STRUCT):
          session = try __proto.readValue() as SessionKey

        case let (_, unknownType):
          try __proto.skipType(unknownType)
      }

      try __proto.readFieldEnd()
    }

    try __proto.readStructEnd()

    // Required fields
    try __proto.validateValue(ownerRole, named: "ownerRole")
    try __proto.validateValue(quota, named: "quota")
    try __proto.validateValue(session, named: "session")

    return AuroraAdmin_setQuota_args(ownerRole: ownerRole, quota: quota, session: session)
  }

  private static func writeValue(__value: AuroraAdmin_setQuota_args, toProtocol __proto: TProtocol) throws {

    try __proto.writeStructBeginWithName("AuroraAdmin_setQuota_args")

    try __proto.writeFieldValue(__value.ownerRole, name: "ownerRole", type: .STRING, id: 1)

    try __proto.writeFieldValue(__value.quota, name: "quota", type: .STRUCT, id: 2)

    try __proto.writeFieldValue(__value.session, name: "session", type: .STRUCT, id: 3)

    try __proto.writeFieldStop()

    try __proto.writeStructEnd()
  }

}



private struct AuroraAdmin_setQuota_result {

  private var success : Response?

  private init() {
  }

  private init(success: Response?) {
    self.success = success
  }

}

private func ==(lhs: AuroraAdmin_setQuota_result, rhs: AuroraAdmin_setQuota_result) -> Bool {
  return
    (lhs.success ?== rhs.success)
}

extension AuroraAdmin_setQuota_result : Hashable {

  private var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime * result + (success?.hashValue ?? 0)
    return result
  }

}

extension AuroraAdmin_setQuota_result : TStruct {

  private static func readValueFromProtocol(__proto: TProtocol) throws -> AuroraAdmin_setQuota_result {

    try __proto.readStructBegin()

    var success : Response?

    fields: while true {

      let (_, fieldType, fieldID) = try __proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .STOP):
          break fields

        case (0, .STRUCT):
          success = try __proto.readValue() as Response

        case let (_, unknownType):
          try __proto.skipType(unknownType)
      }

      try __proto.readFieldEnd()
    }

    try __proto.readStructEnd()


    return AuroraAdmin_setQuota_result(success: success)
  }

  private static func writeValue(__value: AuroraAdmin_setQuota_result, toProtocol __proto: TProtocol) throws {

    try __proto.writeStructBeginWithName("AuroraAdmin_setQuota_result")

    if let result = __value.success {
      try __proto.writeFieldValue(result, name: "success", type: .STRUCT, id: 0)
    }
    try __proto.writeFieldStop()

    try __proto.writeStructEnd()
  }

}



private struct AuroraAdmin_forceTaskState_args {

  private var taskId = String()

  private var status = ScheduleStatus()

  private var session = SessionKey()

  private init() {
  }

  private init(taskId: String, status: ScheduleStatus, session: SessionKey) {
    self.taskId = taskId
    self.status = status
    self.session = session
  }

}

private func ==(lhs: AuroraAdmin_forceTaskState_args, rhs: AuroraAdmin_forceTaskState_args) -> Bool {
  return
    (lhs.taskId ?== rhs.taskId) &&
    (lhs.status ?== rhs.status) &&
    (lhs.session ?== rhs.session)
}

extension AuroraAdmin_forceTaskState_args : Hashable {

  private var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime * result + (taskId.hashValue)
    result = prime * result + (status.hashValue)
    result = prime * result + (session.hashValue)
    return result
  }

}

extension AuroraAdmin_forceTaskState_args : TStruct {

  private static func readValueFromProtocol(__proto: TProtocol) throws -> AuroraAdmin_forceTaskState_args {

    try __proto.readStructBegin()

    var taskId : String!
    var status : ScheduleStatus!
    var session : SessionKey!

    fields: while true {

      let (_, fieldType, fieldID) = try __proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .STOP):
          break fields

        case (1, .STRING):
          taskId = try __proto.readValue() as String

        case (2, .I32):
          status = try __proto.readValue() as ScheduleStatus

        case (3, .STRUCT):
          session = try __proto.readValue() as SessionKey

        case let (_, unknownType):
          try __proto.skipType(unknownType)
      }

      try __proto.readFieldEnd()
    }

    try __proto.readStructEnd()

    // Required fields
    try __proto.validateValue(taskId, named: "taskId")
    try __proto.validateValue(status, named: "status")
    try __proto.validateValue(session, named: "session")

    return AuroraAdmin_forceTaskState_args(taskId: taskId, status: status, session: session)
  }

  private static func writeValue(__value: AuroraAdmin_forceTaskState_args, toProtocol __proto: TProtocol) throws {

    try __proto.writeStructBeginWithName("AuroraAdmin_forceTaskState_args")

    try __proto.writeFieldValue(__value.taskId, name: "taskId", type: .STRING, id: 1)

    try __proto.writeFieldValue(__value.status, name: "status", type: .I32, id: 2)

    try __proto.writeFieldValue(__value.session, name: "session", type: .STRUCT, id: 3)

    try __proto.writeFieldStop()

    try __proto.writeStructEnd()
  }

}



private struct AuroraAdmin_forceTaskState_result {

  private var success : Response?

  private init() {
  }

  private init(success: Response?) {
    self.success = success
  }

}

private func ==(lhs: AuroraAdmin_forceTaskState_result, rhs: AuroraAdmin_forceTaskState_result) -> Bool {
  return
    (lhs.success ?== rhs.success)
}

extension AuroraAdmin_forceTaskState_result : Hashable {

  private var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime * result + (success?.hashValue ?? 0)
    return result
  }

}

extension AuroraAdmin_forceTaskState_result : TStruct {

  private static func readValueFromProtocol(__proto: TProtocol) throws -> AuroraAdmin_forceTaskState_result {

    try __proto.readStructBegin()

    var success : Response?

    fields: while true {

      let (_, fieldType, fieldID) = try __proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .STOP):
          break fields

        case (0, .STRUCT):
          success = try __proto.readValue() as Response

        case let (_, unknownType):
          try __proto.skipType(unknownType)
      }

      try __proto.readFieldEnd()
    }

    try __proto.readStructEnd()


    return AuroraAdmin_forceTaskState_result(success: success)
  }

  private static func writeValue(__value: AuroraAdmin_forceTaskState_result, toProtocol __proto: TProtocol) throws {

    try __proto.writeStructBeginWithName("AuroraAdmin_forceTaskState_result")

    if let result = __value.success {
      try __proto.writeFieldValue(result, name: "success", type: .STRUCT, id: 0)
    }
    try __proto.writeFieldStop()

    try __proto.writeStructEnd()
  }

}



private struct AuroraAdmin_performBackup_args {

  private var session = SessionKey()

  private init() {
  }

  private init(session: SessionKey) {
    self.session = session
  }

}

private func ==(lhs: AuroraAdmin_performBackup_args, rhs: AuroraAdmin_performBackup_args) -> Bool {
  return
    (lhs.session ?== rhs.session)
}

extension AuroraAdmin_performBackup_args : Hashable {

  private var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime * result + (session.hashValue)
    return result
  }

}

extension AuroraAdmin_performBackup_args : TStruct {

  private static func readValueFromProtocol(__proto: TProtocol) throws -> AuroraAdmin_performBackup_args {

    try __proto.readStructBegin()

    var session : SessionKey!

    fields: while true {

      let (_, fieldType, fieldID) = try __proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .STOP):
          break fields

        case (1, .STRUCT):
          session = try __proto.readValue() as SessionKey

        case let (_, unknownType):
          try __proto.skipType(unknownType)
      }

      try __proto.readFieldEnd()
    }

    try __proto.readStructEnd()

    // Required fields
    try __proto.validateValue(session, named: "session")

    return AuroraAdmin_performBackup_args(session: session)
  }

  private static func writeValue(__value: AuroraAdmin_performBackup_args, toProtocol __proto: TProtocol) throws {

    try __proto.writeStructBeginWithName("AuroraAdmin_performBackup_args")

    try __proto.writeFieldValue(__value.session, name: "session", type: .STRUCT, id: 1)

    try __proto.writeFieldStop()

    try __proto.writeStructEnd()
  }

}



private struct AuroraAdmin_performBackup_result {

  private var success : Response?

  private init() {
  }

  private init(success: Response?) {
    self.success = success
  }

}

private func ==(lhs: AuroraAdmin_performBackup_result, rhs: AuroraAdmin_performBackup_result) -> Bool {
  return
    (lhs.success ?== rhs.success)
}

extension AuroraAdmin_performBackup_result : Hashable {

  private var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime * result + (success?.hashValue ?? 0)
    return result
  }

}

extension AuroraAdmin_performBackup_result : TStruct {

  private static func readValueFromProtocol(__proto: TProtocol) throws -> AuroraAdmin_performBackup_result {

    try __proto.readStructBegin()

    var success : Response?

    fields: while true {

      let (_, fieldType, fieldID) = try __proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .STOP):
          break fields

        case (0, .STRUCT):
          success = try __proto.readValue() as Response

        case let (_, unknownType):
          try __proto.skipType(unknownType)
      }

      try __proto.readFieldEnd()
    }

    try __proto.readStructEnd()


    return AuroraAdmin_performBackup_result(success: success)
  }

  private static func writeValue(__value: AuroraAdmin_performBackup_result, toProtocol __proto: TProtocol) throws {

    try __proto.writeStructBeginWithName("AuroraAdmin_performBackup_result")

    if let result = __value.success {
      try __proto.writeFieldValue(result, name: "success", type: .STRUCT, id: 0)
    }
    try __proto.writeFieldStop()

    try __proto.writeStructEnd()
  }

}



private struct AuroraAdmin_listBackups_args {

  private var session = SessionKey()

  private init() {
  }

  private init(session: SessionKey) {
    self.session = session
  }

}

private func ==(lhs: AuroraAdmin_listBackups_args, rhs: AuroraAdmin_listBackups_args) -> Bool {
  return
    (lhs.session ?== rhs.session)
}

extension AuroraAdmin_listBackups_args : Hashable {

  private var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime * result + (session.hashValue)
    return result
  }

}

extension AuroraAdmin_listBackups_args : TStruct {

  private static func readValueFromProtocol(__proto: TProtocol) throws -> AuroraAdmin_listBackups_args {

    try __proto.readStructBegin()

    var session : SessionKey!

    fields: while true {

      let (_, fieldType, fieldID) = try __proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .STOP):
          break fields

        case (1, .STRUCT):
          session = try __proto.readValue() as SessionKey

        case let (_, unknownType):
          try __proto.skipType(unknownType)
      }

      try __proto.readFieldEnd()
    }

    try __proto.readStructEnd()

    // Required fields
    try __proto.validateValue(session, named: "session")

    return AuroraAdmin_listBackups_args(session: session)
  }

  private static func writeValue(__value: AuroraAdmin_listBackups_args, toProtocol __proto: TProtocol) throws {

    try __proto.writeStructBeginWithName("AuroraAdmin_listBackups_args")

    try __proto.writeFieldValue(__value.session, name: "session", type: .STRUCT, id: 1)

    try __proto.writeFieldStop()

    try __proto.writeStructEnd()
  }

}



private struct AuroraAdmin_listBackups_result {

  private var success : Response?

  private init() {
  }

  private init(success: Response?) {
    self.success = success
  }

}

private func ==(lhs: AuroraAdmin_listBackups_result, rhs: AuroraAdmin_listBackups_result) -> Bool {
  return
    (lhs.success ?== rhs.success)
}

extension AuroraAdmin_listBackups_result : Hashable {

  private var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime * result + (success?.hashValue ?? 0)
    return result
  }

}

extension AuroraAdmin_listBackups_result : TStruct {

  private static func readValueFromProtocol(__proto: TProtocol) throws -> AuroraAdmin_listBackups_result {

    try __proto.readStructBegin()

    var success : Response?

    fields: while true {

      let (_, fieldType, fieldID) = try __proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .STOP):
          break fields

        case (0, .STRUCT):
          success = try __proto.readValue() as Response

        case let (_, unknownType):
          try __proto.skipType(unknownType)
      }

      try __proto.readFieldEnd()
    }

    try __proto.readStructEnd()


    return AuroraAdmin_listBackups_result(success: success)
  }

  private static func writeValue(__value: AuroraAdmin_listBackups_result, toProtocol __proto: TProtocol) throws {

    try __proto.writeStructBeginWithName("AuroraAdmin_listBackups_result")

    if let result = __value.success {
      try __proto.writeFieldValue(result, name: "success", type: .STRUCT, id: 0)
    }
    try __proto.writeFieldStop()

    try __proto.writeStructEnd()
  }

}



private struct AuroraAdmin_stageRecovery_args {

  private var backupId = String()

  private var session = SessionKey()

  private init() {
  }

  private init(backupId: String, session: SessionKey) {
    self.backupId = backupId
    self.session = session
  }

}

private func ==(lhs: AuroraAdmin_stageRecovery_args, rhs: AuroraAdmin_stageRecovery_args) -> Bool {
  return
    (lhs.backupId ?== rhs.backupId) &&
    (lhs.session ?== rhs.session)
}

extension AuroraAdmin_stageRecovery_args : Hashable {

  private var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime * result + (backupId.hashValue)
    result = prime * result + (session.hashValue)
    return result
  }

}

extension AuroraAdmin_stageRecovery_args : TStruct {

  private static func readValueFromProtocol(__proto: TProtocol) throws -> AuroraAdmin_stageRecovery_args {

    try __proto.readStructBegin()

    var backupId : String!
    var session : SessionKey!

    fields: while true {

      let (_, fieldType, fieldID) = try __proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .STOP):
          break fields

        case (1, .STRING):
          backupId = try __proto.readValue() as String

        case (2, .STRUCT):
          session = try __proto.readValue() as SessionKey

        case let (_, unknownType):
          try __proto.skipType(unknownType)
      }

      try __proto.readFieldEnd()
    }

    try __proto.readStructEnd()

    // Required fields
    try __proto.validateValue(backupId, named: "backupId")
    try __proto.validateValue(session, named: "session")

    return AuroraAdmin_stageRecovery_args(backupId: backupId, session: session)
  }

  private static func writeValue(__value: AuroraAdmin_stageRecovery_args, toProtocol __proto: TProtocol) throws {

    try __proto.writeStructBeginWithName("AuroraAdmin_stageRecovery_args")

    try __proto.writeFieldValue(__value.backupId, name: "backupId", type: .STRING, id: 1)

    try __proto.writeFieldValue(__value.session, name: "session", type: .STRUCT, id: 2)

    try __proto.writeFieldStop()

    try __proto.writeStructEnd()
  }

}



private struct AuroraAdmin_stageRecovery_result {

  private var success : Response?

  private init() {
  }

  private init(success: Response?) {
    self.success = success
  }

}

private func ==(lhs: AuroraAdmin_stageRecovery_result, rhs: AuroraAdmin_stageRecovery_result) -> Bool {
  return
    (lhs.success ?== rhs.success)
}

extension AuroraAdmin_stageRecovery_result : Hashable {

  private var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime * result + (success?.hashValue ?? 0)
    return result
  }

}

extension AuroraAdmin_stageRecovery_result : TStruct {

  private static func readValueFromProtocol(__proto: TProtocol) throws -> AuroraAdmin_stageRecovery_result {

    try __proto.readStructBegin()

    var success : Response?

    fields: while true {

      let (_, fieldType, fieldID) = try __proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .STOP):
          break fields

        case (0, .STRUCT):
          success = try __proto.readValue() as Response

        case let (_, unknownType):
          try __proto.skipType(unknownType)
      }

      try __proto.readFieldEnd()
    }

    try __proto.readStructEnd()


    return AuroraAdmin_stageRecovery_result(success: success)
  }

  private static func writeValue(__value: AuroraAdmin_stageRecovery_result, toProtocol __proto: TProtocol) throws {

    try __proto.writeStructBeginWithName("AuroraAdmin_stageRecovery_result")

    if let result = __value.success {
      try __proto.writeFieldValue(result, name: "success", type: .STRUCT, id: 0)
    }
    try __proto.writeFieldStop()

    try __proto.writeStructEnd()
  }

}



private struct AuroraAdmin_queryRecovery_args {

  private var query = TaskQuery()

  private var session = SessionKey()

  private init() {
  }

  private init(query: TaskQuery, session: SessionKey) {
    self.query = query
    self.session = session
  }

}

private func ==(lhs: AuroraAdmin_queryRecovery_args, rhs: AuroraAdmin_queryRecovery_args) -> Bool {
  return
    (lhs.query ?== rhs.query) &&
    (lhs.session ?== rhs.session)
}

extension AuroraAdmin_queryRecovery_args : Hashable {

  private var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime * result + (query.hashValue)
    result = prime * result + (session.hashValue)
    return result
  }

}

extension AuroraAdmin_queryRecovery_args : TStruct {

  private static func readValueFromProtocol(__proto: TProtocol) throws -> AuroraAdmin_queryRecovery_args {

    try __proto.readStructBegin()

    var query : TaskQuery!
    var session : SessionKey!

    fields: while true {

      let (_, fieldType, fieldID) = try __proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .STOP):
          break fields

        case (1, .STRUCT):
          query = try __proto.readValue() as TaskQuery

        case (2, .STRUCT):
          session = try __proto.readValue() as SessionKey

        case let (_, unknownType):
          try __proto.skipType(unknownType)
      }

      try __proto.readFieldEnd()
    }

    try __proto.readStructEnd()

    // Required fields
    try __proto.validateValue(query, named: "query")
    try __proto.validateValue(session, named: "session")

    return AuroraAdmin_queryRecovery_args(query: query, session: session)
  }

  private static func writeValue(__value: AuroraAdmin_queryRecovery_args, toProtocol __proto: TProtocol) throws {

    try __proto.writeStructBeginWithName("AuroraAdmin_queryRecovery_args")

    try __proto.writeFieldValue(__value.query, name: "query", type: .STRUCT, id: 1)

    try __proto.writeFieldValue(__value.session, name: "session", type: .STRUCT, id: 2)

    try __proto.writeFieldStop()

    try __proto.writeStructEnd()
  }

}



private struct AuroraAdmin_queryRecovery_result {

  private var success : Response?

  private init() {
  }

  private init(success: Response?) {
    self.success = success
  }

}

private func ==(lhs: AuroraAdmin_queryRecovery_result, rhs: AuroraAdmin_queryRecovery_result) -> Bool {
  return
    (lhs.success ?== rhs.success)
}

extension AuroraAdmin_queryRecovery_result : Hashable {

  private var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime * result + (success?.hashValue ?? 0)
    return result
  }

}

extension AuroraAdmin_queryRecovery_result : TStruct {

  private static func readValueFromProtocol(__proto: TProtocol) throws -> AuroraAdmin_queryRecovery_result {

    try __proto.readStructBegin()

    var success : Response?

    fields: while true {

      let (_, fieldType, fieldID) = try __proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .STOP):
          break fields

        case (0, .STRUCT):
          success = try __proto.readValue() as Response

        case let (_, unknownType):
          try __proto.skipType(unknownType)
      }

      try __proto.readFieldEnd()
    }

    try __proto.readStructEnd()


    return AuroraAdmin_queryRecovery_result(success: success)
  }

  private static func writeValue(__value: AuroraAdmin_queryRecovery_result, toProtocol __proto: TProtocol) throws {

    try __proto.writeStructBeginWithName("AuroraAdmin_queryRecovery_result")

    if let result = __value.success {
      try __proto.writeFieldValue(result, name: "success", type: .STRUCT, id: 0)
    }
    try __proto.writeFieldStop()

    try __proto.writeStructEnd()
  }

}



private struct AuroraAdmin_deleteRecoveryTasks_args {

  private var query = TaskQuery()

  private var session = SessionKey()

  private init() {
  }

  private init(query: TaskQuery, session: SessionKey) {
    self.query = query
    self.session = session
  }

}

private func ==(lhs: AuroraAdmin_deleteRecoveryTasks_args, rhs: AuroraAdmin_deleteRecoveryTasks_args) -> Bool {
  return
    (lhs.query ?== rhs.query) &&
    (lhs.session ?== rhs.session)
}

extension AuroraAdmin_deleteRecoveryTasks_args : Hashable {

  private var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime * result + (query.hashValue)
    result = prime * result + (session.hashValue)
    return result
  }

}

extension AuroraAdmin_deleteRecoveryTasks_args : TStruct {

  private static func readValueFromProtocol(__proto: TProtocol) throws -> AuroraAdmin_deleteRecoveryTasks_args {

    try __proto.readStructBegin()

    var query : TaskQuery!
    var session : SessionKey!

    fields: while true {

      let (_, fieldType, fieldID) = try __proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .STOP):
          break fields

        case (1, .STRUCT):
          query = try __proto.readValue() as TaskQuery

        case (2, .STRUCT):
          session = try __proto.readValue() as SessionKey

        case let (_, unknownType):
          try __proto.skipType(unknownType)
      }

      try __proto.readFieldEnd()
    }

    try __proto.readStructEnd()

    // Required fields
    try __proto.validateValue(query, named: "query")
    try __proto.validateValue(session, named: "session")

    return AuroraAdmin_deleteRecoveryTasks_args(query: query, session: session)
  }

  private static func writeValue(__value: AuroraAdmin_deleteRecoveryTasks_args, toProtocol __proto: TProtocol) throws {

    try __proto.writeStructBeginWithName("AuroraAdmin_deleteRecoveryTasks_args")

    try __proto.writeFieldValue(__value.query, name: "query", type: .STRUCT, id: 1)

    try __proto.writeFieldValue(__value.session, name: "session", type: .STRUCT, id: 2)

    try __proto.writeFieldStop()

    try __proto.writeStructEnd()
  }

}



private struct AuroraAdmin_deleteRecoveryTasks_result {

  private var success : Response?

  private init() {
  }

  private init(success: Response?) {
    self.success = success
  }

}

private func ==(lhs: AuroraAdmin_deleteRecoveryTasks_result, rhs: AuroraAdmin_deleteRecoveryTasks_result) -> Bool {
  return
    (lhs.success ?== rhs.success)
}

extension AuroraAdmin_deleteRecoveryTasks_result : Hashable {

  private var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime * result + (success?.hashValue ?? 0)
    return result
  }

}

extension AuroraAdmin_deleteRecoveryTasks_result : TStruct {

  private static func readValueFromProtocol(__proto: TProtocol) throws -> AuroraAdmin_deleteRecoveryTasks_result {

    try __proto.readStructBegin()

    var success : Response?

    fields: while true {

      let (_, fieldType, fieldID) = try __proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .STOP):
          break fields

        case (0, .STRUCT):
          success = try __proto.readValue() as Response

        case let (_, unknownType):
          try __proto.skipType(unknownType)
      }

      try __proto.readFieldEnd()
    }

    try __proto.readStructEnd()


    return AuroraAdmin_deleteRecoveryTasks_result(success: success)
  }

  private static func writeValue(__value: AuroraAdmin_deleteRecoveryTasks_result, toProtocol __proto: TProtocol) throws {

    try __proto.writeStructBeginWithName("AuroraAdmin_deleteRecoveryTasks_result")

    if let result = __value.success {
      try __proto.writeFieldValue(result, name: "success", type: .STRUCT, id: 0)
    }
    try __proto.writeFieldStop()

    try __proto.writeStructEnd()
  }

}



private struct AuroraAdmin_commitRecovery_args {

  private var session = SessionKey()

  private init() {
  }

  private init(session: SessionKey) {
    self.session = session
  }

}

private func ==(lhs: AuroraAdmin_commitRecovery_args, rhs: AuroraAdmin_commitRecovery_args) -> Bool {
  return
    (lhs.session ?== rhs.session)
}

extension AuroraAdmin_commitRecovery_args : Hashable {

  private var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime * result + (session.hashValue)
    return result
  }

}

extension AuroraAdmin_commitRecovery_args : TStruct {

  private static func readValueFromProtocol(__proto: TProtocol) throws -> AuroraAdmin_commitRecovery_args {

    try __proto.readStructBegin()

    var session : SessionKey!

    fields: while true {

      let (_, fieldType, fieldID) = try __proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .STOP):
          break fields

        case (1, .STRUCT):
          session = try __proto.readValue() as SessionKey

        case let (_, unknownType):
          try __proto.skipType(unknownType)
      }

      try __proto.readFieldEnd()
    }

    try __proto.readStructEnd()

    // Required fields
    try __proto.validateValue(session, named: "session")

    return AuroraAdmin_commitRecovery_args(session: session)
  }

  private static func writeValue(__value: AuroraAdmin_commitRecovery_args, toProtocol __proto: TProtocol) throws {

    try __proto.writeStructBeginWithName("AuroraAdmin_commitRecovery_args")

    try __proto.writeFieldValue(__value.session, name: "session", type: .STRUCT, id: 1)

    try __proto.writeFieldStop()

    try __proto.writeStructEnd()
  }

}



private struct AuroraAdmin_commitRecovery_result {

  private var success : Response?

  private init() {
  }

  private init(success: Response?) {
    self.success = success
  }

}

private func ==(lhs: AuroraAdmin_commitRecovery_result, rhs: AuroraAdmin_commitRecovery_result) -> Bool {
  return
    (lhs.success ?== rhs.success)
}

extension AuroraAdmin_commitRecovery_result : Hashable {

  private var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime * result + (success?.hashValue ?? 0)
    return result
  }

}

extension AuroraAdmin_commitRecovery_result : TStruct {

  private static func readValueFromProtocol(__proto: TProtocol) throws -> AuroraAdmin_commitRecovery_result {

    try __proto.readStructBegin()

    var success : Response?

    fields: while true {

      let (_, fieldType, fieldID) = try __proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .STOP):
          break fields

        case (0, .STRUCT):
          success = try __proto.readValue() as Response

        case let (_, unknownType):
          try __proto.skipType(unknownType)
      }

      try __proto.readFieldEnd()
    }

    try __proto.readStructEnd()


    return AuroraAdmin_commitRecovery_result(success: success)
  }

  private static func writeValue(__value: AuroraAdmin_commitRecovery_result, toProtocol __proto: TProtocol) throws {

    try __proto.writeStructBeginWithName("AuroraAdmin_commitRecovery_result")

    if let result = __value.success {
      try __proto.writeFieldValue(result, name: "success", type: .STRUCT, id: 0)
    }
    try __proto.writeFieldStop()

    try __proto.writeStructEnd()
  }

}



private struct AuroraAdmin_unloadRecovery_args {

  private var session = SessionKey()

  private init() {
  }

  private init(session: SessionKey) {
    self.session = session
  }

}

private func ==(lhs: AuroraAdmin_unloadRecovery_args, rhs: AuroraAdmin_unloadRecovery_args) -> Bool {
  return
    (lhs.session ?== rhs.session)
}

extension AuroraAdmin_unloadRecovery_args : Hashable {

  private var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime * result + (session.hashValue)
    return result
  }

}

extension AuroraAdmin_unloadRecovery_args : TStruct {

  private static func readValueFromProtocol(__proto: TProtocol) throws -> AuroraAdmin_unloadRecovery_args {

    try __proto.readStructBegin()

    var session : SessionKey!

    fields: while true {

      let (_, fieldType, fieldID) = try __proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .STOP):
          break fields

        case (1, .STRUCT):
          session = try __proto.readValue() as SessionKey

        case let (_, unknownType):
          try __proto.skipType(unknownType)
      }

      try __proto.readFieldEnd()
    }

    try __proto.readStructEnd()

    // Required fields
    try __proto.validateValue(session, named: "session")

    return AuroraAdmin_unloadRecovery_args(session: session)
  }

  private static func writeValue(__value: AuroraAdmin_unloadRecovery_args, toProtocol __proto: TProtocol) throws {

    try __proto.writeStructBeginWithName("AuroraAdmin_unloadRecovery_args")

    try __proto.writeFieldValue(__value.session, name: "session", type: .STRUCT, id: 1)

    try __proto.writeFieldStop()

    try __proto.writeStructEnd()
  }

}



private struct AuroraAdmin_unloadRecovery_result {

  private var success : Response?

  private init() {
  }

  private init(success: Response?) {
    self.success = success
  }

}

private func ==(lhs: AuroraAdmin_unloadRecovery_result, rhs: AuroraAdmin_unloadRecovery_result) -> Bool {
  return
    (lhs.success ?== rhs.success)
}

extension AuroraAdmin_unloadRecovery_result : Hashable {

  private var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime * result + (success?.hashValue ?? 0)
    return result
  }

}

extension AuroraAdmin_unloadRecovery_result : TStruct {

  private static func readValueFromProtocol(__proto: TProtocol) throws -> AuroraAdmin_unloadRecovery_result {

    try __proto.readStructBegin()

    var success : Response?

    fields: while true {

      let (_, fieldType, fieldID) = try __proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .STOP):
          break fields

        case (0, .STRUCT):
          success = try __proto.readValue() as Response

        case let (_, unknownType):
          try __proto.skipType(unknownType)
      }

      try __proto.readFieldEnd()
    }

    try __proto.readStructEnd()


    return AuroraAdmin_unloadRecovery_result(success: success)
  }

  private static func writeValue(__value: AuroraAdmin_unloadRecovery_result, toProtocol __proto: TProtocol) throws {

    try __proto.writeStructBeginWithName("AuroraAdmin_unloadRecovery_result")

    if let result = __value.success {
      try __proto.writeFieldValue(result, name: "success", type: .STRUCT, id: 0)
    }
    try __proto.writeFieldStop()

    try __proto.writeStructEnd()
  }

}



private struct AuroraAdmin_startMaintenance_args {

  private var hosts = Hosts()

  private var session = SessionKey()

  private init() {
  }

  private init(hosts: Hosts, session: SessionKey) {
    self.hosts = hosts
    self.session = session
  }

}

private func ==(lhs: AuroraAdmin_startMaintenance_args, rhs: AuroraAdmin_startMaintenance_args) -> Bool {
  return
    (lhs.hosts ?== rhs.hosts) &&
    (lhs.session ?== rhs.session)
}

extension AuroraAdmin_startMaintenance_args : Hashable {

  private var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime * result + (hosts.hashValue)
    result = prime * result + (session.hashValue)
    return result
  }

}

extension AuroraAdmin_startMaintenance_args : TStruct {

  private static func readValueFromProtocol(__proto: TProtocol) throws -> AuroraAdmin_startMaintenance_args {

    try __proto.readStructBegin()

    var hosts : Hosts!
    var session : SessionKey!

    fields: while true {

      let (_, fieldType, fieldID) = try __proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .STOP):
          break fields

        case (1, .STRUCT):
          hosts = try __proto.readValue() as Hosts

        case (2, .STRUCT):
          session = try __proto.readValue() as SessionKey

        case let (_, unknownType):
          try __proto.skipType(unknownType)
      }

      try __proto.readFieldEnd()
    }

    try __proto.readStructEnd()

    // Required fields
    try __proto.validateValue(hosts, named: "hosts")
    try __proto.validateValue(session, named: "session")

    return AuroraAdmin_startMaintenance_args(hosts: hosts, session: session)
  }

  private static func writeValue(__value: AuroraAdmin_startMaintenance_args, toProtocol __proto: TProtocol) throws {

    try __proto.writeStructBeginWithName("AuroraAdmin_startMaintenance_args")

    try __proto.writeFieldValue(__value.hosts, name: "hosts", type: .STRUCT, id: 1)

    try __proto.writeFieldValue(__value.session, name: "session", type: .STRUCT, id: 2)

    try __proto.writeFieldStop()

    try __proto.writeStructEnd()
  }

}



private struct AuroraAdmin_startMaintenance_result {

  private var success : Response?

  private init() {
  }

  private init(success: Response?) {
    self.success = success
  }

}

private func ==(lhs: AuroraAdmin_startMaintenance_result, rhs: AuroraAdmin_startMaintenance_result) -> Bool {
  return
    (lhs.success ?== rhs.success)
}

extension AuroraAdmin_startMaintenance_result : Hashable {

  private var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime * result + (success?.hashValue ?? 0)
    return result
  }

}

extension AuroraAdmin_startMaintenance_result : TStruct {

  private static func readValueFromProtocol(__proto: TProtocol) throws -> AuroraAdmin_startMaintenance_result {

    try __proto.readStructBegin()

    var success : Response?

    fields: while true {

      let (_, fieldType, fieldID) = try __proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .STOP):
          break fields

        case (0, .STRUCT):
          success = try __proto.readValue() as Response

        case let (_, unknownType):
          try __proto.skipType(unknownType)
      }

      try __proto.readFieldEnd()
    }

    try __proto.readStructEnd()


    return AuroraAdmin_startMaintenance_result(success: success)
  }

  private static func writeValue(__value: AuroraAdmin_startMaintenance_result, toProtocol __proto: TProtocol) throws {

    try __proto.writeStructBeginWithName("AuroraAdmin_startMaintenance_result")

    if let result = __value.success {
      try __proto.writeFieldValue(result, name: "success", type: .STRUCT, id: 0)
    }
    try __proto.writeFieldStop()

    try __proto.writeStructEnd()
  }

}



private struct AuroraAdmin_drainHosts_args {

  private var hosts = Hosts()

  private var session = SessionKey()

  private init() {
  }

  private init(hosts: Hosts, session: SessionKey) {
    self.hosts = hosts
    self.session = session
  }

}

private func ==(lhs: AuroraAdmin_drainHosts_args, rhs: AuroraAdmin_drainHosts_args) -> Bool {
  return
    (lhs.hosts ?== rhs.hosts) &&
    (lhs.session ?== rhs.session)
}

extension AuroraAdmin_drainHosts_args : Hashable {

  private var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime * result + (hosts.hashValue)
    result = prime * result + (session.hashValue)
    return result
  }

}

extension AuroraAdmin_drainHosts_args : TStruct {

  private static func readValueFromProtocol(__proto: TProtocol) throws -> AuroraAdmin_drainHosts_args {

    try __proto.readStructBegin()

    var hosts : Hosts!
    var session : SessionKey!

    fields: while true {

      let (_, fieldType, fieldID) = try __proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .STOP):
          break fields

        case (1, .STRUCT):
          hosts = try __proto.readValue() as Hosts

        case (2, .STRUCT):
          session = try __proto.readValue() as SessionKey

        case let (_, unknownType):
          try __proto.skipType(unknownType)
      }

      try __proto.readFieldEnd()
    }

    try __proto.readStructEnd()

    // Required fields
    try __proto.validateValue(hosts, named: "hosts")
    try __proto.validateValue(session, named: "session")

    return AuroraAdmin_drainHosts_args(hosts: hosts, session: session)
  }

  private static func writeValue(__value: AuroraAdmin_drainHosts_args, toProtocol __proto: TProtocol) throws {

    try __proto.writeStructBeginWithName("AuroraAdmin_drainHosts_args")

    try __proto.writeFieldValue(__value.hosts, name: "hosts", type: .STRUCT, id: 1)

    try __proto.writeFieldValue(__value.session, name: "session", type: .STRUCT, id: 2)

    try __proto.writeFieldStop()

    try __proto.writeStructEnd()
  }

}



private struct AuroraAdmin_drainHosts_result {

  private var success : Response?

  private init() {
  }

  private init(success: Response?) {
    self.success = success
  }

}

private func ==(lhs: AuroraAdmin_drainHosts_result, rhs: AuroraAdmin_drainHosts_result) -> Bool {
  return
    (lhs.success ?== rhs.success)
}

extension AuroraAdmin_drainHosts_result : Hashable {

  private var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime * result + (success?.hashValue ?? 0)
    return result
  }

}

extension AuroraAdmin_drainHosts_result : TStruct {

  private static func readValueFromProtocol(__proto: TProtocol) throws -> AuroraAdmin_drainHosts_result {

    try __proto.readStructBegin()

    var success : Response?

    fields: while true {

      let (_, fieldType, fieldID) = try __proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .STOP):
          break fields

        case (0, .STRUCT):
          success = try __proto.readValue() as Response

        case let (_, unknownType):
          try __proto.skipType(unknownType)
      }

      try __proto.readFieldEnd()
    }

    try __proto.readStructEnd()


    return AuroraAdmin_drainHosts_result(success: success)
  }

  private static func writeValue(__value: AuroraAdmin_drainHosts_result, toProtocol __proto: TProtocol) throws {

    try __proto.writeStructBeginWithName("AuroraAdmin_drainHosts_result")

    if let result = __value.success {
      try __proto.writeFieldValue(result, name: "success", type: .STRUCT, id: 0)
    }
    try __proto.writeFieldStop()

    try __proto.writeStructEnd()
  }

}



private struct AuroraAdmin_maintenanceStatus_args {

  private var hosts = Hosts()

  private var session = SessionKey()

  private init() {
  }

  private init(hosts: Hosts, session: SessionKey) {
    self.hosts = hosts
    self.session = session
  }

}

private func ==(lhs: AuroraAdmin_maintenanceStatus_args, rhs: AuroraAdmin_maintenanceStatus_args) -> Bool {
  return
    (lhs.hosts ?== rhs.hosts) &&
    (lhs.session ?== rhs.session)
}

extension AuroraAdmin_maintenanceStatus_args : Hashable {

  private var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime * result + (hosts.hashValue)
    result = prime * result + (session.hashValue)
    return result
  }

}

extension AuroraAdmin_maintenanceStatus_args : TStruct {

  private static func readValueFromProtocol(__proto: TProtocol) throws -> AuroraAdmin_maintenanceStatus_args {

    try __proto.readStructBegin()

    var hosts : Hosts!
    var session : SessionKey!

    fields: while true {

      let (_, fieldType, fieldID) = try __proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .STOP):
          break fields

        case (1, .STRUCT):
          hosts = try __proto.readValue() as Hosts

        case (2, .STRUCT):
          session = try __proto.readValue() as SessionKey

        case let (_, unknownType):
          try __proto.skipType(unknownType)
      }

      try __proto.readFieldEnd()
    }

    try __proto.readStructEnd()

    // Required fields
    try __proto.validateValue(hosts, named: "hosts")
    try __proto.validateValue(session, named: "session")

    return AuroraAdmin_maintenanceStatus_args(hosts: hosts, session: session)
  }

  private static func writeValue(__value: AuroraAdmin_maintenanceStatus_args, toProtocol __proto: TProtocol) throws {

    try __proto.writeStructBeginWithName("AuroraAdmin_maintenanceStatus_args")

    try __proto.writeFieldValue(__value.hosts, name: "hosts", type: .STRUCT, id: 1)

    try __proto.writeFieldValue(__value.session, name: "session", type: .STRUCT, id: 2)

    try __proto.writeFieldStop()

    try __proto.writeStructEnd()
  }

}



private struct AuroraAdmin_maintenanceStatus_result {

  private var success : Response?

  private init() {
  }

  private init(success: Response?) {
    self.success = success
  }

}

private func ==(lhs: AuroraAdmin_maintenanceStatus_result, rhs: AuroraAdmin_maintenanceStatus_result) -> Bool {
  return
    (lhs.success ?== rhs.success)
}

extension AuroraAdmin_maintenanceStatus_result : Hashable {

  private var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime * result + (success?.hashValue ?? 0)
    return result
  }

}

extension AuroraAdmin_maintenanceStatus_result : TStruct {

  private static func readValueFromProtocol(__proto: TProtocol) throws -> AuroraAdmin_maintenanceStatus_result {

    try __proto.readStructBegin()

    var success : Response?

    fields: while true {

      let (_, fieldType, fieldID) = try __proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .STOP):
          break fields

        case (0, .STRUCT):
          success = try __proto.readValue() as Response

        case let (_, unknownType):
          try __proto.skipType(unknownType)
      }

      try __proto.readFieldEnd()
    }

    try __proto.readStructEnd()


    return AuroraAdmin_maintenanceStatus_result(success: success)
  }

  private static func writeValue(__value: AuroraAdmin_maintenanceStatus_result, toProtocol __proto: TProtocol) throws {

    try __proto.writeStructBeginWithName("AuroraAdmin_maintenanceStatus_result")

    if let result = __value.success {
      try __proto.writeFieldValue(result, name: "success", type: .STRUCT, id: 0)
    }
    try __proto.writeFieldStop()

    try __proto.writeStructEnd()
  }

}



private struct AuroraAdmin_endMaintenance_args {

  private var hosts = Hosts()

  private var session = SessionKey()

  private init() {
  }

  private init(hosts: Hosts, session: SessionKey) {
    self.hosts = hosts
    self.session = session
  }

}

private func ==(lhs: AuroraAdmin_endMaintenance_args, rhs: AuroraAdmin_endMaintenance_args) -> Bool {
  return
    (lhs.hosts ?== rhs.hosts) &&
    (lhs.session ?== rhs.session)
}

extension AuroraAdmin_endMaintenance_args : Hashable {

  private var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime * result + (hosts.hashValue)
    result = prime * result + (session.hashValue)
    return result
  }

}

extension AuroraAdmin_endMaintenance_args : TStruct {

  private static func readValueFromProtocol(__proto: TProtocol) throws -> AuroraAdmin_endMaintenance_args {

    try __proto.readStructBegin()

    var hosts : Hosts!
    var session : SessionKey!

    fields: while true {

      let (_, fieldType, fieldID) = try __proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .STOP):
          break fields

        case (1, .STRUCT):
          hosts = try __proto.readValue() as Hosts

        case (2, .STRUCT):
          session = try __proto.readValue() as SessionKey

        case let (_, unknownType):
          try __proto.skipType(unknownType)
      }

      try __proto.readFieldEnd()
    }

    try __proto.readStructEnd()

    // Required fields
    try __proto.validateValue(hosts, named: "hosts")
    try __proto.validateValue(session, named: "session")

    return AuroraAdmin_endMaintenance_args(hosts: hosts, session: session)
  }

  private static func writeValue(__value: AuroraAdmin_endMaintenance_args, toProtocol __proto: TProtocol) throws {

    try __proto.writeStructBeginWithName("AuroraAdmin_endMaintenance_args")

    try __proto.writeFieldValue(__value.hosts, name: "hosts", type: .STRUCT, id: 1)

    try __proto.writeFieldValue(__value.session, name: "session", type: .STRUCT, id: 2)

    try __proto.writeFieldStop()

    try __proto.writeStructEnd()
  }

}



private struct AuroraAdmin_endMaintenance_result {

  private var success : Response?

  private init() {
  }

  private init(success: Response?) {
    self.success = success
  }

}

private func ==(lhs: AuroraAdmin_endMaintenance_result, rhs: AuroraAdmin_endMaintenance_result) -> Bool {
  return
    (lhs.success ?== rhs.success)
}

extension AuroraAdmin_endMaintenance_result : Hashable {

  private var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime * result + (success?.hashValue ?? 0)
    return result
  }

}

extension AuroraAdmin_endMaintenance_result : TStruct {

  private static func readValueFromProtocol(__proto: TProtocol) throws -> AuroraAdmin_endMaintenance_result {

    try __proto.readStructBegin()

    var success : Response?

    fields: while true {

      let (_, fieldType, fieldID) = try __proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .STOP):
          break fields

        case (0, .STRUCT):
          success = try __proto.readValue() as Response

        case let (_, unknownType):
          try __proto.skipType(unknownType)
      }

      try __proto.readFieldEnd()
    }

    try __proto.readStructEnd()


    return AuroraAdmin_endMaintenance_result(success: success)
  }

  private static func writeValue(__value: AuroraAdmin_endMaintenance_result, toProtocol __proto: TProtocol) throws {

    try __proto.writeStructBeginWithName("AuroraAdmin_endMaintenance_result")

    if let result = __value.success {
      try __proto.writeFieldValue(result, name: "success", type: .STRUCT, id: 0)
    }
    try __proto.writeFieldStop()

    try __proto.writeStructEnd()
  }

}



private struct AuroraAdmin_snapshot_args {

  private var session = SessionKey()

  private init() {
  }

  private init(session: SessionKey) {
    self.session = session
  }

}

private func ==(lhs: AuroraAdmin_snapshot_args, rhs: AuroraAdmin_snapshot_args) -> Bool {
  return
    (lhs.session ?== rhs.session)
}

extension AuroraAdmin_snapshot_args : Hashable {

  private var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime * result + (session.hashValue)
    return result
  }

}

extension AuroraAdmin_snapshot_args : TStruct {

  private static func readValueFromProtocol(__proto: TProtocol) throws -> AuroraAdmin_snapshot_args {

    try __proto.readStructBegin()

    var session : SessionKey!

    fields: while true {

      let (_, fieldType, fieldID) = try __proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .STOP):
          break fields

        case (1, .STRUCT):
          session = try __proto.readValue() as SessionKey

        case let (_, unknownType):
          try __proto.skipType(unknownType)
      }

      try __proto.readFieldEnd()
    }

    try __proto.readStructEnd()

    // Required fields
    try __proto.validateValue(session, named: "session")

    return AuroraAdmin_snapshot_args(session: session)
  }

  private static func writeValue(__value: AuroraAdmin_snapshot_args, toProtocol __proto: TProtocol) throws {

    try __proto.writeStructBeginWithName("AuroraAdmin_snapshot_args")

    try __proto.writeFieldValue(__value.session, name: "session", type: .STRUCT, id: 1)

    try __proto.writeFieldStop()

    try __proto.writeStructEnd()
  }

}



private struct AuroraAdmin_snapshot_result {

  private var success : Response?

  private init() {
  }

  private init(success: Response?) {
    self.success = success
  }

}

private func ==(lhs: AuroraAdmin_snapshot_result, rhs: AuroraAdmin_snapshot_result) -> Bool {
  return
    (lhs.success ?== rhs.success)
}

extension AuroraAdmin_snapshot_result : Hashable {

  private var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime * result + (success?.hashValue ?? 0)
    return result
  }

}

extension AuroraAdmin_snapshot_result : TStruct {

  private static func readValueFromProtocol(__proto: TProtocol) throws -> AuroraAdmin_snapshot_result {

    try __proto.readStructBegin()

    var success : Response?

    fields: while true {

      let (_, fieldType, fieldID) = try __proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .STOP):
          break fields

        case (0, .STRUCT):
          success = try __proto.readValue() as Response

        case let (_, unknownType):
          try __proto.skipType(unknownType)
      }

      try __proto.readFieldEnd()
    }

    try __proto.readStructEnd()


    return AuroraAdmin_snapshot_result(success: success)
  }

  private static func writeValue(__value: AuroraAdmin_snapshot_result, toProtocol __proto: TProtocol) throws {

    try __proto.writeStructBeginWithName("AuroraAdmin_snapshot_result")

    if let result = __value.success {
      try __proto.writeFieldValue(result, name: "success", type: .STRUCT, id: 0)
    }
    try __proto.writeFieldStop()

    try __proto.writeStructEnd()
  }

}



private struct AuroraAdmin_rewriteConfigs_args {

  private var request = RewriteConfigsRequest()

  private var session = SessionKey()

  private init() {
  }

  private init(request: RewriteConfigsRequest, session: SessionKey) {
    self.request = request
    self.session = session
  }

}

private func ==(lhs: AuroraAdmin_rewriteConfigs_args, rhs: AuroraAdmin_rewriteConfigs_args) -> Bool {
  return
    (lhs.request ?== rhs.request) &&
    (lhs.session ?== rhs.session)
}

extension AuroraAdmin_rewriteConfigs_args : Hashable {

  private var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime * result + (request.hashValue)
    result = prime * result + (session.hashValue)
    return result
  }

}

extension AuroraAdmin_rewriteConfigs_args : TStruct {

  private static func readValueFromProtocol(__proto: TProtocol) throws -> AuroraAdmin_rewriteConfigs_args {

    try __proto.readStructBegin()

    var request : RewriteConfigsRequest!
    var session : SessionKey!

    fields: while true {

      let (_, fieldType, fieldID) = try __proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .STOP):
          break fields

        case (1, .STRUCT):
          request = try __proto.readValue() as RewriteConfigsRequest

        case (2, .STRUCT):
          session = try __proto.readValue() as SessionKey

        case let (_, unknownType):
          try __proto.skipType(unknownType)
      }

      try __proto.readFieldEnd()
    }

    try __proto.readStructEnd()

    // Required fields
    try __proto.validateValue(request, named: "request")
    try __proto.validateValue(session, named: "session")

    return AuroraAdmin_rewriteConfigs_args(request: request, session: session)
  }

  private static func writeValue(__value: AuroraAdmin_rewriteConfigs_args, toProtocol __proto: TProtocol) throws {

    try __proto.writeStructBeginWithName("AuroraAdmin_rewriteConfigs_args")

    try __proto.writeFieldValue(__value.request, name: "request", type: .STRUCT, id: 1)

    try __proto.writeFieldValue(__value.session, name: "session", type: .STRUCT, id: 2)

    try __proto.writeFieldStop()

    try __proto.writeStructEnd()
  }

}



private struct AuroraAdmin_rewriteConfigs_result {

  private var success : Response?

  private init() {
  }

  private init(success: Response?) {
    self.success = success
  }

}

private func ==(lhs: AuroraAdmin_rewriteConfigs_result, rhs: AuroraAdmin_rewriteConfigs_result) -> Bool {
  return
    (lhs.success ?== rhs.success)
}

extension AuroraAdmin_rewriteConfigs_result : Hashable {

  private var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime * result + (success?.hashValue ?? 0)
    return result
  }

}

extension AuroraAdmin_rewriteConfigs_result : TStruct {

  private static func readValueFromProtocol(__proto: TProtocol) throws -> AuroraAdmin_rewriteConfigs_result {

    try __proto.readStructBegin()

    var success : Response?

    fields: while true {

      let (_, fieldType, fieldID) = try __proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .STOP):
          break fields

        case (0, .STRUCT):
          success = try __proto.readValue() as Response

        case let (_, unknownType):
          try __proto.skipType(unknownType)
      }

      try __proto.readFieldEnd()
    }

    try __proto.readStructEnd()


    return AuroraAdmin_rewriteConfigs_result(success: success)
  }

  private static func writeValue(__value: AuroraAdmin_rewriteConfigs_result, toProtocol __proto: TProtocol) throws {

    try __proto.writeStructBeginWithName("AuroraAdmin_rewriteConfigs_result")

    if let result = __value.success {
      try __proto.writeFieldValue(result, name: "success", type: .STRUCT, id: 0)
    }
    try __proto.writeFieldStop()

    try __proto.writeStructEnd()
  }

}



extension AuroraAdminClient : AuroraAdmin {

  private func send_setQuota(ownerRole ownerRole: String, quota: ResourceAggregate, session: SessionKey) throws {

    try __outProtocol.writeMessageBeginWithName("setQuota", type: .CALL, sequenceID: 0)

    let __args = AuroraAdmin_setQuota_args(ownerRole: ownerRole, quota: quota, session: session)
    try AuroraAdmin_setQuota_args.writeValue(__args, toProtocol: __outProtocol)

    try __outProtocol.writeMessageEnd()
  }

  private func recv_setQuota() throws -> Response {

    try __inProtocol.readResultMessageBegin() 

    let __result = try AuroraAdmin_setQuota_result.readValueFromProtocol(__inProtocol)

    try __inProtocol.readMessageEnd()

    if let __success = __result.success {
      return __success
    }
    throw NSError(
      domain: TApplicationErrorDomain, 
      code: Int(TApplicationError.MissingResult.rawValue),
      userInfo: [TApplicationErrorMethodKey: "setQuota"])
  }

  public func setQuotaWithOwnerRole(ownerRole: String, quota: ResourceAggregate, session: SessionKey) throws -> Response {

    try send_setQuota(ownerRole: ownerRole, quota: quota, session: session)

    try __outProtocol.transport().flush()

    return try recv_setQuota()
  }

  private func send_forceTaskState(taskId taskId: String, status: ScheduleStatus, session: SessionKey) throws {

    try __outProtocol.writeMessageBeginWithName("forceTaskState", type: .CALL, sequenceID: 0)

    let __args = AuroraAdmin_forceTaskState_args(taskId: taskId, status: status, session: session)
    try AuroraAdmin_forceTaskState_args.writeValue(__args, toProtocol: __outProtocol)

    try __outProtocol.writeMessageEnd()
  }

  private func recv_forceTaskState() throws -> Response {

    try __inProtocol.readResultMessageBegin() 

    let __result = try AuroraAdmin_forceTaskState_result.readValueFromProtocol(__inProtocol)

    try __inProtocol.readMessageEnd()

    if let __success = __result.success {
      return __success
    }
    throw NSError(
      domain: TApplicationErrorDomain, 
      code: Int(TApplicationError.MissingResult.rawValue),
      userInfo: [TApplicationErrorMethodKey: "forceTaskState"])
  }

  public func forceTaskStateWithTaskId(taskId: String, status: ScheduleStatus, session: SessionKey) throws -> Response {

    try send_forceTaskState(taskId: taskId, status: status, session: session)

    try __outProtocol.transport().flush()

    return try recv_forceTaskState()
  }

  private func send_performBackup(session session: SessionKey) throws {

    try __outProtocol.writeMessageBeginWithName("performBackup", type: .CALL, sequenceID: 0)

    let __args = AuroraAdmin_performBackup_args(session: session)
    try AuroraAdmin_performBackup_args.writeValue(__args, toProtocol: __outProtocol)

    try __outProtocol.writeMessageEnd()
  }

  private func recv_performBackup() throws -> Response {

    try __inProtocol.readResultMessageBegin() 

    let __result = try AuroraAdmin_performBackup_result.readValueFromProtocol(__inProtocol)

    try __inProtocol.readMessageEnd()

    if let __success = __result.success {
      return __success
    }
    throw NSError(
      domain: TApplicationErrorDomain, 
      code: Int(TApplicationError.MissingResult.rawValue),
      userInfo: [TApplicationErrorMethodKey: "performBackup"])
  }

  public func performBackupWithSession(session: SessionKey) throws -> Response {

    try send_performBackup(session: session)

    try __outProtocol.transport().flush()

    return try recv_performBackup()
  }

  private func send_listBackups(session session: SessionKey) throws {

    try __outProtocol.writeMessageBeginWithName("listBackups", type: .CALL, sequenceID: 0)

    let __args = AuroraAdmin_listBackups_args(session: session)
    try AuroraAdmin_listBackups_args.writeValue(__args, toProtocol: __outProtocol)

    try __outProtocol.writeMessageEnd()
  }

  private func recv_listBackups() throws -> Response {

    try __inProtocol.readResultMessageBegin() 

    let __result = try AuroraAdmin_listBackups_result.readValueFromProtocol(__inProtocol)

    try __inProtocol.readMessageEnd()

    if let __success = __result.success {
      return __success
    }
    throw NSError(
      domain: TApplicationErrorDomain, 
      code: Int(TApplicationError.MissingResult.rawValue),
      userInfo: [TApplicationErrorMethodKey: "listBackups"])
  }

  public func listBackupsWithSession(session: SessionKey) throws -> Response {

    try send_listBackups(session: session)

    try __outProtocol.transport().flush()

    return try recv_listBackups()
  }

  private func send_stageRecovery(backupId backupId: String, session: SessionKey) throws {

    try __outProtocol.writeMessageBeginWithName("stageRecovery", type: .CALL, sequenceID: 0)

    let __args = AuroraAdmin_stageRecovery_args(backupId: backupId, session: session)
    try AuroraAdmin_stageRecovery_args.writeValue(__args, toProtocol: __outProtocol)

    try __outProtocol.writeMessageEnd()
  }

  private func recv_stageRecovery() throws -> Response {

    try __inProtocol.readResultMessageBegin() 

    let __result = try AuroraAdmin_stageRecovery_result.readValueFromProtocol(__inProtocol)

    try __inProtocol.readMessageEnd()

    if let __success = __result.success {
      return __success
    }
    throw NSError(
      domain: TApplicationErrorDomain, 
      code: Int(TApplicationError.MissingResult.rawValue),
      userInfo: [TApplicationErrorMethodKey: "stageRecovery"])
  }

  public func stageRecoveryWithBackupId(backupId: String, session: SessionKey) throws -> Response {

    try send_stageRecovery(backupId: backupId, session: session)

    try __outProtocol.transport().flush()

    return try recv_stageRecovery()
  }

  private func send_queryRecovery(query query: TaskQuery, session: SessionKey) throws {

    try __outProtocol.writeMessageBeginWithName("queryRecovery", type: .CALL, sequenceID: 0)

    let __args = AuroraAdmin_queryRecovery_args(query: query, session: session)
    try AuroraAdmin_queryRecovery_args.writeValue(__args, toProtocol: __outProtocol)

    try __outProtocol.writeMessageEnd()
  }

  private func recv_queryRecovery() throws -> Response {

    try __inProtocol.readResultMessageBegin() 

    let __result = try AuroraAdmin_queryRecovery_result.readValueFromProtocol(__inProtocol)

    try __inProtocol.readMessageEnd()

    if let __success = __result.success {
      return __success
    }
    throw NSError(
      domain: TApplicationErrorDomain, 
      code: Int(TApplicationError.MissingResult.rawValue),
      userInfo: [TApplicationErrorMethodKey: "queryRecovery"])
  }

  public func queryRecoveryWithQuery(query: TaskQuery, session: SessionKey) throws -> Response {

    try send_queryRecovery(query: query, session: session)

    try __outProtocol.transport().flush()

    return try recv_queryRecovery()
  }

  private func send_deleteRecoveryTasks(query query: TaskQuery, session: SessionKey) throws {

    try __outProtocol.writeMessageBeginWithName("deleteRecoveryTasks", type: .CALL, sequenceID: 0)

    let __args = AuroraAdmin_deleteRecoveryTasks_args(query: query, session: session)
    try AuroraAdmin_deleteRecoveryTasks_args.writeValue(__args, toProtocol: __outProtocol)

    try __outProtocol.writeMessageEnd()
  }

  private func recv_deleteRecoveryTasks() throws -> Response {

    try __inProtocol.readResultMessageBegin() 

    let __result = try AuroraAdmin_deleteRecoveryTasks_result.readValueFromProtocol(__inProtocol)

    try __inProtocol.readMessageEnd()

    if let __success = __result.success {
      return __success
    }
    throw NSError(
      domain: TApplicationErrorDomain, 
      code: Int(TApplicationError.MissingResult.rawValue),
      userInfo: [TApplicationErrorMethodKey: "deleteRecoveryTasks"])
  }

  public func deleteRecoveryTasksWithQuery(query: TaskQuery, session: SessionKey) throws -> Response {

    try send_deleteRecoveryTasks(query: query, session: session)

    try __outProtocol.transport().flush()

    return try recv_deleteRecoveryTasks()
  }

  private func send_commitRecovery(session session: SessionKey) throws {

    try __outProtocol.writeMessageBeginWithName("commitRecovery", type: .CALL, sequenceID: 0)

    let __args = AuroraAdmin_commitRecovery_args(session: session)
    try AuroraAdmin_commitRecovery_args.writeValue(__args, toProtocol: __outProtocol)

    try __outProtocol.writeMessageEnd()
  }

  private func recv_commitRecovery() throws -> Response {

    try __inProtocol.readResultMessageBegin() 

    let __result = try AuroraAdmin_commitRecovery_result.readValueFromProtocol(__inProtocol)

    try __inProtocol.readMessageEnd()

    if let __success = __result.success {
      return __success
    }
    throw NSError(
      domain: TApplicationErrorDomain, 
      code: Int(TApplicationError.MissingResult.rawValue),
      userInfo: [TApplicationErrorMethodKey: "commitRecovery"])
  }

  public func commitRecoveryWithSession(session: SessionKey) throws -> Response {

    try send_commitRecovery(session: session)

    try __outProtocol.transport().flush()

    return try recv_commitRecovery()
  }

  private func send_unloadRecovery(session session: SessionKey) throws {

    try __outProtocol.writeMessageBeginWithName("unloadRecovery", type: .CALL, sequenceID: 0)

    let __args = AuroraAdmin_unloadRecovery_args(session: session)
    try AuroraAdmin_unloadRecovery_args.writeValue(__args, toProtocol: __outProtocol)

    try __outProtocol.writeMessageEnd()
  }

  private func recv_unloadRecovery() throws -> Response {

    try __inProtocol.readResultMessageBegin() 

    let __result = try AuroraAdmin_unloadRecovery_result.readValueFromProtocol(__inProtocol)

    try __inProtocol.readMessageEnd()

    if let __success = __result.success {
      return __success
    }
    throw NSError(
      domain: TApplicationErrorDomain, 
      code: Int(TApplicationError.MissingResult.rawValue),
      userInfo: [TApplicationErrorMethodKey: "unloadRecovery"])
  }

  public func unloadRecoveryWithSession(session: SessionKey) throws -> Response {

    try send_unloadRecovery(session: session)

    try __outProtocol.transport().flush()

    return try recv_unloadRecovery()
  }

  private func send_startMaintenance(hosts hosts: Hosts, session: SessionKey) throws {

    try __outProtocol.writeMessageBeginWithName("startMaintenance", type: .CALL, sequenceID: 0)

    let __args = AuroraAdmin_startMaintenance_args(hosts: hosts, session: session)
    try AuroraAdmin_startMaintenance_args.writeValue(__args, toProtocol: __outProtocol)

    try __outProtocol.writeMessageEnd()
  }

  private func recv_startMaintenance() throws -> Response {

    try __inProtocol.readResultMessageBegin() 

    let __result = try AuroraAdmin_startMaintenance_result.readValueFromProtocol(__inProtocol)

    try __inProtocol.readMessageEnd()

    if let __success = __result.success {
      return __success
    }
    throw NSError(
      domain: TApplicationErrorDomain, 
      code: Int(TApplicationError.MissingResult.rawValue),
      userInfo: [TApplicationErrorMethodKey: "startMaintenance"])
  }

  public func startMaintenanceWithHosts(hosts: Hosts, session: SessionKey) throws -> Response {

    try send_startMaintenance(hosts: hosts, session: session)

    try __outProtocol.transport().flush()

    return try recv_startMaintenance()
  }

  private func send_drainHosts(hosts hosts: Hosts, session: SessionKey) throws {

    try __outProtocol.writeMessageBeginWithName("drainHosts", type: .CALL, sequenceID: 0)

    let __args = AuroraAdmin_drainHosts_args(hosts: hosts, session: session)
    try AuroraAdmin_drainHosts_args.writeValue(__args, toProtocol: __outProtocol)

    try __outProtocol.writeMessageEnd()
  }

  private func recv_drainHosts() throws -> Response {

    try __inProtocol.readResultMessageBegin() 

    let __result = try AuroraAdmin_drainHosts_result.readValueFromProtocol(__inProtocol)

    try __inProtocol.readMessageEnd()

    if let __success = __result.success {
      return __success
    }
    throw NSError(
      domain: TApplicationErrorDomain, 
      code: Int(TApplicationError.MissingResult.rawValue),
      userInfo: [TApplicationErrorMethodKey: "drainHosts"])
  }

  public func drainHosts(hosts: Hosts, session: SessionKey) throws -> Response {

    try send_drainHosts(hosts: hosts, session: session)

    try __outProtocol.transport().flush()

    return try recv_drainHosts()
  }

  private func send_maintenanceStatus(hosts hosts: Hosts, session: SessionKey) throws {

    try __outProtocol.writeMessageBeginWithName("maintenanceStatus", type: .CALL, sequenceID: 0)

    let __args = AuroraAdmin_maintenanceStatus_args(hosts: hosts, session: session)
    try AuroraAdmin_maintenanceStatus_args.writeValue(__args, toProtocol: __outProtocol)

    try __outProtocol.writeMessageEnd()
  }

  private func recv_maintenanceStatus() throws -> Response {

    try __inProtocol.readResultMessageBegin() 

    let __result = try AuroraAdmin_maintenanceStatus_result.readValueFromProtocol(__inProtocol)

    try __inProtocol.readMessageEnd()

    if let __success = __result.success {
      return __success
    }
    throw NSError(
      domain: TApplicationErrorDomain, 
      code: Int(TApplicationError.MissingResult.rawValue),
      userInfo: [TApplicationErrorMethodKey: "maintenanceStatus"])
  }

  public func maintenanceStatusWithHosts(hosts: Hosts, session: SessionKey) throws -> Response {

    try send_maintenanceStatus(hosts: hosts, session: session)

    try __outProtocol.transport().flush()

    return try recv_maintenanceStatus()
  }

  private func send_endMaintenance(hosts hosts: Hosts, session: SessionKey) throws {

    try __outProtocol.writeMessageBeginWithName("endMaintenance", type: .CALL, sequenceID: 0)

    let __args = AuroraAdmin_endMaintenance_args(hosts: hosts, session: session)
    try AuroraAdmin_endMaintenance_args.writeValue(__args, toProtocol: __outProtocol)

    try __outProtocol.writeMessageEnd()
  }

  private func recv_endMaintenance() throws -> Response {

    try __inProtocol.readResultMessageBegin() 

    let __result = try AuroraAdmin_endMaintenance_result.readValueFromProtocol(__inProtocol)

    try __inProtocol.readMessageEnd()

    if let __success = __result.success {
      return __success
    }
    throw NSError(
      domain: TApplicationErrorDomain, 
      code: Int(TApplicationError.MissingResult.rawValue),
      userInfo: [TApplicationErrorMethodKey: "endMaintenance"])
  }

  public func endMaintenanceWithHosts(hosts: Hosts, session: SessionKey) throws -> Response {

    try send_endMaintenance(hosts: hosts, session: session)

    try __outProtocol.transport().flush()

    return try recv_endMaintenance()
  }

  private func send_snapshot(session session: SessionKey) throws {

    try __outProtocol.writeMessageBeginWithName("snapshot", type: .CALL, sequenceID: 0)

    let __args = AuroraAdmin_snapshot_args(session: session)
    try AuroraAdmin_snapshot_args.writeValue(__args, toProtocol: __outProtocol)

    try __outProtocol.writeMessageEnd()
  }

  private func recv_snapshot() throws -> Response {

    try __inProtocol.readResultMessageBegin() 

    let __result = try AuroraAdmin_snapshot_result.readValueFromProtocol(__inProtocol)

    try __inProtocol.readMessageEnd()

    if let __success = __result.success {
      return __success
    }
    throw NSError(
      domain: TApplicationErrorDomain, 
      code: Int(TApplicationError.MissingResult.rawValue),
      userInfo: [TApplicationErrorMethodKey: "snapshot"])
  }

  public func snapshotWithSession(session: SessionKey) throws -> Response {

    try send_snapshot(session: session)

    try __outProtocol.transport().flush()

    return try recv_snapshot()
  }

  private func send_rewriteConfigs(request request: RewriteConfigsRequest, session: SessionKey) throws {

    try __outProtocol.writeMessageBeginWithName("rewriteConfigs", type: .CALL, sequenceID: 0)

    let __args = AuroraAdmin_rewriteConfigs_args(request: request, session: session)
    try AuroraAdmin_rewriteConfigs_args.writeValue(__args, toProtocol: __outProtocol)

    try __outProtocol.writeMessageEnd()
  }

  private func recv_rewriteConfigs() throws -> Response {

    try __inProtocol.readResultMessageBegin() 

    let __result = try AuroraAdmin_rewriteConfigs_result.readValueFromProtocol(__inProtocol)

    try __inProtocol.readMessageEnd()

    if let __success = __result.success {
      return __success
    }
    throw NSError(
      domain: TApplicationErrorDomain, 
      code: Int(TApplicationError.MissingResult.rawValue),
      userInfo: [TApplicationErrorMethodKey: "rewriteConfigs"])
  }

  public func rewriteConfigsWithRequest(request: RewriteConfigsRequest, session: SessionKey) throws -> Response {

    try send_rewriteConfigs(request: request, session: session)

    try __outProtocol.transport().flush()

    return try recv_rewriteConfigs()
  }

}

extension AuroraAdminProcessor : TProcessor {

  static let processorHandlers : ProcessorHandlerDictionary = {

    var processorHandlers = ProcessorHandlerDictionary()

    processorHandlers["setQuota"] = { sequenceID, inProtocol, outProtocol, handler in

      let args = try AuroraAdmin_setQuota_args.readValueFromProtocol(inProtocol)

      try inProtocol.readMessageEnd()

      var result = AuroraAdmin_setQuota_result()
      do {
        result.success = try handler.setQuotaWithOwnerRole(args.ownerRole, quota: args.quota, session: args.session)
      }
      catch let error {
        throw error
      }

      try outProtocol.writeMessageBeginWithName("setQuota", type: .REPLY, sequenceID: sequenceID)
      try AuroraAdmin_setQuota_result.writeValue(result, toProtocol: outProtocol)
      try outProtocol.writeMessageEnd()
    }
    processorHandlers["forceTaskState"] = { sequenceID, inProtocol, outProtocol, handler in

      let args = try AuroraAdmin_forceTaskState_args.readValueFromProtocol(inProtocol)

      try inProtocol.readMessageEnd()

      var result = AuroraAdmin_forceTaskState_result()
      do {
        result.success = try handler.forceTaskStateWithTaskId(args.taskId, status: args.status, session: args.session)
      }
      catch let error {
        throw error
      }

      try outProtocol.writeMessageBeginWithName("forceTaskState", type: .REPLY, sequenceID: sequenceID)
      try AuroraAdmin_forceTaskState_result.writeValue(result, toProtocol: outProtocol)
      try outProtocol.writeMessageEnd()
    }
    processorHandlers["performBackup"] = { sequenceID, inProtocol, outProtocol, handler in

      let args = try AuroraAdmin_performBackup_args.readValueFromProtocol(inProtocol)

      try inProtocol.readMessageEnd()

      var result = AuroraAdmin_performBackup_result()
      do {
        result.success = try handler.performBackupWithSession(args.session)
      }
      catch let error {
        throw error
      }

      try outProtocol.writeMessageBeginWithName("performBackup", type: .REPLY, sequenceID: sequenceID)
      try AuroraAdmin_performBackup_result.writeValue(result, toProtocol: outProtocol)
      try outProtocol.writeMessageEnd()
    }
    processorHandlers["listBackups"] = { sequenceID, inProtocol, outProtocol, handler in

      let args = try AuroraAdmin_listBackups_args.readValueFromProtocol(inProtocol)

      try inProtocol.readMessageEnd()

      var result = AuroraAdmin_listBackups_result()
      do {
        result.success = try handler.listBackupsWithSession(args.session)
      }
      catch let error {
        throw error
      }

      try outProtocol.writeMessageBeginWithName("listBackups", type: .REPLY, sequenceID: sequenceID)
      try AuroraAdmin_listBackups_result.writeValue(result, toProtocol: outProtocol)
      try outProtocol.writeMessageEnd()
    }
    processorHandlers["stageRecovery"] = { sequenceID, inProtocol, outProtocol, handler in

      let args = try AuroraAdmin_stageRecovery_args.readValueFromProtocol(inProtocol)

      try inProtocol.readMessageEnd()

      var result = AuroraAdmin_stageRecovery_result()
      do {
        result.success = try handler.stageRecoveryWithBackupId(args.backupId, session: args.session)
      }
      catch let error {
        throw error
      }

      try outProtocol.writeMessageBeginWithName("stageRecovery", type: .REPLY, sequenceID: sequenceID)
      try AuroraAdmin_stageRecovery_result.writeValue(result, toProtocol: outProtocol)
      try outProtocol.writeMessageEnd()
    }
    processorHandlers["queryRecovery"] = { sequenceID, inProtocol, outProtocol, handler in

      let args = try AuroraAdmin_queryRecovery_args.readValueFromProtocol(inProtocol)

      try inProtocol.readMessageEnd()

      var result = AuroraAdmin_queryRecovery_result()
      do {
        result.success = try handler.queryRecoveryWithQuery(args.query, session: args.session)
      }
      catch let error {
        throw error
      }

      try outProtocol.writeMessageBeginWithName("queryRecovery", type: .REPLY, sequenceID: sequenceID)
      try AuroraAdmin_queryRecovery_result.writeValue(result, toProtocol: outProtocol)
      try outProtocol.writeMessageEnd()
    }
    processorHandlers["deleteRecoveryTasks"] = { sequenceID, inProtocol, outProtocol, handler in

      let args = try AuroraAdmin_deleteRecoveryTasks_args.readValueFromProtocol(inProtocol)

      try inProtocol.readMessageEnd()

      var result = AuroraAdmin_deleteRecoveryTasks_result()
      do {
        result.success = try handler.deleteRecoveryTasksWithQuery(args.query, session: args.session)
      }
      catch let error {
        throw error
      }

      try outProtocol.writeMessageBeginWithName("deleteRecoveryTasks", type: .REPLY, sequenceID: sequenceID)
      try AuroraAdmin_deleteRecoveryTasks_result.writeValue(result, toProtocol: outProtocol)
      try outProtocol.writeMessageEnd()
    }
    processorHandlers["commitRecovery"] = { sequenceID, inProtocol, outProtocol, handler in

      let args = try AuroraAdmin_commitRecovery_args.readValueFromProtocol(inProtocol)

      try inProtocol.readMessageEnd()

      var result = AuroraAdmin_commitRecovery_result()
      do {
        result.success = try handler.commitRecoveryWithSession(args.session)
      }
      catch let error {
        throw error
      }

      try outProtocol.writeMessageBeginWithName("commitRecovery", type: .REPLY, sequenceID: sequenceID)
      try AuroraAdmin_commitRecovery_result.writeValue(result, toProtocol: outProtocol)
      try outProtocol.writeMessageEnd()
    }
    processorHandlers["unloadRecovery"] = { sequenceID, inProtocol, outProtocol, handler in

      let args = try AuroraAdmin_unloadRecovery_args.readValueFromProtocol(inProtocol)

      try inProtocol.readMessageEnd()

      var result = AuroraAdmin_unloadRecovery_result()
      do {
        result.success = try handler.unloadRecoveryWithSession(args.session)
      }
      catch let error {
        throw error
      }

      try outProtocol.writeMessageBeginWithName("unloadRecovery", type: .REPLY, sequenceID: sequenceID)
      try AuroraAdmin_unloadRecovery_result.writeValue(result, toProtocol: outProtocol)
      try outProtocol.writeMessageEnd()
    }
    processorHandlers["startMaintenance"] = { sequenceID, inProtocol, outProtocol, handler in

      let args = try AuroraAdmin_startMaintenance_args.readValueFromProtocol(inProtocol)

      try inProtocol.readMessageEnd()

      var result = AuroraAdmin_startMaintenance_result()
      do {
        result.success = try handler.startMaintenanceWithHosts(args.hosts, session: args.session)
      }
      catch let error {
        throw error
      }

      try outProtocol.writeMessageBeginWithName("startMaintenance", type: .REPLY, sequenceID: sequenceID)
      try AuroraAdmin_startMaintenance_result.writeValue(result, toProtocol: outProtocol)
      try outProtocol.writeMessageEnd()
    }
    processorHandlers["drainHosts"] = { sequenceID, inProtocol, outProtocol, handler in

      let args = try AuroraAdmin_drainHosts_args.readValueFromProtocol(inProtocol)

      try inProtocol.readMessageEnd()

      var result = AuroraAdmin_drainHosts_result()
      do {
        result.success = try handler.drainHosts(args.hosts, session: args.session)
      }
      catch let error {
        throw error
      }

      try outProtocol.writeMessageBeginWithName("drainHosts", type: .REPLY, sequenceID: sequenceID)
      try AuroraAdmin_drainHosts_result.writeValue(result, toProtocol: outProtocol)
      try outProtocol.writeMessageEnd()
    }
    processorHandlers["maintenanceStatus"] = { sequenceID, inProtocol, outProtocol, handler in

      let args = try AuroraAdmin_maintenanceStatus_args.readValueFromProtocol(inProtocol)

      try inProtocol.readMessageEnd()

      var result = AuroraAdmin_maintenanceStatus_result()
      do {
        result.success = try handler.maintenanceStatusWithHosts(args.hosts, session: args.session)
      }
      catch let error {
        throw error
      }

      try outProtocol.writeMessageBeginWithName("maintenanceStatus", type: .REPLY, sequenceID: sequenceID)
      try AuroraAdmin_maintenanceStatus_result.writeValue(result, toProtocol: outProtocol)
      try outProtocol.writeMessageEnd()
    }
    processorHandlers["endMaintenance"] = { sequenceID, inProtocol, outProtocol, handler in

      let args = try AuroraAdmin_endMaintenance_args.readValueFromProtocol(inProtocol)

      try inProtocol.readMessageEnd()

      var result = AuroraAdmin_endMaintenance_result()
      do {
        result.success = try handler.endMaintenanceWithHosts(args.hosts, session: args.session)
      }
      catch let error {
        throw error
      }

      try outProtocol.writeMessageBeginWithName("endMaintenance", type: .REPLY, sequenceID: sequenceID)
      try AuroraAdmin_endMaintenance_result.writeValue(result, toProtocol: outProtocol)
      try outProtocol.writeMessageEnd()
    }
    processorHandlers["snapshot"] = { sequenceID, inProtocol, outProtocol, handler in

      let args = try AuroraAdmin_snapshot_args.readValueFromProtocol(inProtocol)

      try inProtocol.readMessageEnd()

      var result = AuroraAdmin_snapshot_result()
      do {
        result.success = try handler.snapshotWithSession(args.session)
      }
      catch let error {
        throw error
      }

      try outProtocol.writeMessageBeginWithName("snapshot", type: .REPLY, sequenceID: sequenceID)
      try AuroraAdmin_snapshot_result.writeValue(result, toProtocol: outProtocol)
      try outProtocol.writeMessageEnd()
    }
    processorHandlers["rewriteConfigs"] = { sequenceID, inProtocol, outProtocol, handler in

      let args = try AuroraAdmin_rewriteConfigs_args.readValueFromProtocol(inProtocol)

      try inProtocol.readMessageEnd()

      var result = AuroraAdmin_rewriteConfigs_result()
      do {
        result.success = try handler.rewriteConfigsWithRequest(args.request, session: args.session)
      }
      catch let error {
        throw error
      }

      try outProtocol.writeMessageBeginWithName("rewriteConfigs", type: .REPLY, sequenceID: sequenceID)
      try AuroraAdmin_rewriteConfigs_result.writeValue(result, toProtocol: outProtocol)
      try outProtocol.writeMessageEnd()
    }
    return processorHandlers
  }()

  public func processOnInputProtocol(inProtocol: TProtocol, outputProtocol outProtocol: TProtocol) throws {

    let (messageName, _, sequenceID) = try inProtocol.readMessageBegin()

    if let processorHandler = AuroraAdminProcessor.processorHandlers[messageName] {
      do {
        try processorHandler(sequenceID, inProtocol, outProtocol, service)
      }
      catch let error as NSError {
        try outProtocol.writeExceptionForMessageName(messageName, sequenceID: sequenceID, ex: error)
      }
    }
    else {
      try inProtocol.skipType(.STRUCT)
      try inProtocol.readMessageEnd()
      try outProtocol.writeExceptionForMessageName(messageName,
        sequenceID: sequenceID,
        ex: NSError(
          domain: TApplicationErrorDomain, 
          code: Int(TApplicationError.UnknownMethod.rawValue), 
          userInfo: [TApplicationErrorMethodKey: messageName]))
    }
  }
}

